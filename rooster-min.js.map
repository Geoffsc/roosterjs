{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getInnerHTML.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeAfterLinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/teamsConverter/convertPastedContentFromTeams.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","node","nodeType","tagName","toUpperCase","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","internalContains","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","matches","msMatchesSelector","parentElement","CRLF","CRLFSPACE","shouldSkipNode","textContent","replace","region","nodeBefore","nodeAfter","html","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","beforeRunCallback","regions","getSelectedRegions","VListChain","createListChains","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","findListItems","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","originalLength","splice","mergeOrphanNodesAfter","isOrphanItem","canMerge","mergeItems","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","collapseToSingleElement","equals","blockElement","HTML_VOID_ELEMENTS","isFirst","getLeafNode","clientRect","left","right","top","bottom","tempNode","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","chains","chain","commit","color","backgroundColor","isDarkMode","darkModeColor","lightModeColor","dataset","fontName","fontFamily","fontSize","lineHeight","listType","startNumber","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","createVListFromRegion","wrapFunction","getSelectedBlockElementsInRegion","collapseNodesInRegion","NodeTag","wrap","toArray","isNodeInRegion","hasFocus","core","activeElement","contentDiv","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","options","defaultFormat","textColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","clipboardData","data","link","matchLink","text","getRangeFromText","word","getWordBefore","trailingPunctuation","match","substring","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","format","elementStyle","textColors","backgroundColors","bold","italic","underline","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","getAsString","Promise","resolve","types","getData","image","rawHtml","customValues","handlers","TEXT_TYPE_PREFIX","promise","headerValues","parseInt","workaroundForEdge","allowLinkPreview","linkPreview","JSON","parse","allowedCustomPasteType","all","handler","then","values","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","FileReader","onload","onerror","readAsDataURL","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","orderListStyles","wrapIfNotBlockNode","pop","originalRoot","nextLevel","newList","createListElement","newRoot","listStyleType","checkFirst","checkLast","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","listNode","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rect","getBoundingClientRect","rects","getClientRects","span","areAllPrevousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","currentRange","getRangeAt","removeAllRanges","e","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","j","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","className","HTML_TAG_REPLACEMENT","a","abbr","address","area","article","aside","b","bdi","bdo","blockquote","br","button","canvas","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","img","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","q","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","base","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","isReadonly","contentEditable","isEntity","eventDataCache","isCtrlOrMetaPressed","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","returnBlockElement","isBlockElement","isVoidHtmlElement","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","nonborderStyles","STYLES_TO_REMOVE","queryElements","getDefaultFormat","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","listTag","getElementAtCursor","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","src","maxWidth","imageFile","readFile","dataUrl","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","VTable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","angle","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","findClosestElementAncestor","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","borderColor","paddingLeft","PRE_TAG","level","wrapped","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","shiftKey","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","isPositionAtBeginningOf","getListChains","experimentCommitListChains","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","isNodeEmpty","OutdentWhenEnterOnEmptyLine","AutoBullet","textBeforeCursor","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","fromHtml","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","hasShiftKey","targetTd","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","deleteNode","existingNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","insertContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","getSelectionPath","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","startShadowEdit","switchShadowEdit","stopShadowEdit","isInShadowEdit","shadowEditFragment","isFeatureEnabled","experimentalFeatures","undoState","isNested","isShadowEdit","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","imageDataUri","querySelector","attrs","lastIndexOf","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","clonedNode","originalRange","shadowEditSelectionPath","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","adjustSteps","nodeToInsert","safeRemove","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","changeElementTag","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","setHtmlWithSelectionPath","isOn","wasInShadowEdit","STYLE_DATASET_MAP","ATTR_DATASET_MAP","getValueOrDefault","defualtValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","onExternalContentTransform","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","getTempDiv","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","newRange","forceInLightMode","tempDiv","onDrop","onFocus","onBlur","onScroll","onKeybaordEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","height","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","clear","getCurrentPosition","inlineElementBefore","inlineElementAfter","undoSnapshotService","createSnapshots","delta","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","y","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","ENTITY_TYPE","CORNER_HANDLE_POSITIONS","ALL_HANDLE_POSITIONS","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","startPageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","stopEvent","widthChange","heightChange","newWidth","calculateNewWidth","newHeight","calculateNewHeight","shouldPreserveRatio","isSingleDirectionNS","isSingleDirectionWE","ratio","resizeDiv","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","currentImg","showResizeHandle","createResizeDiv","selectImageAfterUnSelect","isWest","isNorth","selectedImage","divWithImage","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","tableRectMap","resizingState","insertingState","onMouseMove","cacheRects","isRTL","setCurrentTable","tdRect","normalizeRect","verticalInserterTd","preTd","previousElementSibling","setCurrentTd","setCurrentInsertTd","horizontalInserterTd","insertTd","currentInsertTd","startHorizontalResizeTable","startResizeTable","startVerticalResizeTable","frameAnimateResizeTable","resizeTable","currentTd","wordBreak","endResizeTable","setupResizerContainer","onMouseMoveDisposer","destoryRectMap","removeResizerContainer","resizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","inserterColor","HORIZONTAL_INSERTER_HTML","VERTICAL_INSERTER_HTML","horizontalResizer","verticalResizer","createResizer","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 82);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as arrayPush } from './utils/arrayPush';\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as normalizeRect } from './utils/normalizeRect';\r\nexport { default as toArray } from './utils/toArray';\r\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\r\nexport { default as readFile } from './utils/readFile';\r\nexport { default as getInnerHTML } from './utils/getInnerHTML';\r\n\r\nexport { default as VTable } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\nexport { default as VListChain } from './list/VListChain';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\r\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\r\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as commitEntity } from './entity/commitEntity';\r\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\r\nexport { default as getEntitySelector } from './entity/getEntitySelector';\r\n\r\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\r\nexport { default as isModifierKey } from './event/isModifierKey';\r\nexport { default as isCharacterValue } from './event/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\r\n\r\nexport { default as getStyles } from './style/getStyles';\r\nexport { default as setStyles } from './style/setStyles';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * @internal Export for test only\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: any,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\nimport { ChangeSource, IEditor, NodePosition, Region } from 'roosterjs-editor-types';\nimport { VListChain } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: IEditor,\n    callback: (\n        region: Region,\n        start: NodePosition,\n        end: NodePosition,\n        chains: VListChain[]\n    ) => void,\n    beforeRunCallback?: () => boolean\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        if (!beforeRunCallback || beforeRunCallback()) {\n            const regions = editor.getSelectedRegions();\n            const chains = VListChain.createListChains(regions, start?.node);\n            regions.forEach(region => callback(region, start, end, chains));\n            experimentCommitListChains(editor, chains);\n        }\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\n * A type-safe wrapper for Array.prototype.push.apply()\n * @param mainArray The main array to push items into\n * @param itemsArray The items to push to main array\n */\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\n    Array.prototype.push.apply(mainArray, itemsArray);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    private items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get list number of the last item in this VList.\n     * If there is no order list item, result will be undefined\n     */\n    getLastItemNumber(): number | undefined {\n        const start = getStart(this.rootList);\n\n        return start === undefined\n            ? start\n            : start -\n                  1 +\n                  this.items.filter(\n                      item => item.getListType() == ListType.Ordered && item.getLevel() == 1\n                  ).length;\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const doc = this.rootList.ownerDocument;\n        const listStack: Node[] = [doc.createDocumentFragment()];\n        const placeholder = doc.createTextNode('');\n        let start = getStart(this.rootList) || 1;\n        let lastList: Node;\n\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\n\n        this.items.forEach(item => {\n            item.writeBack(listStack, this.rootList);\n            const topList = listStack[1];\n\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\n                if (lastList != topList) {\n                    if (start == 1) {\n                        topList.removeAttribute('start');\n                    } else {\n                        topList.start = start;\n                    }\n                }\n\n                if (item.getLevel() == 1) {\n                    start++;\n                }\n            }\n\n            lastList = topList;\n        });\n\n        // Restore the content to the positioni of placeholder\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease ? item.outdent() : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        const nodeTag = getTagOfNode(node);\n\n        // Change DIV tag to SPAN. Otherwise we can create new list item by Enter key in Safari\n        if (nodeTag == 'DIV') {\n            node = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag != 'LI') {\n            node = wrap(node, 'LI');\n        }\n\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            const originalLength = this.items.length;\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n\n            this.mergeOrphanNodesAfter(originalLength - 1);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private mergeOrphanNodesAfter(startIndex: number) {\n        const item = this.items[startIndex];\n\n        if (item && !item.isOrphanItem()) {\n            for (let i = startIndex + 1; i <= this.items.length; i++) {\n                if (!item || !item.canMerge(this.items[i])) {\n                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));\n                    break;\n                }\n            }\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n            this.mergeOrphanNodesAfter(endIndex);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n\n        for (let item = list.firstChild; !!item; item = item.nextSibling) {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item as HTMLOListElement | HTMLUListElement, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        }\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { Region, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get the selection range in the given region.\n * The original range can cover multiple regions, this function will narrow the origianl selection\n * of a region into current region\n * @param regionBase The region to get range from\n */\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\n    if (!regionBase) {\n        return null;\n    }\n\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\n\n    if (!isRegion(regionBase)) {\n        return regionRange;\n    } else if (regionRange) {\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            return createRange(start, end);\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\n    const region = regionBase as Region;\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\n}\n","/**\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport default function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","/**\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\n * @param element The element to set styles\n * @param styles The styles to set, in name-value pair format\n */\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\n    if (element) {\n        const style = Object.keys(styles || {})\n            .map(name => {\n                let value = styles[name];\n                name = name ? name.trim() : null;\n                value = value ? value.trim() : null;\n                return name && value ? `${name}:${value}` : null;\n            })\n            .filter(x => x)\n            .join(';');\n        if (style) {\n            element.setAttribute('style', style);\n        } else {\n            element.removeAttribute('style');\n        }\n    }\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","export * from './plugins/ContentEdit/index';\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\nimport { CursorFeatures } from './features/cursorFeatures';\nimport { EntityFeatures } from './features/entityFeatures';\nimport { ListFeatures } from './features/listFeatures';\nimport { MarkdownFeatures } from './features/markdownFeatures';\nimport { QuoteFeatures } from './features/quoteFeatures';\nimport { ShortcutFeatures } from './features/shortcutFeatures';\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\nimport { TableFeatures } from './features/tableFeatures';\nimport {\n    BuildInEditFeature,\n    ContentEditFeatureSettings,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\nconst allFeatures = {\n    ...ListFeatures,\n    ...QuoteFeatures,\n    ...TableFeatures,\n    ...StructuredNodeFeatures,\n    ...AutoLinkFeatures,\n    ...ShortcutFeatures,\n    ...CursorFeatures,\n    ...MarkdownFeatures,\n    ...EntityFeatures,\n};\n\n/**\n * Get all content edit features provided by roosterjs\n */\nexport default function getAllFeatures(): Record<\n    keyof ContentEditFeatureSettings,\n    BuildInEditFeature<PluginEvent>\n> {\n    return allFeatures;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\n\n/**\n * Get innerHTML of the given node\n * @param node The DOM node to get innerHTML from\n */\nexport default function getInnerHTML(node: HTMLElement | DocumentFragment) {\n    if (safeInstanceOf(node, 'HTMLElement')) {\n        return node.innerHTML;\n    } else if (node) {\n        const tempNode = node.ownerDocument.createElement('span');\n        tempNode.appendChild(node.cloneNode(true /*deep*/));\n        return tempNode.innerHTML;\n    } else {\n        return '';\n    }\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport { RegionBase } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A type map from selector string to HTML element type\n */\nexport interface SelectorToTypeMap {\n    ol: HTMLOListElement;\n    ul: HTMLUListElement;\n    'ol,ul': HTMLOListElement | HTMLUListElement;\n}\n\n/**\n * @internal\n * Get Root list node from the given node within the given region\n * @param region Region to scope the search inot\n * @param selector The selector to search\n * @param node The start node\n */\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\n    region: RegionBase,\n    selector: TSelector,\n    node: Node\n): SelectorToTypeMap[TSelector] {\n    let list =\n        region &&\n        (findClosestElementAncestor(\n            node,\n            region.rootNode,\n            selector\n        ) as SelectorToTypeMap[TSelector]);\n\n    if (list) {\n        let ancestor: SelectorToTypeMap[TSelector];\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                selector\n            ) as SelectorToTypeMap[TSelector])\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport fromHtml from '../utils/fromHtml';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get all block elements covered by the selection under this region\n * @param regionBase The region to get block elements from\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\n * any blocks in the region. Default value is false\n */\nexport default function getSelectedBlockElementsInRegion(\n    regionBase: RegionBase,\n    createBlockIfEmpty?: boolean\n): BlockElement[] {\n    const range = getSelectionRangeInRegion(regionBase);\n    let blocks: BlockElement[] = [];\n\n    if (range) {\n        const { rootNode, skipTags } = regionBase;\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n        for (\n            let block = traverser?.currentBlockElement;\n            !!block;\n            block = traverser.getNextBlockElement()\n        ) {\n            blocks.push(block);\n        }\n\n        // Remove unmeaningful nodes\n        blocks = blocks.filter(block => {\n            const startNode = block.getStartNode();\n            const endNode = block.getEndNode();\n\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\n                startNode.parentNode?.removeChild(startNode);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\n        const newNode = fromHtml('<div><br></div>', regionBase.rootNode.ownerDocument)[0];\n        regionBase.rootNode.appendChild(newNode);\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created acording to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child bundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ascenstor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport setStyles from '../style/setStyles';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\nimport { collapse } from '../utils/collapseNodes';\nimport { safeInstanceOf } from '..';\n\n/**\n * Merge a BlockElement of given node after another node\n * @param region Region to operate in\n * @param refNode The node to merge after\n * @param targetNode The node of target block element\n */\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\n    let block: BlockElement;\n\n    if (\n        !isNodeInRegion(region, refNode) ||\n        !isNodeInRegion(region, targetNode) ||\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\n        block.contains(refNode)\n    ) {\n        return;\n    }\n\n    const blockRoot = block.collapseToSingleElement();\n    const commonContainer = collapse(\n        region.rootNode,\n        blockRoot,\n        refNode,\n        false /*isStart*/,\n        true /*canSplitParent*/\n    );\n\n    // Copy styles of parent nodes into blockRoot\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\n        const parent = node.parentNode;\n        if (safeInstanceOf(parent, 'HTMLElement')) {\n            const styles = {\n                ...(getPredefinedCssForElement(parent) || {}),\n                ...getStyles(parent),\n                ...getStyles(blockRoot),\n            };\n            setStyles(blockRoot, styles);\n        }\n        node = parent;\n    }\n\n    let nodeToRemove: Node = null;\n    let nodeToMerge =\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\n            ? blockRoot.firstChild\n            : changeElementTag(blockRoot, 'SPAN');\n\n    // Remove empty node\n    for (\n        let node: Node = nodeToMerge;\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\n        node = node.parentNode\n    ) {\n        // If the only child is the one which is about to be removed, this node should also be removed\n        nodeToRemove = node.parentNode;\n    }\n\n    // Finally, merge blocks, and remove empty nodes\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\n\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\n    B: {\n        'font-weight': 'bold',\n    },\n    EM: {\n        'font-style': 'italic',\n    },\n    I: {\n        'font-style': 'italic',\n    },\n    U: {\n        'text-decoration': 'underline',\n    },\n    P: {\n        'margin-top': '1em',\n        'margin-bottom': '1em',\n    },\n    PRE: {\n        'white-space': 'pre',\n    },\n    S: {\n        'text-decoration': 'line-through',\n    },\n    STRIKE: {\n        'text-decoration': 'line-through',\n    },\n    SUB: {\n        'vertical-align': 'sub',\n        'font-size': 'smaller',\n    },\n    SUP: {\n        'vertical-align': 'super',\n        'font-size': 'smaller',\n    },\n};\n\n/**\n * @internal\n * Get a map for browser built-in CSS definations of elements\n */\nexport default function getPredefinedCssForElement(\n    element: HTMLElement,\n    additionalPredefinedCssForElement?: PredefinedCssMap\n): StringMap {\n    const tag = getTagOfNode(element);\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: Node, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: Node): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","const CTRL_CHARCODE = 'Control';\nconst ALT_CHARCODE = 'Alt';\nconst META_CHARCODE = 'Meta';\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport default function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Position, VListChain } from 'roosterjs-editor-dom';\n\n/**\n * Commit changes of all list changes when experiment features are allowed\n * @param editor The Editor object\n * @param chains List chains to commit\n */\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\n    if (chains?.length > 0) {\n        const range = editor.getSelectionRange();\n        const start = range && Position.getStart(range);\n        const end = range && Position.getEnd(range);\n        chains.forEach(chain => chain.commit());\n        editor.select(start, end);\n    }\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\nimport { IEditor, ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function toggleListType(editor: IEditor, listType: ListType): void;\nexport default function toggleListType(\n    editor: IEditor,\n    listType: ListType.Ordered,\n    startNumber: number\n): void;\n\nexport default function toggleListType(editor: IEditor, listType: ListType, startNumber?: number) {\n    blockFormat(editor, (region, start, end, chains) => {\n        const chain =\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\n        const vList =\n            chain && start.equalTo(end)\n                ? chain.createVListAtBlock(\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\n                      startNumber\n                  )\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\n\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","import blockFormat from './blockFormat';\nimport { IEditor } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Toggle a tag at selection, if selection already contains elements of such tag,\n * the elements will be untagge and other elements will take no affect\n * @param editor The editor instance\n * @param wrapFunction  The wrap function\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\n * the loop for regions will be skipped\n */\nexport default function blockWrap(\n    editor: IEditor,\n    wrapFunction: (nodes: Node[]) => void,\n    beforeRunCallback: () => boolean\n): void {\n    blockFormat(\n        editor,\n        region => {\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n            let nodes = collapseNodesInRegion(region, blocks);\n            if (nodes.length > 0) {\n                if (nodes.length == 1) {\n                    const NodeTag = getTagOfNode(nodes[0]);\n                    if (NodeTag == 'BR') {\n                        nodes = [wrap(nodes[0])];\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\n                        nodes = toArray(nodes[0].childNodes);\n                    }\n                }\n\n                while (\n                    nodes[0] &&\n                    isNodeInRegion(region, nodes[0].parentNode) &&\n                    nodes.some(node => getTagOfNode(node) == 'LI')\n                ) {\n                    nodes = [splitBalancedNodeRange(nodes)];\n                }\n\n                wrapFunction(nodes);\n            }\n        },\n        beforeRunCallback\n    );\n}\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The EditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = (core: EditorCore) => {\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\n    return (\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\n    );\n};\n","export * from './plugins/HyperLink/index';\n","export * from './plugins/Paste/index';\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface WordCustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty WordCustomData\n */\nexport function createCustomData(): WordCustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!wordCustomData.dict[id]) {\n                // First time dictionary creation\n                wordCustomData.dict[id] = {};\n            }\n            wordCustomData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = wordCustomData.nextNodeId.toString();\n        wordCustomData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\nexport { default as getAllFeatures } from './getAllFeatures';\n","import getAllFeatures from './getAllFeatures';\nimport {\n    ContentEditFeatureSettings,\n    EditorPlugin,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    /**\n     * Create instance of ContentEdit plugin\n     * @param settingsOverride An optional feature set to override default feature settings\n     * @param additionalFeatures Optional. More features to add\n     */\n    constructor(\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor): void {\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\n        const allFeatures = getAllFeatures();\n\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\n            const feature = allFeatures[key];\n            const hasSettingForKey =\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\n\n            if (\n                (hasSettingForKey && this.settingsOverride[key]) ||\n                (!hasSettingForKey && !feature.defaultDisabled)\n            ) {\n                features.push(feature);\n            }\n        });\n\n        features\n            .concat(this.additionalFeatures || [])\n            .forEach(feature => editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose(): void {}\n}\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    AutoLinkFeatureSettings,\n    BuildInEditFeature,\n    ChangeSource,\n    ClipboardData,\n    IEditor,\n    Keys,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    clearEventDataCache,\n    LinkInlineElement,\n    matchLink,\n} from 'roosterjs-editor-dom';\n\n/**\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\n * we need to trim off the trailing puncatuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = editor.getContentSearcherOfCursor(event);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: IEditor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(editor => {\n        editor.addUndoSnapshot(\n            () => {\n                replaceWithNode(\n                    editor,\n                    linkData.originalUrl,\n                    anchor,\n                    false /* exactMatch */,\n                    searcher\n                );\n\n                // The content at cursor has changed. Should also clear the cursor data cache\n                clearEventDataCache(event);\n                return anchor;\n            },\n            ChangeSource.AutoLink,\n            true /*canUndoByBackspace*/\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const AutoLinkFeatures: Record<\n    keyof AutoLinkFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoLink: AutoLink,\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n};\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DarkModeDatasetNames, DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            elementStyle.color =\r\n                (isDarkMode ? textColors?.darkModeColor : textColors?.lightModeColor) || textColor;\r\n\r\n            if (textColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] =\r\n                    textColors.lightModeColor;\r\n            }\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            elementStyle.backgroundColor =\r\n                (isDarkMode ? backgroundColors?.darkModeColor : backgroundColors?.lightModeColor) ||\r\n                backgroundColor;\r\n\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    backgroundColors.lightModeColor;\r\n            }\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport {\r\n    ClipboardData,\r\n    EdgeLinkPreview,\r\n    ExtractClipboardEventOption,\r\n} from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\nconst TEXT_TYPE_PREFIX = 'text/';\r\nconst IMAGE_TYPE_PREFIX = 'image/';\r\nconst HTML_TYPE = TEXT_TYPE_PREFIX + 'html';\r\nconst LINKPREVIEW_TYPE = TEXT_TYPE_PREFIX + 'link-preview';\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardData) => void,\r\n    options?: ExtractClipboardEventOption\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardData = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        rawHtml: undefined,\r\n        customValues: {},\r\n    };\r\n\r\n    const handlers: {\r\n        promise: Promise<string>;\r\n        callback: (value: string) => void;\r\n    }[] = [];\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n\r\n        // Set rawHtml to null so that caller knows that we have tried\r\n        result.rawHtml = null;\r\n        const items = event.clipboardData.items;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n\r\n            switch (item.type) {\r\n                case HTML_TYPE:\r\n                    handlers.push({\r\n                        promise: getAsString(item),\r\n                        callback: value => {\r\n                            result.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value;\r\n                        },\r\n                    });\r\n                    break;\r\n                case LINKPREVIEW_TYPE:\r\n                    if (options?.allowLinkPreview) {\r\n                        handlers.push({\r\n                            promise: getAsString(item),\r\n                            callback: value => {\r\n                                try {\r\n                                    result.linkPreview = JSON.parse(value) as EdgeLinkPreview;\r\n                                } catch {}\r\n                            },\r\n                        });\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (item.type.indexOf(TEXT_TYPE_PREFIX) == 0) {\r\n                        const textType = item.type.substr(TEXT_TYPE_PREFIX.length);\r\n                        if (options?.allowedCustomPasteType?.indexOf(textType) >= 0) {\r\n                            handlers.push({\r\n                                promise: getAsString(item),\r\n                                callback: value => (result.customValues[textType] = value),\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Promise.all(handlers.map(handler => handler.promise)).then(values => {\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            handlers[i].callback(values[i]);\r\n        }\r\n\r\n        callback(result);\r\n    });\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n\r\nfunction getAsString(item: DataTransferItem): Promise<string> {\r\n    return new Promise<string>(resolve => {\r\n        item.getAsString(value => {\r\n            resolve(value);\r\n        });\r\n    });\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\n    if (file && callback) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represnets list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(private node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): Node {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is an orphan item.\n     *\n     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag\n     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.\n     *\n     * For example:\n     * ```html\n     * <ol>\n     *   <div>Orphan node</div>\n     *   <li>first item</li>\n     * </ol>\n     * ```\n     * Here the first DIV tag is an orphan item.\n     *\n     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be\n     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,\n     * those nodes will be merged into LI, so that ideally here they should not exist.\n     */\n    isOrphanItem(): boolean {\n        return getTagOfNode(this.node) != 'LI';\n    }\n\n    /**\n     * Check if the given item can be merged into this item.\n     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.\n     * @param item The item to check\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * Merge items into this item.\n     * @example Before merge:\n     * ```html\n     * <ol>\n     *   <li>Current item</li>\n     *   <div>line 1</div>\n     *   <div>line 2</div>\n     * </ol>\n     * ```\n     * After merge then two DIVs into LI:\n     * ```html\n     * <ol>\n     *   <li>Current item\n     *     <div>line 1</div>\n     *     <div>line 2</div>\n     *   </li>\n     * </ol>\n     * ```\n     * @param items The items to merge\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     */\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            while (originalRoot.firstChild) {\n                originalRoot.removeChild(originalRoot.firstChild);\n            }\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import fromHtml from '../utils/fromHtml';\nimport getRootListNode from './getRootListNode';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport Position from '../selection/Position';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport toArray from '../utils/toArray';\nimport VList from './VList';\nimport wrap from '../utils/wrap';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { ListType, Region } from 'roosterjs-editor-types';\nimport { PositionType } from 'roosterjs-editor-types';\n\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, ListSelector, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n                if (\n                    nodes.length == 1 &&\n                    safeInstanceOf(list, 'HTMLOListElement') &&\n                    list.start > 1\n                ) {\n                    // Do not include sibling lists if this list is not start from 1\n                    includeSiblingLists = false;\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\n            const newNode = fromHtml('<div><br></div>', region.rootNode.ownerDocument)[0];\n            region.rootNode.appendChild(newNode);\n            nodes.push(newNode);\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\n        }\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, ListSelector, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\n                // Only include sibling list when\n                // 1. This is a unordered list, OR\n                // 2. This list starts from 1\n                nodes.push(node);\n            }\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Wrap all child nodes under a single one, and put the new list under original root node\n    // so that the list can carry over styles under the root node.\n    const childNodes = toArray(node.childNodes);\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\n\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.appendChild(listNode);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(nodeForItem, ListType.None);\n\n    return vList;\n}\n","import arrayPush from '../utils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList {\n        if (container) {\n            const list = container.ownerDocument.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     */\n    commit() {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n            list.start = lastNumber + 1;\n\n            const vlist = new VList(list);\n\n            lastNumber = vlist.getLastItemNumber();\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack();\n        }\n    }\n\n    /**\n     * Contruct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber();\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getInnerHTML from '../utils/getInnerHTML';\nimport getSelectionPath from './getSelectionPath';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport queryElements from '../utils/queryElements';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(\n    rootNode: HTMLElement | DocumentFragment,\n    range: Range\n): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\n    let isDOMChanged = false;\n\n    queryElements(rootNode, 'table', table => {\n        let tbody: HTMLTableSectionElement = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            if (getTagOfNode(child) == 'TR') {\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n\n                isDOMChanged = true;\n            } else {\n                tbody = null;\n            }\n        }\n    });\n\n    if (range && isDOMChanged) {\n        try {\n            range.setStart(startContainer, startOffset);\n            range.setEnd(endContainer, endOffset);\n        } catch {}\n    }\n\n    const content = getInnerHTML(rootNode);\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\n\n/**\n * Add the given range into selection of the given document\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\n * otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\n    if (selection) {\n        let needAddRange = true;\n\n        if (selection.rangeCount > 0) {\n            // Workaround IE exception 800a025e\n            try {\n                let currentRange: Range;\n                // Do not remove/add range if current selection is the same with target range\n                // Without this check, execCommand() may fail in Edge since we changed the selection\n                if (\n                    (skipSameRange || Browser.isEdge) &&\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\n                    currentRange.startContainer == range.startContainer &&\n                    currentRange.startOffset == range.startOffset &&\n                    currentRange.endContainer == range.endContainer &&\n                    currentRange.endOffset == range.endOffset\n                ) {\n                    needAddRange = false;\n                } else {\n                    selection.removeAllRanges();\n                }\n            } catch (e) {}\n        }\n\n        if (needAddRange) {\n            selection.addRange(range);\n        }\n    }\n}\n","import arrayPush from '../utils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from './Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new positon to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\n    let nodeBefore: Node = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detecte them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes =>\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\n    );\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node = node.childNodes[offset - 1];\n        let nodeAfter: Node = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument.createTextNode('');\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore, nodeAfter];\n    }\n}\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        snapshots.autoCompleteIndex = -1;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Whether there is a snapshot added before auto complete and it can be undone now\n */\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\n    return (\n        snapshots.autoCompleteIndex >= 0 &&\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\n    );\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getInheritableStyles from './getInheritableStyles';\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setStyles from '../style/setStyles';\nimport toArray from '../utils/toArray';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedAttributes,\n    getAllowedCssClassesRegex,\n    getTagReplacement,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n} from './getAllowedValues';\nimport {\n    AttributeCallbackMap,\n    CssStyleCallbackMap,\n    ElementCallbackMap,\n    HtmlSanitizerOptions,\n    NodeType,\n    PredefinedCssMap,\n    SanitizeHtmlOptions,\n    StringMap,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two featuers:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: CssStyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private tagReplacements: Record<string, string>;\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalPredefinedCssForElement: PredefinedCssMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private unknownTagReplacement: string;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.unknownTagReplacement = options.unknownTagReplacement;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html || '', 'text/html');\n\n        if (doc && doc.body && doc.body.firstChild) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n\n        let shouldKeep = false;\n\n        if (isElement) {\n            const tag = getTagOfNode(node);\n            const callback = this.elementCallbacks[tag];\n            let replacement = this.tagReplacements[tag.toLowerCase()];\n\n            if (replacement === undefined) {\n                replacement = this.unknownTagReplacement;\n            }\n\n            if (callback) {\n                shouldKeep = callback(node as HTMLElement, context);\n            } else if (tag.indexOf(':') > 0) {\n                shouldKeep = true;\n            } else if (tag == replacement || replacement == '*') {\n                shouldKeep = true;\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\n                node = changeElementTag(node as HTMLElement, replacement);\n                shouldKeep = true;\n            }\n        } else if (isText) {\n            const whiteSpace = currentStyle['white-space'];\n            shouldKeep =\n                whiteSpace == 'pre' ||\n                whiteSpace == 'pre-line' ||\n                whiteSpace == 'pre-wrap' ||\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\n        } else if (isFragment) {\n            shouldKeep = true;\n        } else {\n            shouldKeep = false;\n        }\n\n        if (!shouldKeep) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            let element = <HTMLElement>node;\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.preprocessCss(element, thisStyle);\n                this.processCss(element, thisStyle, context);\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\n        const predefinedStyles = getPredefinedCssForElement(\n            element,\n            this.additionalPredefinedCssForElement\n        );\n        if (predefinedStyles) {\n            Object.keys(predefinedStyles).forEach(name => {\n                thisStyle[name] = predefinedStyles[name];\n            });\n        }\n    }\n\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\n        const styles = getStyles(element);\n        Object.keys(styles).forEach(name => {\n            const value = styles[name];\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, thisStyle, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n\n            if (!keep) {\n                delete styles[name];\n            }\n        });\n\n        setStyles(element, styles);\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n}\n","import { cloneObject } from './cloneObject';\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\n\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\n    // Allowed tags\n    a: '*',\n    abbr: '*',\n    address: '*',\n    area: '*',\n    article: '*',\n    aside: '*',\n    b: '*',\n    bdi: '*',\n    bdo: '*',\n    blockquote: '*',\n    body: '*',\n    br: '*',\n    button: '*',\n    canvas: '*',\n    caption: '*',\n    center: '*',\n    cite: '*',\n    code: '*',\n    col: '*',\n    colgroup: '*',\n    data: '*',\n    datalist: '*',\n    dd: '*',\n    del: '*',\n    details: '*',\n    dfn: '*',\n    dialog: '*',\n    dir: '*',\n    div: '*',\n    dl: '*',\n    dt: '*',\n    em: '*',\n    fieldset: '*',\n    figcaption: '*',\n    figure: '*',\n    font: '*',\n    footer: '*',\n    h1: '*',\n    h2: '*',\n    h3: '*',\n    h4: '*',\n    h5: '*',\n    h6: '*',\n    head: '*',\n    header: '*',\n    hgroup: '*',\n    hr: '*',\n    html: '*',\n    i: '*',\n    img: '*',\n    input: '*',\n    ins: '*',\n    kbd: '*',\n    label: '*',\n    legend: '*',\n    li: '*',\n    main: '*',\n    map: '*',\n    mark: '*',\n    menu: '*',\n    menuitem: '*',\n    meter: '*',\n    nav: '*',\n    ol: '*',\n    optgroup: '*',\n    option: '*',\n    output: '*',\n    p: '*',\n    picture: '*',\n    pre: '*',\n    progress: '*',\n    q: '*',\n    rp: '*',\n    rt: '*',\n    ruby: '*',\n    s: '*',\n    samp: '*',\n    section: '*',\n    select: '*',\n    small: '*',\n    span: '*',\n    strike: '*',\n    strong: '*',\n    sub: '*',\n    summary: '*',\n    sup: '*',\n    table: '*',\n    tbody: '*',\n    td: '*',\n    template: '*',\n    textarea: '*',\n    tfoot: '*',\n    th: '*',\n    thead: '*',\n    time: '*',\n    tr: '*',\n    tt: '*',\n    u: '*',\n    ul: '*',\n    var: '*',\n    wbr: '*',\n    xmp: '*',\n\n    // Replaced tags:\n    form: 'SPAN',\n\n    // Disallowed tags\n    applet: null,\n    audio: null,\n    base: null,\n    basefont: null,\n    embed: null,\n    frame: null,\n    frameset: null,\n    iframe: null,\n    link: null,\n    meta: null,\n    noscript: null,\n    object: null,\n    param: null,\n    script: null,\n    slot: null,\n    source: null,\n    style: null,\n    title: null,\n    track: null,\n    video: null,\n};\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getTagReplacement(\n    additionalReplacements: Record<string, string>\n): Record<string, string> {\n    const result = { ...HTML_TAG_REPLACEMENT };\n    const replacements = additionalReplacements || {};\n    Object.keys(replacements).forEach(key => {\n        if (key) {\n            result[key.toLowerCase()] = replacements[key];\n        }\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        cssStyleCallbacks: {},\n        additionalTagReplacements: {},\n        additionalAllowedAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        additionalPredefinedCssForElement: {},\n        unknownTagReplacement: null,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<T extends any[], R>(\n    map: Record<string, (...args: T) => R>,\n    name: string,\n    newCallback: (...args: T) => R\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: T) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE = 'contenteditable';\n\n/**\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\n * @param wrapper The entity wrapper element\n * @param type Entity type\n * @param isReadonly Whether this is a readonly entity\n * @param id Optional Id of the entity\n */\nexport default function commitEntity(\n    wrapper: HTMLElement,\n    type: string,\n    isReadonly: boolean,\n    id?: string\n) {\n    if (wrapper) {\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\n            EntityClasses.ENTITY_TYPE_PREFIX\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\n            EntityClasses.ENTITY_READONLY_PREFIX\n        }${isReadonly ? '1' : '0'}`;\n\n        if (isReadonly) {\n            wrapper.contentEditable = 'false';\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\n            wrapper.removeAttribute(CONTENT_EDITABLE);\n        }\n    }\n}\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    element?.className?.split(' ').forEach(name => {\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\n            isEntity = true;\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\n        }\n    });\n\n    return isEntity\n        ? {\n              wrapper: element,\n              id,\n              type,\n              isReadonly,\n          }\n        : null;\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport default function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\n    let result =\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter();\n    if (event) {\n        event.eventDataCache = event.eventDataCache || {};\n        event.eventDataCache[key] = result;\n    }\n\n    return result;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Clear a cached object by its key from an event object\n * @param event The event object\n * @param key The cache key\n */\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\n    if (event && event.eventDataCache) {\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\n            delete event.eventDataCache[key];\n        } else if (!key) {\n            event.eventDataCache = {};\n        }\n    }\n}\n","import isModifierKey from './isModifierKey';\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && event.key && event.key.length == 1;\n}\n","import { Browser } from '../utils/Browser';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import blockFormat from '../utils/blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    IEditor,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n        });\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Rotate an element visually\n * @param editor The editor instance\n * @param element The element that should be rotated\n * @param angle The degree at which to rotate the element from it's center\n */\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\n    if (element) {\n        editor.addUndoSnapshot(() => {\n            element.style.transform = `rotate(${angle}deg)`;\n        }, ChangeSource.Format);\n    }\n}\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { BlockElement, IEditor, Indentation, RegionBase } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    createVListFromRegion,\r\n    findClosestElementAncestor,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    const handler = indentation == Indentation.Increase ? indent : outdent;\r\n\r\n    blockFormat(editor, (region, start, end) => {\r\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n        const blockGroups: BlockElement[][] = [[]];\r\n\r\n        for (let i = 0; i < blocks.length; i++) {\r\n            const startNode = blocks[i].getStartNode();\r\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\r\n\r\n            if (vList) {\r\n                blockGroups.push([]);\r\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\r\n                    i++;\r\n                }\r\n                vList.setIndentation(start, end, indentation);\r\n                vList.writeBack();\r\n            } else {\r\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\r\n            }\r\n        }\r\n\r\n        blockGroups.forEach(group => handler(region, group));\r\n    });\r\n}\r\n\r\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\r\n    const nodes = collapseNodesInRegion(region, blocks);\r\n    wrap(nodes, BlockWrapper);\r\n}\r\n\r\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\r\n    blocks.forEach(blockElement => {\r\n        let node = blockElement.collapseToSingleElement();\r\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\r\n        if (quote) {\r\n            if (node == quote) {\r\n                node = wrap(toArray(node.childNodes));\r\n            }\r\n\r\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (isNodeInRegion(region, node)) {\r\n                unwrap(node);\r\n            }\r\n        }\r\n    });\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\nimport applyInlineStyle from '../utils/applyInlineStyle';\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environment’s current locale.\n */\nexport default function changeCapitalization(\n    editor: IEditor,\n    capitalization: Capitalization,\n    language?: string\n) {\n    applyInlineStyle(editor, element => {\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\n            if (node.nodeType == NodeType.Text) {\n                try {\n                    node.textContent = getCapitalizedText(node.textContent, language);\n                } catch {\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\n                }\n            }\n        }\n    });\n\n    function getCapitalizedText(originalText: string, language: string): string {\n        switch (capitalization) {\n            case Capitalization.Lowercase:\n                return originalText.toLocaleLowerCase(language);\n            case Capitalization.Uppercase:\n                return originalText.toLocaleUpperCase(language);\n            case Capitalization.CapitalizeEachWord:\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\n                for (let i = 0; i < wordArray.length; i++) {\n                    wordArray[i] =\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\n                }\n                return wordArray.join(' ');\n            case Capitalization.Sentence:\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                // Find a match of a word character either:\n                // - At the beginning of a string with or without preceding whitespace, for\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\n                // - Or preceded by a punctuation mark and at least one whitespace, for\n                // example 'yes. hello world' would match 'y' and 'h'.\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\n                    return match.toLocaleUpperCase(language);\n                });\n        }\n    }\n}\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    toggleListType(editor, ListType.Unordered);\r\n}\r\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n * @param startNumber (Optional) Start number of the list\r\n */\r\nexport default function toggleNumbering(editor: IEditor, startNumber?: number) {\r\n    toggleListType(editor, ListType.Ordered, startNumber);\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    CursorFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: !Browser.isChrome,\n};\n\n/**\n * @internal\n */\nexport const CursorFeatures: Record<\n    keyof CursorFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    noCycleCursorMove: NoCycleCursorMove,\n};\n","import {\n    cacheGetEventData,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    EntityFeatureSettings,\n    EntityOperation,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    operation?: EntityOperation\n) {\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const node = event.rawEvent.target as Node;\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromEnd\n        );\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromStart\n        );\n    },\n};\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    operation?: EntityOperation\n): HTMLElement {\n    const element = cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range).normalize();\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\n            let entityNode: HTMLElement = null;\n\n            if (isAtBeginOrEnd) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = isNext\n                    ? pos.offset == 0\n                        ? traverser.currentInlineElement\n                        : traverser.getNextInlineElement()\n                    : pos.isAtEnd\n                    ? traverser.currentInlineElement\n                    : traverser.getPreviousInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (!collapseOnly) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\n            }\n\n            return entityNode;\n        }\n    );\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * @internal\n */\nexport const EntityFeatures: Record<\n    keyof EntityFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    clickOnEntity: ClickOnEntityFeature,\n    escapeFromEntity: EscapeFromEntityFeature,\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\n};\n","import {\n    experimentCommitListChains,\n    setIndentation,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\nimport {\n    Browser,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n    VListChain,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Indentation,\n    ListFeatureSettings,\n    Keys,\n    NodeType,\n    PluginKeyboardEvent,\n    PositionType,\n    QueryScope,\n    RegionBase,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        let range = editor.getSelectionRange();\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li.previousSibling) {\n            const chains = getListChains(editor);\n            editor.runAsync(editor => {\n                let br = editor.getDocument().createElement('BR');\n                editor.insertNode(br);\n                editor.select(br, PositionType.After);\n                experimentCommitListChains(editor, chains);\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n    defaultDisabled: true,\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.addUndoSnapshot(\n            () => toggleListAndPreventDefault(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\n};\n\n/**\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = editor.getContentSearcherOfCursor(event);\n            let textBeforeCursor = searcher.getSubStringBefore(4);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return (\n                /^(\\*|-|[0-9]{1,2}\\.)$/.test(textBeforeCursor) &&\n                !searcher.getNearestNonTextInlineElement()\n            );\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.runAsync(editor => {\n            editor.addUndoSnapshot(\n                () => {\n                    let regions: RegionBase[];\n                    let searcher = editor.getContentSearcherOfCursor();\n                    let textBeforeCursor = searcher.getSubStringBefore(4);\n                    let rangeToDelete = searcher.getRangeFromText(\n                        textBeforeCursor,\n                        true /*exactMatch*/\n                    );\n\n                    if (!rangeToDelete) {\n                        // no op if the range can't be found\n                    } else if (\n                        textBeforeCursor.indexOf('*') == 0 ||\n                        textBeforeCursor.indexOf('-') == 0\n                    ) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleBullet(editor);\n                    } else if (textBeforeCursor.indexOf('1.') == 0) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleNumbering(editor);\n                    } else if ((regions = editor.getSelectedRegions()) && regions.length == 1) {\n                        const num = parseInt(textBeforeCursor);\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleNumbering(editor, num);\n                    }\n                },\n                null /*changeSource*/,\n                true /*canUndoByBackspace*/\n            );\n        });\n    },\n};\n\n/**\n * Maintain the list numbers in list chain\n * e.g. we have two lists:\n * 1, 2, 3 and 4, 5, 6\n * Now we delete list item 2, so the first one becomes \"1, 2\".\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\n */\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\n    shouldHandleEvent: (event, editor) =>\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\nfunction getListChains(editor: IEditor) {\n    return VListChain.createListChains(editor.getSelectedRegions());\n}\n\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\n    range.deleteContents();\n    const node = range.startContainer;\n    if (node?.nodeType == NodeType.Text && node.nodeValue == '' && !node.nextSibling) {\n        const br = editor.getDocument().createElement('BR');\n        editor.insertNode(br);\n        editor.select(br, PositionType.Before);\n    }\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n\n/**\n * @internal\n */\nexport const ListFeatures: Record<\n    keyof ListFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoBullet: AutoBullet,\n    indentWhenTab: IndentWhenTab,\n    outdentWhenShiftTab: OutdentWhenShiftTab,\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n    maintainListChain: MaintainListChain,\n};\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    ChangeSource,\n    IEditor,\n    Keys,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceeding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!!range) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                // set the removal range to include the typed last character.\n                range.setEnd(range.endContainer, range.endOffset + 1);\n\n                // extract content and put it into a new element.\n                const elementToWrap = editor.getDocument().createElement(elementTag);\n                elementToWrap.appendChild(textContentRange.extractContents());\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Bolds text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Italicises text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\n */\nconst MarkdownStrikethru: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethru,\n    markdownInlineCode: MarkdownInlineCode,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    QuoteFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) =>\n        editor.addUndoSnapshot(\n            () => splitQuote(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        ),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n\n/**\n * @internal\n */\nexport const QuoteFeatures: Record<\n    keyof QuoteFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n};\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    FontSizeChange,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ShortcutFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: IEditor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n\n/**\n * @internal\n */\nexport const ShortcutFeatures: Record<\n    keyof ShortcutFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    defaultShortcut: DefaultShortcut,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    StructuredNodeFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    fromHtml,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n// Edge can sometimes lose current format when Enter to new line.\n// So here we add an extra SPAN for Edge to workaround this bug\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n\n/**\n * @internal\n */\nexport const StructuredNodeFeatures: Record<\n    keyof StructuredNodeFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n};\n","import { editTable } from 'roosterjs-editor-api';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    NodeType,\n    PluginEvent,\n    PositionType,\n    TableFeatureSettings,\n    TableOperation,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    contains,\n    getTagOfNode,\n    isVoidHtmlElement,\n    Position,\n    VTable,\n} from 'roosterjs-editor-dom';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0) {\n                    editor.select(vtable.table, PositionType.Before);\n                    break;\n                } else if (row >= vtable.cells.length) {\n                    editTable(editor, TableOperation.InsertBelow);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        const td = cacheGetTableCell(event, editor);\n        const vtable = new VTable(td);\n        const isUp = event.rawEvent.which == Keys.UP;\n        const step = isUp ? -1 : 1;\n        const hasShiftKey = event.rawEvent.shiftKey;\n        const selection = editor.getDocument().defaultView?.getSelection();\n        let targetTd: HTMLTableCellElement = null;\n\n        if (selection) {\n            let { anchorNode, anchorOffset } = selection;\n\n            for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n                let cell = vtable.getCell(row, vtable.col);\n                if (cell.td && cell.td != td) {\n                    targetTd = cell.td;\n                    break;\n                }\n            }\n\n            editor.runAsync(editor => {\n                let newContainer = editor.getElementAtCursor();\n                if (\n                    contains(vtable.table, newContainer) &&\n                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n                ) {\n                    let newPos = targetTd\n                        ? new Position(targetTd, PositionType.Begin)\n                        : new Position(\n                              vtable.table,\n                              isUp ? PositionType.Before : PositionType.After\n                          );\n                    if (hasShiftKey) {\n                        newPos =\n                            newPos.node.nodeType == NodeType.Element &&\n                            isVoidHtmlElement(newPos.node)\n                                ? new Position(\n                                      newPos.node,\n                                      newPos.isAtEnd ? PositionType.After : PositionType.Before\n                                  )\n                                : newPos;\n                        const selection = editor.getDocument().defaultView?.getSelection();\n                        selection?.setBaseAndExtent(\n                            anchorNode,\n                            anchorOffset,\n                            newPos.node,\n                            newPos.offset\n                        );\n                    } else {\n                        editor.select(newPos);\n                    }\n                }\n            });\n        }\n    },\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const TableFeatures: Record<\n    keyof TableFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    tabInTable: TabInTable,\n    upDownInTable: UpDownInTable,\n};\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            let allNodes = fromHtml(content, doc);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView?.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Make the editor in \"Shadow Edit\" mode.\r\n     * In Shadow Edit mode, all format change will finally be ignored.\r\n     * This can be used for building a live preview feature for format button, to allow user\r\n     * see format result without really apply it.\r\n     * This function can be called repeatly. If editor is already in shadow edit mode, we can still\r\n     * use this function to do more shadow edit operation.\r\n     */\r\n    public startShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, true /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\r\n     */\r\n    public stopShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, false /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in Shadow Edit mode\r\n     */\r\n    public isInShadowEdit() {\r\n        return !!this.core.lifecycle.shadowEditFragment;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { CoreApiMap } from 'roosterjs-editor-types';\nimport { createPasteFragment } from './createPasteFragment';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { focus } from './focus';\nimport { getContent } from './getContent';\nimport { getSelectionRange } from './getSelectionRange';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { hasFocus } from './hasFocus';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { selectRange } from './selectRange';\nimport { setContent } from './setContent';\nimport { switchShadowEdit } from './switchShadowEdit';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\n\n/**\n * @internal\n */\nexport const coreApiMap: CoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    createPasteFragment,\n    ensureTypeInContainer,\n    focus,\n    getContent,\n    getSelectionRange,\n    getStyleBasedFormatState,\n    hasFocus,\n    insertNode,\n    restoreUndoSnapshot,\n    selectRange,\n    setContent,\n    switchShadowEdit,\n    transformColor,\n    triggerEvent,\n};\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    AddUndoSnapshot,\n    ChangeSource,\n    ContentChangedEvent,\n    EditorCore,\n    NodePosition,\n    PluginEventType,\n    GetContentMode,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The EditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core: EditorCore,\n    callback: (start: NodePosition, end: NodePosition) => any,\n    changeSource: ChangeSource | string,\n    canUndoByBackspace: boolean\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    const isShadowEdit = !!core.lifecycle.shadowEditFragment;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        if (!isShadowEdit) {\n            undoState.snapshotsService.addSnapshot(\n                core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                canUndoByBackspace\n            );\n            undoState.hasNewContent = false;\n        }\n    }\n\n    try {\n        if (callback) {\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested && !isShadowEdit) {\n                undoState.snapshotsService.addSnapshot(\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                    false /*isAutoCompleteSnapshot*/\n                );\n                undoState.hasNewContent = false;\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        let event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\n\n        if (range) {\n            core.undo.hasNewContent = false;\n            core.undo.autoCompletePosition = Position.getStart(range);\n        }\n    }\n};\n","import {\n    AttachDomEvent,\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    EditorCore,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (\n    core: EditorCore,\n    eventMap: Record<string, DOMEventHandler>\n) => {\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\n        let onEvent = (event: UIEvent) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n        core.contentDiv.addEventListener(eventName, onEvent);\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    CreatePasteFragment,\n    EditorCore,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\n/**\n * @internal\n * Create a DocumentFragment for paste from a ClipboardData\n * @param core The EditorCore object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param position The position to paste to\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n * false to keep original foramt\n */\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    if (!clipboardData) {\n        return null;\n    }\n\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData);\n    const { fragment, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const document = core.contentDiv.ownerDocument;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (!pasteAsText && !text && imageDataUri) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        !pasteAsText &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\n    ) {\n        // Paste HTML\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\n                startIndex + START_FRAGMENT.length,\n                endIndex\n            );\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        while (doc.body.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        // Paste text\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n            const textNode = document.createTextNode(line);\n\n            // There are 3 scenarios:\n            // 1. Single line: Paste as it is\n            // 2. Two lines: Add <br> between the lines\n            // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line\n            if (lines.length == 2 && index == 0) {\n                // 1 of 2 lines scenario, add BR\n                fragment.appendChild(textNode);\n                fragment.appendChild(document.createElement('br'));\n            } else if (index > 0 && index < lines.length - 1) {\n                // Middle line of >=3 lines scenario, wrap with DIV\n                fragment.appendChild(wrap(line == '' ? document.createElement('br') : textNode));\n            } else {\n                // All others, paste as it is\n                fragment.appendChild(textNode);\n            }\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedForamt.fontName,\n        fontSize: styleBasedForamt.fontSize,\n        textColor: styleBasedForamt.textColor,\n        backgroundColor: styleBasedForamt.backgroundColor,\n        textColors: styleBasedForamt.textColors,\n        backgroundColors: styleBasedForamt.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    toArray(node.querySelectorAll('style')).forEach(callback);\n}\n","import {\n    ContentPosition,\n    EditorCore,\n    EnsureTypeInContainer,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    applyFormat,\n    Browser,\n    createRange,\n    fromHtml,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\n    core: EditorCore,\n    position: NodePosition,\n    keyboardEvent?: KeyboardEvent\n) => {\n    position = position.normalize();\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = fromHtml(\n            Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\n            core.contentDiv.ownerDocument\n        )[0] as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode.firstChild, PositionType.Begin);\n    }\n\n    if (formatNode) {\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.selectRange(core, createRange(position));\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = (core: EditorCore) => {\n    if (!core.lifecycle.shadowEditFragment) {\n        if (\n            !core.api.hasFocus(core) ||\n            !core.api.getSelectionRange(core, false /*tryGetFromCache*/)\n        ) {\n            // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\n            // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\n            // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\n            // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\n            // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\n            // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\n            // It should be better than the case you cannot type\n            if (\n                !core.domEvent.selectionRange ||\n                !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\n            ) {\n                let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\n                core.api.selectRange(\n                    core,\n                    createRange(node, PositionType.Begin),\n                    true /*skipSameRange*/\n                );\n            }\n        }\n\n        // remember to clear cached selection range\n        core.domEvent.selectionRange = null;\n\n        // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import {\n    ColorTransformDirection,\n    EditorCore,\n    GetContent,\n    GetContentMode,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The EditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\n    let content = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommited shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\n        const clonedRoot = cloneNode(root);\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n        const path = !includeSelectionMarker\n            ? null\n            : core.lifecycle.shadowEditFragment\n            ? core.lifecycle.shadowEditSelectionPath\n            : originalRange\n            ? getSelectionPath(core.contentDiv, originalRange)\n            : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        if (core.lifecycle.isDarkMode) {\n            core.api.transformColor(\n                core,\n                clonedRoot,\n                false /*includeSelf*/,\n                null /*callback*/,\n                ColorTransformDirection.DarkToLight\n            );\n        }\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    } else {\n        content = getHtmlWithSelectionPath(\n            root,\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\n        );\n    }\n\n    return content;\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, createRange } from 'roosterjs-editor-dom';\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get current or cached selection range\n * @param core The EditorCore object\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\n * @returns A Range object of the selection range\n */\nexport const getSelectionRange: GetSelectionRange = (\n    core: EditorCore,\n    tryGetFromCache: boolean\n) => {\n    let result: Range = null;\n\n    if (core.lifecycle.shadowEditFragment) {\n        result =\n            core.lifecycle.shadowEditSelectionPath &&\n            createRange(\n                core.contentDiv,\n                core.lifecycle.shadowEditSelectionPath.start,\n                core.lifecycle.shadowEditSelectionPath.end\n            );\n\n        return result;\n    } else {\n        if (!tryGetFromCache || core.api.hasFocus(core)) {\n            let selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                let range = selection.getRangeAt(0);\n                if (contains(core.contentDiv, range)) {\n                    result = range;\n                }\n            }\n        }\n\n        if (!result && tryGetFromCache) {\n            result = core.domEvent.selectionRange;\n        }\n\n        return result;\n    }\n};\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.lifecycle.isDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor:\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\n                      ] ||\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\n                      ],\n              }\n            : undefined,\n    };\n};\n","import {\n    BlockElement,\n    ContentPosition,\n    ColorTransformDirection,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodeType,\n    NodePosition,\n    PositionType,\n    QueryScope,\n} from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    contains,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    getTagOfNode,\n    isBlockElement,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    isVoidHtmlElement,\n    Position,\n    queryElements,\n    safeInstanceOf,\n    splitBalancedNodeRange,\n    splitTextNode,\n    toArray,\n    unwrap,\n    VTable,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range; rangeToRestore: Range } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n    };\n    let contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    let isBegin = option.position == ContentPosition.Begin;\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[];\n                    if (block) {\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    let insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos = Position.getStart(range);\n                    let blockElement: BlockElement;\n\n                    if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\n                    } else {\n                        adjustSteps.forEach(handler => {\n                            pos = handler(contentDiv, node, pos);\n                        });\n                    }\n\n                    let nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n                    range = createRange(pos);\n                    range.insertNode(node);\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n                    core.api.selectRange(core, rangeToRestore);\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction handleHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter(a => blockElement.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\n        ) {\n            let normalizedPosition = position.normalize();\n            let parentNode = normalizedPosition.node.parentNode;\n            let nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            position = new Position(splitter, PositionType.Before);\n            safeRemove(splitter);\n        }\n    }\n\n    return position;\n}\n\nfunction handleStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let rootNodeToInsert = nodeToInsert;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\n    }\n\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem,\n                isPositionAtBeginningOf(position, listItem)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    } else if (tag == 'TABLE' && trNode) {\n        // When inserting a table into a table, if these tables have the same column count, and\n        // current position is at beginning of a row, then merge these two tables\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\n        if (\n            currentTable.col == 0 &&\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\n            newTable.cells[0] &&\n            newTable.cells[0].length == currentTable.cells[0].length &&\n            isPositionAtBeginningOf(position, tdNode)\n        ) {\n            if (\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\n                !rootNodeToInsert.firstChild.nextSibling\n            ) {\n                unwrap(rootNodeToInsert.firstChild);\n            }\n            unwrap(rootNodeToInsert);\n            position = new Position(trNode, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction handleParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        let pos = position.normalize();\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\nfunction handleVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\nimport { hasFocus } from './hasFocus';\nimport {\n    contains,\n    getPendableFormatState,\n    Position,\n    PendableFormatNames,\n    PendableFormatCommandMap,\n    addRangeToSelection,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Change the editor selection to the given range\n * @param core The EditorCore object\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport const selectRange: SelectRange = (\n    core: EditorCore,\n    range: Range,\n    skipSameRange?: boolean\n) => {\n    if (!core.lifecycle.shadowEditSelectionPath && contains(core.contentDiv, range)) {\n        addRangeToSelection(range, skipSameRange);\n\n        if (!hasFocus(core)) {\n            core.domEvent.selectionRange = range;\n        }\n\n        if (range.collapsed) {\n            // If selected, and current selection is collapsed,\n            // need to restore pending format state if exists.\n            restorePendingFormatState(core);\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Restore cached pending format state (if exist) to current selection\n */\nfunction restorePendingFormatState(core: EditorCore) {\n    const {\n        contentDiv,\n        pendingFormatState,\n        api: { getSelectionRange },\n    } = core;\n\n    if (pendingFormatState.pendableFormatState) {\n        const document = contentDiv.ownerDocument;\n        let formatState = getPendableFormatState(document);\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\n                document.execCommand(PendableFormatCommandMap[key], false, null);\n            }\n        });\n\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\n    }\n}\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    EditorCore,\n    PluginEventType,\n    SetContent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The EditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n */\nexport const setContent: SetContent = (\n    core: EditorCore,\n    content: string,\n    triggerContentChangedEvent: boolean\n) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        const range = setHtmlWithSelectionPath(core.contentDiv, content);\n        core.api.selectRange(core, range);\n        contentChanged = true;\n    }\n\n    // Convert content even if it hasn't changed.\n    core.api.transformColor(\n        core,\n        core.contentDiv,\n        false /*includeSelf*/,\n        null /*callback*/,\n        ColorTransformDirection.LightToDark\n    );\n\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n","import { createRange, getSelectionPath } from 'roosterjs-editor-dom';\nimport { EditorCore, PluginEventType, SwitchShadowEdit } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const switchShadowEdit: SwitchShadowEdit = (core: EditorCore, isOn: boolean): void => {\n    const { lifecycle, contentDiv } = core;\n    let { shadowEditFragment, shadowEditSelectionPath } = lifecycle;\n    const wasInShadowEdit = !!shadowEditFragment;\n\n    if (isOn) {\n        if (!wasInShadowEdit) {\n            const range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            shadowEditSelectionPath = range && getSelectionPath(contentDiv, range);\n            shadowEditFragment = core.contentDiv.ownerDocument.createDocumentFragment();\n            while (contentDiv.firstChild) {\n                shadowEditFragment.appendChild(contentDiv.firstChild);\n            }\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment: shadowEditFragment,\n                    selectionPath: shadowEditSelectionPath,\n                },\n                false /*broadcast*/\n            );\n\n            lifecycle.shadowEditFragment = shadowEditFragment;\n            lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;\n        }\n\n        contentDiv.innerHTML = '';\n        contentDiv.appendChild(lifecycle.shadowEditFragment.cloneNode(true /*deep*/));\n    } else {\n        lifecycle.shadowEditFragment = null;\n        lifecycle.shadowEditSelectionPath = null;\n\n        if (wasInShadowEdit) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            contentDiv.innerHTML = '';\n            contentDiv.appendChild(shadowEditFragment);\n            core.api.focus(core);\n\n            if (shadowEditSelectionPath) {\n                core.api.selectRange(\n                    core,\n                    createRange(\n                        contentDiv,\n                        shadowEditSelectionPath.start,\n                        shadowEditSelectionPath.end\n                    )\n                );\n            }\n        }\n    }\n};\n","import { arrayPush, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\nimport {\n    ColorTransformDirection,\n    DarkModeDatasetNames,\n    EditorCore,\n    TransformColor,\n} from 'roosterjs-editor-types';\n\nconst STYLE_DATASET_MAP = {\n    /**\n     * Original style color\n     */\n    [DarkModeDatasetNames.OriginalStyleColor]: (element: HTMLElement, value: string) =>\n        (element.style.color = value),\n\n    /**\n     * Original style background color\n     */\n    [DarkModeDatasetNames.OriginalStyleBackgroundColor]: (element: HTMLElement, value: string) =>\n        (element.style.backgroundColor = value),\n};\nconst ATTR_DATASET_MAP = {\n    /**\n     * Original attribute color\n     */\n    [DarkModeDatasetNames.OriginalAttributeColor]: 'color',\n\n    /**\n     * Original attribute background color\n     */\n    [DarkModeDatasetNames.OriginalAttributeBackgroundColor]: 'bgcolor',\n};\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The EditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n */\nexport const transformColor: TransformColor = (\n    core: EditorCore,\n    rootNode: Node,\n    includeSelf: boolean,\n    callback: () => void,\n    direction: ColorTransformDirection\n) => {\n    let elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\n\n    callback?.();\n\n    elementsToTransform.forEach(element => {\n        if (direction == ColorTransformDirection.DarkToLight && element?.dataset) {\n            // Reset color styles based on the content of the ogsc/ogsb data element.\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\n            Object.keys(STYLE_DATASET_MAP).forEach((name: keyof typeof STYLE_DATASET_MAP) => {\n                STYLE_DATASET_MAP[name](element, getValueOrDefault(element.dataset[name], ''));\n                delete element.dataset[name];\n            });\n\n            // Some elements might have set attribute colors. We need to reset these as well.\n            Object.keys(ATTR_DATASET_MAP).forEach((name: keyof typeof ATTR_DATASET_MAP) => {\n                const value = element.dataset[name];\n                if (getValueOrDefault(value, null)) {\n                    element.setAttribute(ATTR_DATASET_MAP[name], value);\n                } else {\n                    element.removeAttribute(ATTR_DATASET_MAP[name]);\n                }\n                delete element.dataset[name];\n            });\n        } else if (direction == ColorTransformDirection.LightToDark && element) {\n            if (core.lifecycle.onExternalContentTransform) {\n                core.lifecycle.onExternalContentTransform(element);\n            } else {\n                element.style.color = null;\n                element.style.backgroundColor = null;\n            }\n        }\n    });\n};\n\nfunction getValueOrDefault(value: string, defualtValue: string | null) {\n    return value && value != 'undefined' && value != 'null' ? value : defualtValue;\n}\n\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\n        if (includeSelf) {\n            result.push(rootNode);\n        }\n        const allChildren = rootNode.getElementsByTagName('*');\n        arrayPush(result, toArray(allChildren));\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\n        const allChildren = rootNode.querySelectorAll('*');\n        arrayPush(result, toArray(allChildren));\n    }\n\n    return result;\n}\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (\n    core: EditorCore,\n    pluginEvent: PluginEvent,\n    broadcast: boolean\n) => {\n    if (\n        !core.lifecycle.shadowEditFragment &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import CopyPastePlugin from './CopyPastePlugin';\nimport DOMEventPlugin from './DOMEventPlugin';\nimport EditPlugin from './EditPlugin';\nimport EntityPlugin from './EntityPlugin';\nimport LifecyclePlugin from './LifecyclePlugin';\nimport MouseUpPlugin from './MouseUpPlugin';\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\nimport TypeAfterLinkPlugin from './TypeAfterLinkPlugin';\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\nimport UndoPlugin from './UndoPlugin';\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\n\n/**\n * @internal\n * Create Core Plugins\n * @param contentDiv Content DIV of editor\n * @param options Editor options\n */\nexport default function createCorePlugins(\n    contentDiv: HTMLDivElement,\n    options: EditorOptions\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\n    const map = options.corePluginOverride || {};\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\n        edit: map.edit || new EditPlugin(),\n        _placeholder: null,\n        typeAfterLink: map.typeAfterLink || new TypeAfterLinkPlugin(),\n        undo: map.undo || new UndoPlugin(options),\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\n        copyPaste: map.copyPaste || new CopyPastePlugin(options),\n        entity: map.entity || new EntityPlugin(),\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins CorePlugins object\n */\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\n        edit: corePlugins.edit.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        undo: corePlugins.undo.getState(),\n        entity: corePlugins.entity.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n    };\n}\n","import {\n    addRangeToSelection,\n    extractClipboardEvent,\n    fromHtml,\n    readFile,\n    setHtmlWithSelectionPath,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ClipboardData,\n    ContentPosition,\n    CopyPastePluginState,\n    EditorOptions,\n    GetContentMode,\n    IEditor,\n    PluginEventType,\n    ExperimentalFeatures,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML =\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\n\n/**\n * @internal\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nexport default class CopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param options The editor options\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            allowedCustomPasteType: options.allowedCustomPasteType || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: this.onPaste,\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        const originalRange = this.editor.getSelectionRange();\n        if (originalRange && !originalRange.collapsed) {\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\n            const newRange = setHtmlWithSelectionPath(tempDiv, html);\n\n            if (newRange) {\n                addRangeToSelection(newRange);\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event as ClipboardEvent,\n                isCut,\n            });\n\n            this.editor.runAsync(editor => {\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\n\n                if (isCut) {\n                    editor.addUndoSnapshot(() => {\n                        const position = this.editor.deleteSelectedContent();\n                        editor.focus();\n                        editor.select(position);\n                    }, ChangeSource.Cut);\n                }\n            });\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        extractClipboardEvent(\n            event as ClipboardEvent,\n            items => {\n                if (items.rawHtml === undefined) {\n                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\n                    // This is mostly for IE\n                    const originalSelectionRange = this.editor.getSelectionRange();\n                    const tempDiv = this.getTempDiv();\n\n                    this.editor.runAsync(() => {\n                        items.rawHtml = tempDiv.innerHTML;\n                        this.cleanUpAndRestoreSelection(tempDiv, originalSelectionRange);\n                        this.paste(items);\n                    });\n                } else {\n                    this.paste(items);\n                }\n            },\n            {\n                allowLinkPreview: this.editor.isFeatureEnabled(\n                    ExperimentalFeatures.PasteWithLinkPreview\n                ),\n                allowedCustomPasteType: this.state.allowedCustomPasteType,\n            }\n        );\n    };\n\n    private paste(clipboardData: ClipboardData) {\n        if (clipboardData.image) {\n            readFile(clipboardData.image, dataUrl => {\n                clipboardData.imageDataUri = dataUrl;\n                this.editor.paste(clipboardData);\n            });\n        } else {\n            this.editor.paste(clipboardData);\n        }\n    }\n\n    private getTempDiv(forceInLightMode?: boolean) {\n        const div = this.editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = fromHtml(\n                    CONTAINER_HTML,\n                    this.editor.getDocument()\n                )[0] as HTMLDivElement;\n                this.editor.insertNode(tempDiv, {\n                    position: ContentPosition.Outside,\n                });\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        if (forceInLightMode) {\n            div.style.backgroundColor = 'white';\n            div.style.color = 'black';\n        }\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\n        this.editor.select(range);\n        tempDiv.style.backgroundColor = '';\n        tempDiv.style.color = '';\n        tempDiv.style.display = 'none';\n        tempDiv.innerHTML = '';\n    }\n}\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContextMenuProvider,\n    DOMEventHandler,\n    DOMEventPluginState,\n    EditorOptions,\n    IEditor,\n    PluginEventType,\n    PluginWithState,\n    EditorPlugin,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n */\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            selectionRange: null,\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        this.disposer = editor.addDomEventHandler({\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: PluginEventType.MouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drop event\n            drop: this.onDrop,\n\n            // 5. Focus mangement\n            focus: this.onFocus,\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\n\n            // 6. Input event\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\n        });\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDrop = (e: UIEvent) => {\n        this.editor.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onFocus = () => {\n        this.editor.select(this.state.selectionRange);\n        this.state.selectionRange = null;\n    };\n\n    private onBlur = () => {\n        this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\n    };\n\n    private onScroll = (e: UIEvent) => {\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        return this.state.stopPrintableKeyboardEventPropagation\n            ? {\n                  pluginEventType: eventType,\n                  beforeDispatch:\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeybaordEvent,\n              }\n            : eventType;\n    }\n\n    private onKeybaordEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event)) {\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n        const searcher = this.editor.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2) {\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode);\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n                arrayPush(allItems, items);\n            }\n        });\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n        let ctrlOrMeta = false;\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                break;\n            }\n        }\n    }\n}\n","import {\n    Browser,\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    isCharacterValue,\n    toArray,\n    arrayPush,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    EntityClasses,\n    EntityOperation,\n    EntityPluginState,\n    HtmlSanitizerOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    QueryScope,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\n\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\nconst ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            clickingPoint: null,\n            knownEntityElements: [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.knownEntityElements = [];\n        this.state.clickingPoint = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.handleCutEvent(event.rawEvent);\n                }\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n            case PluginEventType.ContextMenu:\n                this.handleContextMenuEvent(event.rawEvent);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent(event: UIEvent) {\n        const node = event.target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n\n        if (entityElement) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\n        }\n    }\n\n    private handleCutEvent = (event: ClipboardEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (range && !range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.state.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        let entityElement: HTMLElement;\n\n        if (\n            this.state.clickingPoint &&\n            this.state.clickingPoint.pageX == pageX &&\n            this.state.clickingPoint.pageY == pageY &&\n            node &&\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\n        ) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.state.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.state.knownEntityElements = resetAll\n            ? []\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\n        const allId = this.state.knownEntityElements\n            .map(e => getEntityFromElement(e)?.id)\n            .filter(x => !!x);\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\n                this.state.knownEntityElements.push(element);\n\n                const entity = getEntityFromElement(element);\n\n                this.hydrateEntity(entity, allId);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\n        });\n    }\n\n    private checkRemoveEntityForRange(event: Event) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                this.triggerEvent(\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\n        const { id, type, wrapper, isReadonly } = entity;\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            if (knownIds.indexOf(newId) < 0) {\n                knownIds.push(newId);\n                break;\n            }\n        }\n\n        commitEntity(wrapper, type, isReadonly, newId);\n\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\n    }\n\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\n        const entity = element && getEntityFromElement(element);\n\n        if (entity) {\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                operation,\n                rawEvent,\n                entity,\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: IEditor) => {\n          editor.runAsync(editor => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import { Browser, getComputedStyles } from 'roosterjs-editor-dom';\nimport {\n    DefaultFormat,\n    DocumentCommand,\n    EditorOptions,\n    IEditor,\n    LifecyclePluginState,\n    PluginEventType,\n    PluginWithState,\n    PluginEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\nconst COMMANDS: {\n    [command: string]: any;\n} = Browser.isFirefox\n    ? {\n          /**\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\n           */\n          [DocumentCommand.EnableObjectResizing]: false,\n          [DocumentCommand.EnableInlineTableEditing]: false,\n      }\n    : Browser.isIE\n    ? {\n          /**\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\n           */\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\n\n          /**\n           * Disable auto link feature in IE since we have our own implementation\n           */\n          [DocumentCommand.AutoUrlDetect]: false,\n      }\n    : {};\n\nconst DARK_MODE_DEFAULT_FORMAT = {\n    backgroundColors: {\n        darkModeColor: 'rgb(51,51,51)',\n        lightModeColor: 'rgb(255,255,255)',\n    },\n    textColors: {\n        darkModeColor: 'rgb(255,255,255)',\n        lightModeColor: 'rgb(0,0,0)',\n    },\n};\n\n/**\n * @internal\n * Lifecycle plugin handles editor initialization and disposing\n */\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor;\n    private state: LifecyclePluginState;\n    private initialContent: string;\n    private contentDivFormat: string[];\n    private initializer: () => void;\n    private disposer: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\n        this.contentDivFormat = getComputedStyles(contentDiv);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                this.setSelectStyle(contentDiv, 'text');\n            };\n            this.disposer = () => {\n                this.setSelectStyle(contentDiv, '');\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\n            };\n        }\n\n        this.state = {\n            customData: {},\n            defaultFormat: options.defaultFormat || null,\n            isDarkMode: !!options.inDarkMode,\n            onExternalContentTransform: options.onExternalContentTransform,\n            experimentalFeatures: options.experimentalFeatures || [],\n            shadowEditFragment: null,\n            shadowEditSelectionPath: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Calculate default format\n        this.recalculateDefaultFormat();\n\n        // Ensure initial content and its format\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Do proper change for browsers to disable some browser-specified behaviors.\n        this.adjustBrowserBehavior();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        Object.keys(this.state.customData).forEach(key => {\n            const data = this.state.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete this.state.customData[key];\n        });\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.recalculateDefaultFormat();\n        }\n    }\n\n    private adjustBrowserBehavior() {\n        Object.keys(COMMANDS).forEach(command => {\n            // Catch any possible exception since this should not block the initialization of editor\n            try {\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\n            } catch {}\n        });\n    }\n\n    private setSelectStyle(node: HTMLElement, value: string) {\n        node.style.userSelect = value;\n        node.style.msUserSelect = value;\n        node.style.webkitUserSelect = value;\n    }\n\n    private recalculateDefaultFormat() {\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\n\n        if (isDarkMode && baseFormat) {\n            if (!baseFormat.backgroundColors) {\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\n            }\n            if (!baseFormat.textColors) {\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\n            }\n        }\n\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\n            return;\n        }\n\n        const {\n            fontFamily,\n            fontSize,\n            textColor,\n            textColors,\n            backgroundColor,\n            backgroundColors,\n            bold,\n            italic,\n            underline,\n        } = baseFormat || <DefaultFormat>{};\n        const defaultFormat = this.contentDivFormat;\n\n        this.state.defaultFormat = {\n            fontFamily: fontFamily || defaultFormat[0],\n            fontSize: fontSize || defaultFormat[1],\n            get textColor() {\n                return textColors\n                    ? isDarkMode\n                        ? textColors.darkModeColor\n                        : textColors.lightModeColor\n                    : textColor || defaultFormat[2];\n            },\n            textColors: textColors,\n            get backgroundColor() {\n                return backgroundColors\n                    ? isDarkMode\n                        ? backgroundColors.darkModeColor\n                        : backgroundColors.lightModeColor\n                    : backgroundColor || '';\n            },\n            backgroundColors: backgroundColors,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n        };\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\n * as long as the mouse was pressed within Editor before\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private editor: IEditor;\n    private mouseUpEventListerAdded: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'MouseUp';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n        }\n    }\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n            });\n        }\n    };\n}\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    IEditor,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChagned event, cache current position and pending format\n                this.state.pendableFormatPosition = this.getCurrentPosition();\n                this.state.pendableFormatState = event.formatState;\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                // If content or position is changed (by keyboard, mouse, or code),\n                // check if current position is still the same with the cached one (if exist),\n                // and clear cached format if position is changed since it is out-of-date now\n                if (\n                    this.state.pendableFormatPosition &&\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\n                ) {\n                    this.clear();\n                }\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n    }\n\n    private getCurrentPosition() {\n        let range = this.editor.getSelectionRange();\n        return range && Position.getStart(range).normalize();\n    }\n}\n","import { Browser, LinkInlineElement } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * TypeAfterLinkPlugin Component helps handle typing event when cursor is right after a link.\n * When typing/pasting after a link, browser may put the new charactor inside link.\n * This plugin overrides this behavior to always insert outside of link.\n */\nexport default class TypeAfterLinkPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeAfterLink';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\n            event.eventType == PluginEventType.BeforePaste\n        ) {\n            let range = this.editor.getSelectionRange();\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\n                const searcher = this.editor.getContentSearcherOfCursor(event);\n                const inlineElementBefore = searcher.getInlineElementBefore();\n                const inlineElementAfter = searcher.getInlineElementAfter();\n                if (inlineElementBefore instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementBefore.getContainerNode(), PositionType.After);\n                } else if (inlineElementAfter instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementAfter.getContainerNode(), PositionType.Before);\n                }\n            }\n        }\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            // If normalization was not possible before the keypress,\n            // check again after the keyboard event has been processed by browser native behaviour.\n            //\n            // This handles the case where the keyboard event that first inserts content happens when\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\n            //\n            // Only scheudle when the range is not collapsed to catch this edge case.\n            let range = this.editor.getSelectionRange();\n\n            if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\n                return;\n            }\n\n            if (range.collapsed) {\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\n            } else {\n                this.editor.runAsync(editor => {\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\n                });\n            }\n        }\n    }\n}\n","import {\n    EditorOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshot,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshots,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapsnot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAXSIZELIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor;\n    private lastKeyPress: number;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                if (!this.state.isRestoring) {\n                    this.clearRedoForInput();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else {\n                let selectionRange = this.editor.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        let range = this.editor.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService {\n    const snapshots = createSnapshots(MAXSIZELIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): string => moveCurrentSnapsnot(snapshots, delta),\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshots(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n","export { default as HyperLink } from './HyperLink';\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string;\n    private trackedLink: HTMLAnchorElement = null;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({\n                mouseover: this.onMouse,\n                mouseout: this.onMouse,\n                blur: this.onBlur,\n            });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor.getElementAtCursor(\n                'A[href]',\n                null /*startFrom*/,\n                event\n            ) as HTMLAnchorElement;\n\n            const shouldCheckUpdateLink =\n                anchor !== this.trackedLink ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            let display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            let href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            let linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor.addUndoSnapshot(() => {\n                    this.trackedLink.href = linkData.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n","export { default as Paste } from './Paste';\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromTeams from './teamsConverter/convertPastedContentFromTeams';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport handleLineMerge from './lineMerge/handleLineMerge';\nimport { EditorPlugin, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { toArray } from 'roosterjs-editor-dom';\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or Onenote Online\n */\nexport default class Paste implements EditorPlugin {\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     */\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize() {}\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {}\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            let wacListElements: Node[];\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event);\n            } else if (\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))) &&\n                wacListElements.length > 0\n            ) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\n            } else {\n                convertPastedContentFromTeams(fragment);\n                handleLineMerge(fragment);\n            }\n\n            // Replace unknown tags with SPAN\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n        }\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param doc HTML Document which contains the content from Excel\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\n    const html = excelHandler(clipboardData.html, htmlBefore);\n\n    if (clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(html, 'text/html');\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { changeElementTag, getTagOfNode, toArray } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Convert content copied from Teams to be well-formed\n */\nexport default function convertPastedContentFromTeams(fragment: DocumentFragment) {\n    const firstChild = fragment.firstChild;\n\n    // When copy from Teams, it is possible that we get LI nodes directly under DIV.\n    // In that case we need to convert DIV to UL. It is also possible to be OL, but we don't know it.\n    // So always assume it is UL here, and later user can change it.\n    if (\n        firstChild &&\n        !firstChild.nextSibling &&\n        getTagOfNode(firstChild) == 'DIV' &&\n        !toArray(firstChild.childNodes).some(node => getTagOfNode(node) != 'LI')\n    ) {\n        changeElementTag(firstChild as HTMLElement, 'UL');\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        element.innerHTML = '&nbsp;';\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import WordConverterArguments from './WordConverterArguments';\nimport WordCustomData, { createCustomData } from './WordCustomData';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    wordCustomData: WordCustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        wordCustomData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item metatada of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                while (node.firstChild != null) {\n                    last.appendChild(node.firstChild);\n                }\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                while (node.firstChild) {\n                    li.appendChild(node.firstChild);\n                }\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.wordCustomData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        while (list.firstChild) {\n            newList.appendChild(list.firstChild);\n        }\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list beofre the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list metadada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listprops = listatt.split(' ');\n                if (listprops.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listprops[1].substr('level'.length)),\n                        wordListId: listatt,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring emtpy text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those unstandard values throug the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    ContentTraverser,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        processBlock(blocks[0]);\n        processBlock(blocks[blocks.length - 1]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\n        block.start = node;\n        block.end = node;\n\n        if (getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument.createTextNode('');\n        end.parentNode?.insertBefore(node, end);\n        block.end = node;\n        end.parentNode?.removeChild(end);\n    }\n}\n\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (blockElement?.contains(sibling)) {\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\n            block.start.ownerDocument.createElement('br'),\n            isFirst ? block.end.nextSibling : block.start\n        );\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock?.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\n","import { fromHtml } from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML = '<div style=\"position: fixed; width: 0; height: 0\"></div>';\n\nexport interface ContextMenuOptions<T> {\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    dismiss?: (container: HTMLElement) => void;\n\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport default class ContextMenu<T> implements EditorPlugin {\n    private container: HTMLElement;\n    private editor: IEditor;\n    private isMenuShowing: boolean;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\n            this.options.render(this.container, items as T[], this.onDismiss);\n            this.isMenuShowing = true;\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container) {\n            this.container = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\n            this.editor.insertNode(this.container, {\n                position: ContentPosition.Outside,\n            });\n        }\n        this.container.style.left = x + 'px';\n        this.container.style.top = y + 'px';\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\n","import {\n    CustomReplacement,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: CustomReplacement[] = [\n    makeReplacement(':)', '🙂', true),\n    makeReplacement(';)', '😉', true),\n    makeReplacement(':O', '😲', true),\n    makeReplacement(':o', '😯', true),\n    makeReplacement('<3', '❤️', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: IEditor;\n    private replacements: CustomReplacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: CustomReplacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = replacement.replacementHTML;\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.addUndoSnapshot(\n            () => {\n                matchingRange.deleteContents();\n                matchingRange.insertNode(nodeToInsert);\n                this.editor.select(nodeToInsert, PositionType.End);\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    }\n\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/CutPasteListChain/index';\n","export { default as CutPasteListChain } from './CutPasteListChain';\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\n */\nexport default class CutPasteListChain implements EditorPlugin {\n    private chains: VListChain[];\n    private expectedChangeSource: ChangeSource;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CutPasteListChain';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.cacheListChains(ChangeSource.Cut);\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.cacheListChains(ChangeSource.Paste);\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\n                    experimentCommitListChains(this.editor, this.chains);\n                    this.chains = null;\n                    this.expectedChangeSource = null;\n                }\n                break;\n        }\n    }\n\n    private onDrop = () => {\n        this.cacheListChains(ChangeSource.Drop);\n    };\n\n    private cacheListChains(source: ChangeSource) {\n        this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\n        this.expectedChangeSource = source;\n    }\n}\n","export * from './plugins/ImageResize/index';\n","export { default as ImageResize } from './ImageResize';\n","import { Browser, fromHtml, getEntitySelector, getTagOfNode, toArray } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n    EntityOperation,\n    Entity,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\nconst DELETE_KEYCODE = 46;\nconst BACKSPACE_KEYCODE = 8;\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\nconst ENTITY_TYPE = 'IMAGE_RESIZE_WRAPPER';\n\nconst HANDLE_SIZE = 7;\nconst HANDLE_MARGIN = 3;\nconst CORNER_HANDLE_POSITIONS = ['nw', 'ne', 'se', 'sw'];\nconst SIDE_HANDLE_POSITIONS = ['n', 'e', 's', 'w'];\nconst ALL_HANDLE_POSITIONS = CORNER_HANDLE_POSITIONS.concat(SIDE_HANDLE_POSITIONS);\n\n/**\n * ImageResize plugin provides the ability to resize an inline image in editor\n */\nexport default class ImageResize implements EditorPlugin {\n    private editor: IEditor;\n    private startPageX: number;\n    private startPageY: number;\n    private startWidth: number;\n    private startHeight: number;\n    private resizeDiv: HTMLElement;\n    private direction: string;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        private minWidth: number = 10,\n        private minHeight: number = 10,\n        private selectionBorderColor: string = '#DB626C',\n        private forcePreserveRatio: boolean = false,\n        private resizableImageSelector: string = 'img'\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ImageResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            dragstart: this.onDragStart,\n            blur: this.onBlur,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.hideResizeHandle();\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        if (e.eventType == PluginEventType.MouseDown) {\n            if (this.resizeDiv) {\n                this.hideResizeHandle();\n            }\n        } else if (e.eventType == PluginEventType.MouseUp) {\n            const event = e.rawEvent;\n            const target = <HTMLElement>(event.srcElement || event.target);\n\n            if (getTagOfNode(target) == 'IMG') {\n                const parent = target.parentNode as HTMLElement;\n                const elements = parent\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\n                    : [];\n                if (elements.indexOf(target) < 0) {\n                    return;\n                }\n\n                const currentImg = this.getSelectedImage();\n                if (currentImg && currentImg != target) {\n                    this.hideResizeHandle();\n                }\n\n                if (!this.resizeDiv) {\n                    this.showResizeHandle(<HTMLImageElement>target);\n                }\n            }\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\n            const event = e.rawEvent;\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\n                this.editor.addUndoSnapshot(() => {\n                    this.editor.deleteNode(this.resizeDiv);\n                });\n                this.resizeDiv = null;\n                event.preventDefault();\n            } else if (\n                event.which != SHIFT_KEYCODE &&\n                event.which != CTRL_KEYCODE &&\n                event.which != ALT_KEYCODE\n            ) {\n                this.hideResizeHandle(true /*selectImage*/);\n            }\n        } else if (\n            e.eventType == PluginEventType.ContentChanged &&\n            e.source != ChangeSource.ImageResize &&\n            (e.source != ChangeSource.InsertEntity || (<Entity>e.data)?.type != ENTITY_TYPE)\n        ) {\n            this.editor.queryElements(getEntitySelector(ENTITY_TYPE), this.removeResizeDiv);\n            this.resizeDiv = null;\n        } else if (e.eventType == PluginEventType.EntityOperation && e.entity.type == ENTITY_TYPE) {\n            if (e.operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeResizeDiv(e.entity.wrapper);\n            } else if (e.operation == EntityOperation.Click) {\n                this.stopEvent(e.rawEvent);\n            }\n        }\n    }\n\n    /**\n     * Select a given IMG element, show the resize handle\n     * @param img The IMG element to select\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.resizeDiv = this.createResizeDiv(img);\n        this.editor.select(this.resizeDiv, PositionType.After);\n    }\n\n    /**\n     * Hide resize handle of current selected image\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        if (this.resizeDiv) {\n            const transform = this.resizeDiv.style.transform;\n            const img = this.removeResizeDiv(this.resizeDiv);\n\n            if (img) {\n                img.style.transform = transform;\n\n                if (selectImageAfterUnSelect) {\n                    this.editor.select(img);\n                }\n            }\n\n            this.resizeDiv = null;\n        }\n    }\n\n    private startResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            this.startPageX = e.pageX;\n            this.startPageY = e.pageY;\n            this.startWidth = img.clientWidth;\n            this.startHeight = img.clientHeight;\n            this.editor.addUndoSnapshot();\n\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).dataset.direction;\n        }\n\n        this.stopEvent(e);\n    };\n\n    private doResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            let widthChange = e.pageX - this.startPageX;\n            let heightChange = e.pageY - this.startPageY;\n            let newWidth = this.calculateNewWidth(widthChange);\n            let newHeight = this.calculateNewHeight(heightChange);\n            const isSingleDirection =\n                this.isSingleDirectionNS(this.direction) ||\n                this.isSingleDirectionWE(this.direction);\n            const shouldPreserveRatio =\n                !isSingleDirection && (this.forcePreserveRatio || e.shiftKey);\n\n            if (shouldPreserveRatio) {\n                newHeight = Math.min(newHeight, (newWidth * this.startHeight) / this.startWidth);\n                newWidth = Math.min(newWidth, (newHeight * this.startWidth) / this.startHeight);\n\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n                if (ratio > 0) {\n                    if (newWidth < newHeight * ratio) {\n                        newWidth = newHeight * ratio;\n                    } else {\n                        newHeight = newWidth / ratio;\n                    }\n                }\n            }\n\n            img.style.width = newWidth + 'px';\n            img.style.height = newHeight + 'px';\n\n            // double check\n            if (shouldPreserveRatio) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n\n                const clientWidth = Math.floor(img.clientWidth);\n                const clientHeight = Math.floor(img.clientHeight);\n                newWidth = Math.floor(newWidth);\n                newHeight = Math.floor(newHeight);\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\n                    if (clientHeight < newHeight) {\n                        newWidth = clientHeight * ratio;\n                    } else {\n                        newHeight = clientWidth / ratio;\n                    }\n                    img.style.width = newWidth + 'px';\n                    img.style.height = newHeight + 'px';\n                }\n            }\n        }\n        this.stopEvent(e);\n    };\n\n    private calculateNewWidth(widthChange: number): number {\n        let newWidth = this.startWidth;\n        if (!this.isSingleDirectionNS(this.direction)) {\n            newWidth = Math.max(\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\n                this.minWidth\n            );\n        }\n        return newWidth;\n    }\n\n    private calculateNewHeight(heightChange: number): number {\n        let newHeight = this.startHeight;\n        if (!this.isSingleDirectionWE(this.direction)) {\n            newHeight = Math.max(\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\n                this.minHeight\n            );\n        }\n        return newHeight;\n    }\n\n    private finishResize = (e: MouseEvent) => {\n        var img = this.getSelectedImage() as HTMLImageElement;\n        if (this.editor && img) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            let width = img.clientWidth;\n            let height = img.clientHeight;\n            img.style.width = width + 'px';\n            img.style.height = height + 'px';\n            img.width = width;\n            img.height = height;\n            this.resizeDiv.style.width = '';\n            this.resizeDiv.style.height = '';\n        }\n        this.direction = null;\n        this.editor.addUndoSnapshot();\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize, img);\n        this.stopEvent(e);\n    };\n\n    private createResizeDiv(target: HTMLElement) {\n        const { wrapper } = insertEntity(\n            this.editor,\n            ENTITY_TYPE,\n            target,\n            false /*isBlock*/,\n            true /*isReadonly*/\n        );\n\n        wrapper.style.position = 'relative';\n        wrapper.style.display = Browser.isSafari ? 'inline-block' : 'inline-flex';\n\n        const html =\n            (this.editor.isFeatureEnabled(ExperimentalFeatures.SingleDirectionResize)\n                ? ALL_HANDLE_POSITIONS\n                : CORNER_HANDLE_POSITIONS\n            )\n                .map(\n                    pos =>\n                        `<div style=\"position:absolute;${this.isWest(pos) ? 'left' : 'right'}:${\n                            this.isSingleDirectionNS(pos) ? '50%' : '0px'\n                        };${this.isNorth(pos) ? 'top' : 'bottom'}:${\n                            this.isSingleDirectionWE(pos) ? '50%' : '0px'\n                        }\">\n                            <div id=${pos}-handle data-direction=\"${pos}\" style=\"position:relative;width:${HANDLE_SIZE}px;height:${HANDLE_SIZE}px;background-color: ${\n                            this.selectionBorderColor\n                        };cursor: ${pos}-resize;${\n                            this.isNorth(pos) ? 'top' : 'bottom'\n                        }:-${HANDLE_MARGIN}px;${\n                            this.isWest(pos) ? 'left' : 'right'\n                        }:-${HANDLE_MARGIN}px\"></div></div>`\n                )\n                .join('') +\n            `<div style=\"position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${this.selectionBorderColor};pointer-events:none;\">`;\n\n        fromHtml(html, this.editor.getDocument()).forEach(div => {\n            wrapper.appendChild(div);\n            div.addEventListener('mousedown', this.startResize);\n        });\n\n        // If the resizeDiv's image has a transform, apply it to the container\n        const selectedImage = this.getSelectedImage(wrapper);\n        if (selectedImage && selectedImage.style && selectedImage.style.transform) {\n            wrapper.style.transform = selectedImage.style.transform;\n            selectedImage.style.transform = '';\n        }\n\n        return wrapper;\n    }\n\n    private stopEvent = (e: Event) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    private removeResizeDiv = (resizeDiv: HTMLElement): HTMLImageElement => {\n        if (resizeDiv?.parentNode) {\n            const img = resizeDiv.querySelector('img');\n            if (img) {\n                resizeDiv.parentNode.insertBefore(img, resizeDiv);\n            }\n            resizeDiv.parentNode.removeChild(resizeDiv);\n            return img;\n        } else {\n            return null;\n        }\n    };\n\n    private onBlur = (e: FocusEvent) => {\n        this.hideResizeHandle();\n    };\n\n    private getSelectedImage(div?: HTMLElement): HTMLElement {\n        const divWithImage = div || this.resizeDiv;\n        return divWithImage ? <HTMLElement>divWithImage.getElementsByTagName('IMG')[0] : null;\n    }\n\n    private isNorth(direction: string): boolean {\n        return direction && direction.substr(0, 1) == 'n';\n    }\n\n    private isWest(direction: string): boolean {\n        return direction && (direction.substr(1, 1) == 'w' || direction == 'w');\n    }\n\n    private isSingleDirectionNS(direction: string): boolean {\n        return direction && (direction == 'n' || direction == 's');\n    }\n\n    private isSingleDirectionWE(direction: string): boolean {\n        return direction && (direction == 'w' || direction == 'e');\n    }\n\n    private onDragStart = (e: DragEvent) => {\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\n            this.hideResizeHandle(true);\n        }\n    };\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin } from './PickerPlugin';\n","import { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    Browser,\n    createRange,\n    isCharacterValue,\n    isModifierKey,\n    PartialInlineElement,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    NodePosition,\n    PickerDataProvider,\n    PickerPluginOptions,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHARCODE = 'Backspace';\nconst TAB_CHARCODE = 'Tab';\nconst ENTER_CHARCODE = 'Enter';\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPlugin {\n    private editor: IEditor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: IEditor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                this.editor.addUndoSnapshot(\n                    insertNode,\n                    this.pickerOptions.changeSource,\n                    this.pickerOptions.handleAutoComplete\n                );\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undos and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = this.editor.getContentSearcherOfCursor(event);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        positionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHARCODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                // #483: If we are backspacing over the trigger character that triggered this Picker\n                // then we need to hide the Picker\n                const wordBeforeCursor = this.getWord(event);\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\n                    this.setIsSuggesting(false);\n                }\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(editor => {\n                        editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { fromHtml, getComputedStyle, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    Rect,\n    ChangeSource,\n    TableOperation,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_COLOR_DARK_MODE = 'white';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\nconst INSERTER_HOVER_OFFSET = 5;\n\nconst CELL_RESIZER_WIDTH = 4;\nconst HORIZONTAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: row-resize; user-select: none\"></div>';\nconst VERTICAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: col-resize; user-select: none\"></div>';\n\nconst enum ResizeState {\n    None,\n    Horizontal,\n    Vertical,\n}\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: IEditor;\n    private onMouseMoveDisposer: () => void;\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\n    private resizerContainer: HTMLDivElement;\n    private currentTable: HTMLTableElement;\n    private currentTd: HTMLTableCellElement;\n    private horizontalResizer: HTMLDivElement;\n    private verticalResizer: HTMLDivElement;\n    private resizingState: ResizeState = ResizeState.None;\n\n    private currentInsertTd: HTMLTableCellElement;\n    private insertingState: ResizeState = ResizeState.None;\n    private inserter: HTMLDivElement;\n    private isRTL: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.setupResizerContainer();\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onMouseMoveDisposer();\n        this.destoryRectMap();\n        this.removeResizerContainer();\n\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.Input:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.Scroll:\n                this.destoryRectMap();\n                break;\n        }\n    }\n\n    private setupResizerContainer() {\n        this.resizerContainer = this.editor.getDocument().createElement('div');\n        this.editor.insertNode(this.resizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n    }\n\n    private removeResizerContainer() {\n        this.resizerContainer.parentNode.removeChild(this.resizerContainer);\n        this.resizerContainer = null;\n    }\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (this.resizingState != ResizeState.None) {\n            return;\n        }\n\n        if (!this.tableRectMap) {\n            this.cacheRects();\n        }\n\n        if (this.tableRectMap) {\n            let i = this.tableRectMap.length - 1;\n            for (; i >= 0; i--) {\n                const { table, rect } = this.tableRectMap[i];\n\n                if (\n                    e.pageX <= rect.right + (this.isRTL ? INSERTER_SIDE_LENGTH : 0) &&\n                    e.pageX >= rect.left - (this.isRTL ? 0 : INSERTER_SIDE_LENGTH) &&\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\n                    e.pageY <= rect.bottom\n                ) {\n                    this.setCurrentTable(table, rect);\n                    break;\n                }\n            }\n\n            if (i < 0) {\n                this.setCurrentTable(null);\n            }\n\n            if (this.currentTable) {\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\n\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\n                    const tr = this.currentTable.rows[i];\n\n                    let j = 0;\n                    for (; j < tr.cells.length; j++) {\n                        const td = tr.cells[j];\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                        if (\n                            tdRect &&\n                            (this.isRTL ? e.pageX >= tdRect.left : e.pageX <= tdRect.right) &&\n                            e.pageY <= tdRect.bottom\n                        ) {\n                            // check vertical isnerter\n                            if (i == 0 && e.pageY <= tdRect.top + INSERTER_HOVER_OFFSET) {\n                                let verticalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (\n                                    this.isRTL\n                                        ? e.pageX <=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                        : e.pageX >=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                ) {\n                                    verticalInserterTd = td;\n                                } else if (\n                                    this.isRTL ? e.pageX <= tdRect.right : e.pageX >= tdRect.left\n                                ) {\n                                    // set inserter at previous td if it exists\n                                    const preTd = td.previousElementSibling as HTMLTableCellElement;\n                                    if (preTd) {\n                                        verticalInserterTd = preTd;\n                                    }\n                                }\n                                if (verticalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    this.setCurrentInsertTd(\n                                        ResizeState.Vertical,\n                                        verticalInserterTd,\n                                        map.rect\n                                    );\n                                    break;\n                                }\n                                // check horizontal inserter\n                            } else if (\n                                j == 0 &&\n                                (this.isRTL\n                                    ? e.pageX >= tdRect.right - INSERTER_HOVER_OFFSET\n                                    : e.pageX <= tdRect.left + INSERTER_HOVER_OFFSET)\n                            ) {\n                                let horizontalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (e.pageY >= tdRect.top + (tdRect.bottom - tdRect.top) / 2.0) {\n                                    horizontalInserterTd = td;\n                                } else if (e.pageY >= tdRect.top) {\n                                    // set insert at previous td if it exists\n                                    const preTd = this.currentTable.rows[i - 1]?.cells[0];\n                                    if (preTd) {\n                                        horizontalInserterTd = preTd;\n                                    }\n                                }\n\n                                if (horizontalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    this.setCurrentInsertTd(\n                                        ResizeState.Horizontal,\n                                        horizontalInserterTd,\n                                        map.rect\n                                    );\n                                    break;\n                                }\n                            } else {\n                                this.setCurrentTd(td, map.rect, tdRect.right, tdRect.bottom);\n                                this.setCurrentInsertTd(ResizeState.None);\n                                break;\n                            }\n                        }\n                    }\n                    if (j < tr.cells.length) {\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td: HTMLTableCellElement,\n        tableRect: Rect\n    ): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td?: HTMLTableCellElement,\n        tableRect?: Rect\n    ) {\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\n            if (this.currentInsertTd) {\n                this.resizerContainer.removeChild(this.inserter);\n                this.inserter = null;\n            }\n            this.insertingState = insertingState;\n            this.currentInsertTd = td;\n            if (this.currentInsertTd) {\n                this.inserter = this.createInserter(tableRect);\n                this.resizerContainer.appendChild(this.inserter);\n            }\n        }\n    }\n\n    private createInserter(tableRect: Rect) {\n        if (this.insertingState == ResizeState.None) {\n            return;\n        }\n\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\n        const inserterColor = this.editor.isDarkMode() ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;\n        const leftOrRight = this.isRTL ? 'right' : 'left';\n\n        const HORIZONTAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; ${leftOrRight}: 12px; top: 5px; height: 3px; border-top: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n        const VERTICAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n\n        const inserter = fromHtml(\n            this.insertingState == ResizeState.Horizontal\n                ? HORIZONTAL_INSERTER_HTML\n                : VERTICAL_INSERTER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n\n        if (rect) {\n            if (this.insertingState == ResizeState.Horizontal) {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.right}px`;\n                } else {\n                    inserter.style.left = `${\n                        rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                    }px`;\n                }\n                inserter.style.top = `${rect.bottom - 8}px`;\n                (inserter.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.left - 8}px`;\n                } else {\n                    inserter.style.left = `${rect.right - 8}px`;\n                }\n                inserter.style.top = `${\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (inserter.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n        }\n\n        inserter.addEventListener('click', this.insertTd);\n\n        return inserter;\n    }\n\n    private insertTd = () => {\n        this.editor.addUndoSnapshot((start, end) => {\n            const vtable = new VTable(this.currentInsertTd);\n            vtable.edit(\n                this.insertingState == ResizeState.Horizontal\n                    ? TableOperation.InsertBelow\n                    : TableOperation.InsertRight\n            );\n            vtable.writeBack();\n            this.editor.select(start, end);\n            this.setCurrentInsertTd(ResizeState.None);\n        }, ChangeSource.Format);\n    };\n\n    private setCurrentTable(table: HTMLTableElement, rect: Rect): void;\n    private setCurrentTable(table: null): void;\n    private setCurrentTable(table: HTMLTableElement, rect?: Rect) {\n        if (this.currentTable != table) {\n            this.setCurrentTd(null);\n            this.setCurrentInsertTd(ResizeState.None);\n            this.currentTable = table;\n        }\n    }\n\n    private setCurrentTd(td: null): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect: Rect,\n        right: number,\n        bottom: number\n    ): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect?: Rect,\n        right?: number,\n        bottom?: number\n    ) {\n        if (this.currentTd != td) {\n            if (this.currentTd) {\n                this.resizerContainer.removeChild(this.horizontalResizer);\n                this.resizerContainer.removeChild(this.verticalResizer);\n                this.horizontalResizer = null;\n                this.verticalResizer = null;\n            }\n\n            this.currentTd = td;\n\n            if (this.currentTd) {\n                this.horizontalResizer = this.createResizer(\n                    true /*horizontal*/,\n                    tableRect.left,\n                    bottom - CELL_RESIZER_WIDTH + 1,\n                    tableRect.right - tableRect.left,\n                    CELL_RESIZER_WIDTH\n                );\n                this.verticalResizer = this.createResizer(\n                    false /*horizontal*/,\n                    right - CELL_RESIZER_WIDTH + 1,\n                    tableRect.top,\n                    CELL_RESIZER_WIDTH,\n                    tableRect.bottom - tableRect.top\n                );\n\n                this.resizerContainer.appendChild(this.horizontalResizer);\n                this.resizerContainer.appendChild(this.verticalResizer);\n            }\n        }\n    }\n\n    private createResizer(\n        horizontal: boolean,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ) {\n        const div = fromHtml(\n            horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n        div.style.top = `${top}px`;\n        div.style.left = `${left}px`;\n        div.style.width = `${width}px`;\n        div.style.height = `${height}px`;\n\n        div.addEventListener(\n            'mousedown',\n            horizontal ? this.startHorizontalResizeTable : this.startVerticalResizeTable\n        );\n\n        return div;\n    }\n\n    private startHorizontalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Horizontal;\n        this.startResizeTable(e);\n    };\n\n    private startVerticalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Vertical;\n        this.startResizeTable(e);\n    };\n\n    private startResizeTable(e: MouseEvent) {\n        const doc = this.editor.getDocument();\n        doc.addEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.addEventListener('mouseup', this.endResizeTable, true);\n    }\n\n    private frameAnimateResizeTable = (e: MouseEvent) => {\n        this.editor.runAsync(() => this.resizeTable(e));\n    };\n\n    private resizeTable = (e: MouseEvent) => {\n        if (this.currentTd && this.resizingState !== ResizeState.None) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            if (rect) {\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\n\n                let vtable = new VTable(this.currentTd);\n\n                if (this.resizingState == ResizeState.Horizontal) {\n                    vtable.table.style.height = null;\n                    vtable.forEachCellOfCurrentRow(cell => {\n                        if (cell.td) {\n                            cell.td.style.height =\n                                cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\n                        }\n                    });\n                } else {\n                    vtable.table.style.width = '';\n                    vtable.table.width = '';\n                    vtable.forEachCellOfCurrentColumn(cell => {\n                        if (cell.td) {\n                            cell.td.style.wordBreak = 'break-word';\n                            cell.td.style.width =\n                                cell.td == this.currentTd ? `${newPos - rect.left}px` : null;\n                        }\n                    });\n                }\n                vtable.writeBack();\n            }\n        }\n    };\n\n    private endResizeTable = (e: MouseEvent) => {\n        const doc = this.editor.getDocument();\n        doc.removeEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.removeEventListener('mouseup', this.endResizeTable, true);\n\n        this.editor.addUndoSnapshot((start, end) => {\n            this.frameAnimateResizeTable(e);\n            this.editor.select(start, end);\n        }, ChangeSource.Format);\n\n        this.setCurrentTd(null);\n        this.resizingState = ResizeState.None;\n    };\n\n    private destoryRectMap() {\n        this.setCurrentTable(null);\n        this.tableRectMap = null;\n    }\n\n    private cacheRects() {\n        this.destoryRectMap();\n        this.tableRectMap = [];\n        this.editor.queryElements('table', table => {\n            const rect = normalizeRect(table.getBoundingClientRect());\n            if (rect) {\n                this.tableRectMap.push({\n                    table,\n                    rect,\n                });\n            }\n        });\n        this.isRTL = getComputedStyle(this.editor.getDocument().body, 'direction') == 'rtl';\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    DefaultFormat,\n    EditorPlugin,\n    Entity,\n    EntityOperation,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColor: '#aaa',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.showHideWatermark,\n            blur: this.showHideWatermark,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.EditorReady ||\n            (event.eventType == PluginEventType.ContentChanged &&\n                (<Entity>event.data)?.type != ENTITY_TYPE)\n        ) {\n            this.showHideWatermark();\n        } else if (\n            event.eventType == PluginEventType.EntityOperation &&\n            event.entity.type == ENTITY_TYPE\n        ) {\n            const {\n                operation,\n                entity: { wrapper },\n            } = event;\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeWatermark(wrapper);\n            } else if (event.operation == EntityOperation.NewEntity) {\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\n                wrapper.spellcheck = false;\n            }\n        }\n    }\n\n    private showHideWatermark = () => {\n        const hasFocus = this.editor.hasFocus();\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\n        const isShowing = watermarks.length > 0;\n\n        if (hasFocus && isShowing) {\n            watermarks.forEach(this.removeWatermark);\n            this.editor.focus();\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\n            insertEntity(\n                this.editor,\n                ENTITY_TYPE,\n                this.editor.getDocument().createTextNode(this.watermark),\n                false /*isBlock*/,\n                false /*isReadonly*/,\n                ContentPosition.Begin\n            );\n        }\n    };\n\n    private removeWatermark = (wrapper: HTMLElement) => {\n        const parentNode = wrapper.parentNode;\n        parentNode?.removeChild(wrapper);\n\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n        if (\n            this.editor.contains(parentNode) &&\n            getTagOfNode(parentNode) == 'DIV' &&\n            !parentNode.firstChild\n        ) {\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n        }\n    };\n}\n"],"sourceRoot":""}