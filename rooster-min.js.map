{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getInnerHTML.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeAfterLinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/pptConverter/convertPastedContentFromPowerPoint.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/teamsConverter/convertPastedContentFromTeams.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","node","nodeType","tagName","toUpperCase","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","internalContains","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","matches","msMatchesSelector","parentElement","CRLF","CRLFSPACE","shouldSkipNode","textContent","replace","region","nodeBefore","nodeAfter","beforeRunCallback","regions","getSelectedRegions","VListChain","createListChains","html","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","clientRect","left","right","top","bottom","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","isDummy","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","softOutdent","findListItems","setIsDummy","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","splice","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","collapseToSingleElement","equals","blockElement","HTML_VOID_ELEMENTS","isFirst","getLeafNode","tempNode","orderListStyles","dummy","isOrphanItem","canMerge","mergeItems","wrapIfNotBlockNode","listType","pop","originalRoot","nextLevel","newList","createListElement","newRoot","listStyleType","checkFirst","checkLast","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","chains","chain","commit","color","backgroundColor","isDarkMode","darkModeColor","lightModeColor","dataset","fontName","fontFamily","fontSize","lineHeight","startNumber","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","createVListFromRegion","wrapFunction","getSelectedBlockElementsInRegion","collapseNodesInRegion","NodeTag","wrap","toArray","isNodeInRegion","hasFocus","core","activeElement","contentDiv","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","options","defaultFormat","textColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","clipboardData","data","link","matchLink","text","getRangeFromText","word","getWordBefore","trailingPunctuation","match","substring","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","format","elementStyle","textColors","backgroundColors","bold","italic","underline","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","getAsString","Promise","resolve","types","getData","image","rawHtml","customValues","handlers","TEXT_TYPE_PREFIX","promise","headerValues","parseInt","workaroundForEdge","allowLinkPreview","linkPreview","JSON","parse","allowedCustomPasteType","all","handler","then","values","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","FileReader","onload","onerror","readAsDataURL","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","getCellsWithBorder","borderPos","getLeftCells","closestIndex","closestValue","Number","MAX_SAFE_INTEGER","j","cellRect","getBoundingClientRect","found","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","listNode","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rect","rects","getClientRects","span","areAllPrevousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","currentRange","getRangeAt","removeAllRanges","e","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","className","HTML_TAG_REPLACEMENT","a","abbr","address","area","article","aside","b","bdi","bdo","blockquote","br","button","canvas","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","img","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","q","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","base","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","isReadonly","contentEditable","isEntity","eventDataCache","isCtrlOrMetaPressed","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","returnBlockElement","isBlockElement","isVoidHtmlElement","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","nonborderStyles","STYLES_TO_REMOVE","queryElements","getDefaultFormat","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","listTag","getElementAtCursor","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","src","maxWidth","imageFile","readFile","dataUrl","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","VTable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","angle","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","findClosestElementAncestor","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","borderColor","paddingLeft","PRE_TAG","level","wrapped","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","shiftKey","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","isPositionAtBeginningOf","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","isNodeEmpty","OutdentWhenEnterOnEmptyLine","AutoBullet","textBeforeCursor","insertContent","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","getListChains","experimentCommitListChains","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","fromHtml","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","hasShiftKey","targetTd","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","deleteNode","existingNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","getSelectionPath","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","startShadowEdit","switchShadowEdit","stopShadowEdit","isInShadowEdit","shadowEditFragment","isFeatureEnabled","experimentalFeatures","undoState","isNested","isShadowEdit","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","imageDataUri","querySelector","attrs","lastIndexOf","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","clonedNode","originalRange","shadowEditSelectionPath","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","adjustSteps","nodeToInsert","safeRemove","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","changeElementTag","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","setHtmlWithSelectionPath","isOn","wasInShadowEdit","STYLE_DATASET_MAP","ATTR_DATASET_MAP","getValueOrDefault","defualtValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","onExternalContentTransform","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","getTempDiv","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","newRange","forceInLightMode","tempDiv","onDrop","onFocus","onBlur","onScroll","onKeybaordEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","height","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","clear","getCurrentPosition","inlineElementBefore","inlineElementAfter","undoSnapshotService","createSnapshots","delta","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","y","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","ENTITY_TYPE","CORNER_HANDLE_POSITIONS","ALL_HANDLE_POSITIONS","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","startPageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","stopEvent","widthChange","heightChange","newWidth","calculateNewWidth","newHeight","calculateNewHeight","shouldPreserveRatio","isSingleDirectionNS","isSingleDirectionWE","ratio","resizeDiv","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","currentImg","showResizeHandle","createResizeDiv","selectImageAfterUnSelect","isWest","isNorth","selectedImage","divWithImage","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","tableRectMap","currentCellsToResize","nextCellsToResize","resizingState","insertingState","onMouseMove","cacheRects","setCurrentTable","isRTL","setTableResizer","tdRect","normalizeRect","verticalInserterTd","preTd","previousElementSibling","setCurrentTd","buttons","setCurrentInsertTd","horizontalInserterTd","insertTd","currentInsertTd","startResizingTable","startResizeCells","startHorizontalResizeCells","startVerticalResizeCells","currentTd","frameAnimateResizeCells","resizeCells","currentBorder","tableBottomBorder","ratioX","ratioY","shouldResizeX","abs","shouldResizeY","boxSizing","wordBreak","currentBottomBorder","leftBoundary","rightBoundary","tdWidth","endResizeCells","setupResizerContainer","onMouseMoveDisposer","removeResizerContainer","resizerContainer","tableResizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","inserterColor","HORIZONTAL_INSERTER_HTML","VERTICAL_INSERTER_HTML","resizerPosX","horizontalResizer","verticalResizer","createCellsResizer","hasChildNodes","tableResizer","createTableResizer","TABLE_RESIZER_LENGTH","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 83);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as arrayPush } from './utils/arrayPush';\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as normalizeRect } from './utils/normalizeRect';\r\nexport { default as toArray } from './utils/toArray';\r\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\r\nexport { default as readFile } from './utils/readFile';\r\nexport { default as getInnerHTML } from './utils/getInnerHTML';\r\n\r\nexport { default as VTable } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as VListItem } from './list/VListItem';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\nexport { default as VListChain } from './list/VListChain';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\r\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\r\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as commitEntity } from './entity/commitEntity';\r\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\r\nexport { default as getEntitySelector } from './entity/getEntitySelector';\r\n\r\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\r\nexport { default as isModifierKey } from './event/isModifierKey';\r\nexport { default as isCharacterValue } from './event/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\r\n\r\nexport { default as getStyles } from './style/getStyles';\r\nexport { default as setStyles } from './style/setStyles';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * @internal Export for test only\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: any,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\nimport { ChangeSource, IEditor, NodePosition, Region } from 'roosterjs-editor-types';\nimport { VListChain } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: IEditor,\n    callback: (\n        region: Region,\n        start: NodePosition,\n        end: NodePosition,\n        chains: VListChain[]\n    ) => void,\n    beforeRunCallback?: () => boolean\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        if (!beforeRunCallback || beforeRunCallback()) {\n            const regions = editor.getSelectedRegions();\n            const chains = VListChain.createListChains(regions, start?.node);\n            regions.forEach(region => callback(region, start, end, chains));\n            experimentCommitListChains(editor, chains);\n        }\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\n * A type-safe wrapper for Array.prototype.push.apply()\n * @param mainArray The main array to push items into\n * @param itemsArray The items to push to main array\n */\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\n    Array.prototype.push.apply(mainArray, itemsArray);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    public readonly items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get list number of the last item in this VList.\n     * If there is no order list item, result will be undefined\n     */\n    getLastItemNumber(): number | undefined {\n        const start = getStart(this.rootList);\n\n        return start === undefined\n            ? start\n            : start -\n                  1 +\n                  this.items.filter(\n                      item =>\n                          item.getListType() == ListType.Ordered &&\n                          item.getLevel() == 1 &&\n                          !item.isDummy()\n                  ).length;\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const doc = this.rootList.ownerDocument;\n        const listStack: Node[] = [doc.createDocumentFragment()];\n        const placeholder = doc.createTextNode('');\n        let start = getStart(this.rootList) || 1;\n        let lastList: Node;\n\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\n\n        this.items.forEach(item => {\n            item.writeBack(listStack, this.rootList);\n            const topList = listStack[1];\n\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\n                if (lastList != topList) {\n                    if (start == 1) {\n                        topList.removeAttribute('start');\n                    } else {\n                        topList.start = start;\n                    }\n                }\n\n                if (item.getLevel() == 1) {\n                    start++;\n                }\n            }\n\n            lastList = topList;\n        });\n\n        // Restore the content to the positioni of placeholder\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation): void;\n\n    /**\n     * Outdent the give range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Specify to outdent\n     * @param softOutdent (Optional) True to make the item to by dummy (no bullet or number) if the item is not dummy,\n     * otherwise outdent the item\n     */\n    setIndentation(\n        start: NodePosition,\n        end: NodePosition,\n        indentation: Indentation.Decrease,\n        softOutdent?: boolean\n    ): void;\n\n    setIndentation(\n        start: NodePosition,\n        end: NodePosition,\n        indentation: Indentation,\n        softOutdent?: boolean\n    ) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease\n                ? softOutdent && !item.isDummy()\n                    ? item.setIsDummy(true /*isDummy*/)\n                    : item.outdent()\n                : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        const nodeTag = getTagOfNode(node);\n\n        // Change DIV tag to SPAN. Otherwise we cannot create new list item by Enter key in Safari\n        if (nodeTag == 'DIV') {\n            node = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag != 'LI') {\n            node = wrap(node, 'LI');\n        }\n\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n        const items = toArray(list.childNodes);\n\n        items.forEach(item => {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        });\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { Region, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get the selection range in the given region.\n * The original range can cover multiple regions, this function will narrow the origianl selection\n * of a region into current region\n * @param regionBase The region to get range from\n */\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\n    if (!regionBase) {\n        return null;\n    }\n\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\n\n    if (!isRegion(regionBase)) {\n        return regionRange;\n    } else if (regionRange) {\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            return createRange(start, end);\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\n    const region = regionBase as Region;\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\n}\n","/**\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport default function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","/**\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\n * @param element The element to set styles\n * @param styles The styles to set, in name-value pair format\n */\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\n    if (element) {\n        const style = Object.keys(styles || {})\n            .map(name => {\n                let value = styles[name];\n                name = name ? name.trim() : null;\n                value = value ? value.trim() : null;\n                return name && value ? `${name}:${value}` : null;\n            })\n            .filter(x => x)\n            .join(';');\n        if (style) {\n            element.setAttribute('style', style);\n        } else {\n            element.removeAttribute('style');\n        }\n    }\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","export * from './plugins/ContentEdit/index';\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\nimport { CursorFeatures } from './features/cursorFeatures';\nimport { EntityFeatures } from './features/entityFeatures';\nimport { ListFeatures } from './features/listFeatures';\nimport { MarkdownFeatures } from './features/markdownFeatures';\nimport { QuoteFeatures } from './features/quoteFeatures';\nimport { ShortcutFeatures } from './features/shortcutFeatures';\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\nimport { TableFeatures } from './features/tableFeatures';\nimport {\n    BuildInEditFeature,\n    ContentEditFeatureSettings,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\nconst allFeatures = {\n    ...ListFeatures,\n    ...QuoteFeatures,\n    ...TableFeatures,\n    ...StructuredNodeFeatures,\n    ...AutoLinkFeatures,\n    ...ShortcutFeatures,\n    ...CursorFeatures,\n    ...MarkdownFeatures,\n    ...EntityFeatures,\n};\n\n/**\n * Get all content edit features provided by roosterjs\n */\nexport default function getAllFeatures(): Record<\n    keyof ContentEditFeatureSettings,\n    BuildInEditFeature<PluginEvent>\n> {\n    return allFeatures;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\n\n/**\n * Get innerHTML of the given node\n * @param node The DOM node to get innerHTML from\n */\nexport default function getInnerHTML(node: HTMLElement | DocumentFragment) {\n    if (safeInstanceOf(node, 'HTMLElement')) {\n        return node.innerHTML;\n    } else if (node) {\n        const tempNode = node.ownerDocument.createElement('span');\n        tempNode.appendChild(node.cloneNode(true /*deep*/));\n        return tempNode.innerHTML;\n    } else {\n        return '';\n    }\n}\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n    private node: HTMLLIElement;\n    private dummy: boolean;\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represnets list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        this.node = safeInstanceOf(node, 'HTMLLIElement')\n            ? node\n            : (wrap(node, '<li style=\"display:block\"></li>') as HTMLLIElement);\n        const display = this.node.style.display;\n\n        this.dummy = display != 'list-item' && display != '';\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): HTMLLIElement {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is a dummy item.\n     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)\n     * normally it has CSS style display set to a value other than \"list-item\"\n     */\n    isDummy() {\n        return this.dummy;\n    }\n\n    /**\n     * @deprecated Always return false\n     */\n    isOrphanItem(): boolean {\n        return false;\n    }\n\n    /**\n     * @deprecated\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * @deprecated\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Set whether the item is a dummy item\n     * @param isDummy Whether the item is a dummy item\n     */\n    setIsDummy(isDummy: boolean) {\n        this.dummy = isDummy;\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     */\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n        this.node.style.display = this.dummy ? 'block' : null;\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            while (originalRoot.firstChild) {\n                originalRoot.removeChild(originalRoot.firstChild);\n            }\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport { RegionBase } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A type map from selector string to HTML element type\n */\nexport interface SelectorToTypeMap {\n    ol: HTMLOListElement;\n    ul: HTMLUListElement;\n    'ol,ul': HTMLOListElement | HTMLUListElement;\n}\n\n/**\n * @internal\n * Get Root list node from the given node within the given region\n * @param region Region to scope the search inot\n * @param selector The selector to search\n * @param node The start node\n */\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\n    region: RegionBase,\n    selector: TSelector,\n    node: Node\n): SelectorToTypeMap[TSelector] {\n    let list =\n        region &&\n        (findClosestElementAncestor(\n            node,\n            region.rootNode,\n            selector\n        ) as SelectorToTypeMap[TSelector]);\n\n    if (list) {\n        let ancestor: SelectorToTypeMap[TSelector];\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                selector\n            ) as SelectorToTypeMap[TSelector])\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport fromHtml from '../utils/fromHtml';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get all block elements covered by the selection under this region\n * @param regionBase The region to get block elements from\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\n * any blocks in the region. Default value is false\n */\nexport default function getSelectedBlockElementsInRegion(\n    regionBase: RegionBase,\n    createBlockIfEmpty?: boolean\n): BlockElement[] {\n    const range = getSelectionRangeInRegion(regionBase);\n    let blocks: BlockElement[] = [];\n\n    if (range) {\n        const { rootNode, skipTags } = regionBase;\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n        for (\n            let block = traverser?.currentBlockElement;\n            !!block;\n            block = traverser.getNextBlockElement()\n        ) {\n            blocks.push(block);\n        }\n\n        // Remove unmeaningful nodes\n        blocks = blocks.filter(block => {\n            const startNode = block.getStartNode();\n            const endNode = block.getEndNode();\n\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\n                startNode.parentNode?.removeChild(startNode);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\n        const newNode = fromHtml('<div><br></div>', regionBase.rootNode.ownerDocument)[0];\n        regionBase.rootNode.appendChild(newNode);\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created acording to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child bundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ascenstor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport setStyles from '../style/setStyles';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\nimport { collapse } from '../utils/collapseNodes';\nimport { safeInstanceOf } from '..';\n\n/**\n * Merge a BlockElement of given node after another node\n * @param region Region to operate in\n * @param refNode The node to merge after\n * @param targetNode The node of target block element\n */\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\n    let block: BlockElement;\n\n    if (\n        !isNodeInRegion(region, refNode) ||\n        !isNodeInRegion(region, targetNode) ||\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\n        block.contains(refNode)\n    ) {\n        return;\n    }\n\n    const blockRoot = block.collapseToSingleElement();\n    const commonContainer = collapse(\n        region.rootNode,\n        blockRoot,\n        refNode,\n        false /*isStart*/,\n        true /*canSplitParent*/\n    );\n\n    // Copy styles of parent nodes into blockRoot\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\n        const parent = node.parentNode;\n        if (safeInstanceOf(parent, 'HTMLElement')) {\n            const styles = {\n                ...(getPredefinedCssForElement(parent) || {}),\n                ...getStyles(parent),\n                ...getStyles(blockRoot),\n            };\n            setStyles(blockRoot, styles);\n        }\n        node = parent;\n    }\n\n    let nodeToRemove: Node = null;\n    let nodeToMerge =\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\n            ? blockRoot.firstChild\n            : changeElementTag(blockRoot, 'SPAN');\n\n    // Remove empty node\n    for (\n        let node: Node = nodeToMerge;\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\n        node = node.parentNode\n    ) {\n        // If the only child is the one which is about to be removed, this node should also be removed\n        nodeToRemove = node.parentNode;\n    }\n\n    // Finally, merge blocks, and remove empty nodes\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\n\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\n    B: {\n        'font-weight': 'bold',\n    },\n    EM: {\n        'font-style': 'italic',\n    },\n    I: {\n        'font-style': 'italic',\n    },\n    U: {\n        'text-decoration': 'underline',\n    },\n    P: {\n        'margin-top': '1em',\n        'margin-bottom': '1em',\n    },\n    PRE: {\n        'white-space': 'pre',\n    },\n    S: {\n        'text-decoration': 'line-through',\n    },\n    STRIKE: {\n        'text-decoration': 'line-through',\n    },\n    SUB: {\n        'vertical-align': 'sub',\n        'font-size': 'smaller',\n    },\n    SUP: {\n        'vertical-align': 'super',\n        'font-size': 'smaller',\n    },\n};\n\n/**\n * @internal\n * Get a map for browser built-in CSS definations of elements\n */\nexport default function getPredefinedCssForElement(\n    element: HTMLElement,\n    additionalPredefinedCssForElement?: PredefinedCssMap\n): StringMap {\n    const tag = getTagOfNode(element);\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: Node, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: Node): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","const CTRL_CHARCODE = 'Control';\nconst ALT_CHARCODE = 'Alt';\nconst META_CHARCODE = 'Meta';\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport default function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Position, VListChain } from 'roosterjs-editor-dom';\n\n/**\n * Commit changes of all list changes when experiment features are allowed\n * @param editor The Editor object\n * @param chains List chains to commit\n */\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\n    if (chains?.length > 0) {\n        const range = editor.getSelectionRange();\n        const start = range && Position.getStart(range);\n        const end = range && Position.getEnd(range);\n        chains.forEach(chain => chain.commit());\n        editor.select(start, end);\n    }\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\nimport { IEditor, ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function toggleListType(editor: IEditor, listType: ListType): void;\nexport default function toggleListType(\n    editor: IEditor,\n    listType: ListType.Ordered,\n    startNumber: number\n): void;\n\nexport default function toggleListType(editor: IEditor, listType: ListType, startNumber?: number) {\n    blockFormat(editor, (region, start, end, chains) => {\n        const chain =\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\n        const vList =\n            chain && start.equalTo(end)\n                ? chain.createVListAtBlock(\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\n                      startNumber\n                  )\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\n\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","import blockFormat from './blockFormat';\nimport { IEditor } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Toggle a tag at selection, if selection already contains elements of such tag,\n * the elements will be untagge and other elements will take no affect\n * @param editor The editor instance\n * @param wrapFunction  The wrap function\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\n * the loop for regions will be skipped\n */\nexport default function blockWrap(\n    editor: IEditor,\n    wrapFunction: (nodes: Node[]) => void,\n    beforeRunCallback: () => boolean\n): void {\n    blockFormat(\n        editor,\n        region => {\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n            let nodes = collapseNodesInRegion(region, blocks);\n            if (nodes.length > 0) {\n                if (nodes.length == 1) {\n                    const NodeTag = getTagOfNode(nodes[0]);\n                    if (NodeTag == 'BR') {\n                        nodes = [wrap(nodes[0])];\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\n                        nodes = toArray(nodes[0].childNodes);\n                    }\n                }\n\n                while (\n                    nodes[0] &&\n                    isNodeInRegion(region, nodes[0].parentNode) &&\n                    nodes.some(node => getTagOfNode(node) == 'LI')\n                ) {\n                    nodes = [splitBalancedNodeRange(nodes)];\n                }\n\n                wrapFunction(nodes);\n            }\n        },\n        beforeRunCallback\n    );\n}\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The EditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = (core: EditorCore) => {\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\n    return (\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\n    );\n};\n","export * from './plugins/HyperLink/index';\n","export * from './plugins/Paste/index';\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface WordCustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty WordCustomData\n */\nexport function createCustomData(): WordCustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!wordCustomData.dict[id]) {\n                // First time dictionary creation\n                wordCustomData.dict[id] = {};\n            }\n            wordCustomData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = wordCustomData.nextNodeId.toString();\n        wordCustomData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\nexport { default as getAllFeatures } from './getAllFeatures';\n","import getAllFeatures from './getAllFeatures';\nimport {\n    ContentEditFeatureSettings,\n    EditorPlugin,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    /**\n     * Create instance of ContentEdit plugin\n     * @param settingsOverride An optional feature set to override default feature settings\n     * @param additionalFeatures Optional. More features to add\n     */\n    constructor(\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor): void {\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\n        const allFeatures = getAllFeatures();\n\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\n            const feature = allFeatures[key];\n            const hasSettingForKey =\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\n\n            if (\n                (hasSettingForKey && this.settingsOverride[key]) ||\n                (!hasSettingForKey && !feature.defaultDisabled)\n            ) {\n                features.push(feature);\n            }\n        });\n\n        features\n            .concat(this.additionalFeatures || [])\n            .forEach(feature => editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose(): void {}\n}\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    AutoLinkFeatureSettings,\n    BuildInEditFeature,\n    ChangeSource,\n    ClipboardData,\n    IEditor,\n    Keys,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    clearEventDataCache,\n    LinkInlineElement,\n    matchLink,\n} from 'roosterjs-editor-dom';\n\n/**\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\n * we need to trim off the trailing puncatuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = editor.getContentSearcherOfCursor(event);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: IEditor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(editor => {\n        editor.addUndoSnapshot(\n            () => {\n                replaceWithNode(\n                    editor,\n                    linkData.originalUrl,\n                    anchor,\n                    false /* exactMatch */,\n                    searcher\n                );\n\n                // The content at cursor has changed. Should also clear the cursor data cache\n                clearEventDataCache(event);\n                return anchor;\n            },\n            ChangeSource.AutoLink,\n            true /*canUndoByBackspace*/\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const AutoLinkFeatures: Record<\n    keyof AutoLinkFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoLink: AutoLink,\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n};\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DarkModeDatasetNames, DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            elementStyle.color =\r\n                (isDarkMode ? textColors?.darkModeColor : textColors?.lightModeColor) || textColor;\r\n\r\n            if (textColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] =\r\n                    textColors.lightModeColor;\r\n            }\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            elementStyle.backgroundColor =\r\n                (isDarkMode ? backgroundColors?.darkModeColor : backgroundColors?.lightModeColor) ||\r\n                backgroundColor;\r\n\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    backgroundColors.lightModeColor;\r\n            }\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport {\r\n    ClipboardData,\r\n    EdgeLinkPreview,\r\n    ExtractClipboardEventOption,\r\n} from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\nconst TEXT_TYPE_PREFIX = 'text/';\r\nconst IMAGE_TYPE_PREFIX = 'image/';\r\nconst HTML_TYPE = TEXT_TYPE_PREFIX + 'html';\r\nconst LINKPREVIEW_TYPE = TEXT_TYPE_PREFIX + 'link-preview';\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardData) => void,\r\n    options?: ExtractClipboardEventOption\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardData = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        rawHtml: undefined,\r\n        customValues: {},\r\n    };\r\n\r\n    const handlers: {\r\n        promise: Promise<string>;\r\n        callback: (value: string) => void;\r\n    }[] = [];\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n\r\n        // Set rawHtml to null so that caller knows that we have tried\r\n        result.rawHtml = null;\r\n        const items = event.clipboardData.items;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n\r\n            switch (item.type) {\r\n                case HTML_TYPE:\r\n                    handlers.push({\r\n                        promise: getAsString(item),\r\n                        callback: value => {\r\n                            result.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value;\r\n                        },\r\n                    });\r\n                    break;\r\n                case LINKPREVIEW_TYPE:\r\n                    if (options?.allowLinkPreview) {\r\n                        handlers.push({\r\n                            promise: getAsString(item),\r\n                            callback: value => {\r\n                                try {\r\n                                    result.linkPreview = JSON.parse(value) as EdgeLinkPreview;\r\n                                } catch {}\r\n                            },\r\n                        });\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (item.type.indexOf(TEXT_TYPE_PREFIX) == 0) {\r\n                        const textType = item.type.substr(TEXT_TYPE_PREFIX.length);\r\n                        if (options?.allowedCustomPasteType?.indexOf(textType) >= 0) {\r\n                            handlers.push({\r\n                                promise: getAsString(item),\r\n                                callback: value => (result.customValues[textType] = value),\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Promise.all(handlers.map(handler => handler.promise)).then(values => {\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            handlers[i].callback(values[i]);\r\n        }\r\n\r\n        callback(result);\r\n    });\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf(IMAGE_TYPE_PREFIX) == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n\r\nfunction getAsString(item: DataTransferItem): Promise<string> {\r\n    return new Promise<string>(resolve => {\r\n        item.getAsString(value => {\r\n            resolve(value);\r\n        });\r\n    });\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\n    if (file && callback) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","import normalizeRect from '../utils/normalizeRect';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each table cell and get all the cells that share the same border from one side\r\n     * The result is an array of table cell elements where the first element is the narrowest td\r\n     * @param borderPos The position of the border\r\n     * @param getLeftCells Get left-hand-side or right-hand-side cells of the border\r\n     *\r\n     * Example, consider having a 3 by 4 table as below with merged and split cells\r\n     *\r\n     *     | 1 | 4 | 7 | 8 |\r\n     *     |   5   |   9   |\r\n     *     |   3   |   10  |\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: true\r\n     *  output => [4, 5, 3], where the first element (4) is the narrowest cell\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: false\r\n     *  output => [7, 9, 10], where the first element (7) is the narrowest cell\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: true\r\n     *  output => [1], where the first element (1) is the narrowest (and only) cell\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: false\r\n     *  output => [4], where the first element (4) is the narrowest (and only) cell\r\n     */\r\n    getCellsWithBorder(borderPos: number, getLeftCells: boolean): HTMLTableCellElement[] {\r\n        const cells: HTMLTableCellElement[] = [];\r\n        let closestIndex: number = 0;\r\n        let closestValue: number = getLeftCells ? -1 : Number.MAX_SAFE_INTEGER;\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            for (let j = 0; j < this.cells[i].length; j++) {\r\n                const cell = this.getCell(i, j);\r\n                if (cell.td) {\r\n                    const cellRect = normalizeRect(cell.td.getBoundingClientRect());\r\n                    let found: boolean = false;\r\n                    if (getLeftCells) {\r\n                        if (cellRect.right == borderPos) {\r\n                            found = true;\r\n                            if (cellRect.left > closestValue) {\r\n                                closestValue = cellRect.left;\r\n                                closestIndex = cells.length;\r\n                            }\r\n                            cell.td.setAttribute('originalLeftBorder', cellRect.left.toString());\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        if (cellRect.left == borderPos) {\r\n                            found = true;\r\n                            if (cellRect.right < closestValue) {\r\n                                closestValue = cellRect.right;\r\n                                closestIndex = cells.length;\r\n                            }\r\n                            cell.td.setAttribute('originalRightBorder', cellRect.right.toString());\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (cells.length > 0) {\r\n            const temp = cells[0];\r\n            cells[0] = cells[closestIndex];\r\n            cells[closestIndex] = temp;\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import fromHtml from '../utils/fromHtml';\nimport getRootListNode from './getRootListNode';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport Position from '../selection/Position';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport toArray from '../utils/toArray';\nimport VList from './VList';\nimport wrap from '../utils/wrap';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { ListType, Region } from 'roosterjs-editor-types';\nimport { PositionType } from 'roosterjs-editor-types';\n\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, ListSelector, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n                if (\n                    nodes.length == 1 &&\n                    safeInstanceOf(list, 'HTMLOListElement') &&\n                    list.start > 1\n                ) {\n                    // Do not include sibling lists if this list is not start from 1\n                    includeSiblingLists = false;\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\n            const newNode = fromHtml('<div><br></div>', region.rootNode.ownerDocument)[0];\n            region.rootNode.appendChild(newNode);\n            nodes.push(newNode);\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\n        }\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, ListSelector, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\n                // Only include sibling list when\n                // 1. This is a unordered list, OR\n                // 2. This list starts from 1\n                nodes.push(node);\n            }\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Wrap all child nodes under a single one, and put the new list under original root node\n    // so that the list can carry over styles under the root node.\n    const childNodes = toArray(node.childNodes);\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\n\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.appendChild(listNode);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(nodeForItem, ListType.None);\n\n    return vList;\n}\n","import arrayPush from '../utils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList {\n        if (container) {\n            const list = container.ownerDocument.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     */\n    commit() {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n            list.start = lastNumber + 1;\n\n            const vlist = new VList(list);\n\n            lastNumber = vlist.getLastItemNumber();\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack();\n        }\n    }\n\n    /**\n     * Contruct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber();\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getInnerHTML from '../utils/getInnerHTML';\nimport getSelectionPath from './getSelectionPath';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport queryElements from '../utils/queryElements';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(\n    rootNode: HTMLElement | DocumentFragment,\n    range: Range\n): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\n    let isDOMChanged = false;\n\n    queryElements(rootNode, 'table', table => {\n        let tbody: HTMLTableSectionElement = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            if (getTagOfNode(child) == 'TR') {\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n\n                isDOMChanged = true;\n            } else {\n                tbody = null;\n            }\n        }\n    });\n\n    if (range && isDOMChanged) {\n        try {\n            range.setStart(startContainer, startOffset);\n            range.setEnd(endContainer, endOffset);\n        } catch {}\n    }\n\n    const content = getInnerHTML(rootNode);\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\n\n/**\n * Add the given range into selection of the given document\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\n * otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\n    if (selection) {\n        let needAddRange = true;\n\n        if (selection.rangeCount > 0) {\n            // Workaround IE exception 800a025e\n            try {\n                let currentRange: Range;\n                // Do not remove/add range if current selection is the same with target range\n                // Without this check, execCommand() may fail in Edge since we changed the selection\n                if (\n                    (skipSameRange || Browser.isEdge) &&\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\n                    currentRange.startContainer == range.startContainer &&\n                    currentRange.startOffset == range.startOffset &&\n                    currentRange.endContainer == range.endContainer &&\n                    currentRange.endOffset == range.endOffset\n                ) {\n                    needAddRange = false;\n                } else {\n                    selection.removeAllRanges();\n                }\n            } catch (e) {}\n        }\n\n        if (needAddRange) {\n            selection.addRange(range);\n        }\n    }\n}\n","import arrayPush from '../utils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from './Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new positon to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\n    let nodeBefore: Node = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detecte them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes =>\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\n    );\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node = node.childNodes[offset - 1];\n        let nodeAfter: Node = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument.createTextNode('');\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore, nodeAfter];\n    }\n}\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        snapshots.autoCompleteIndex = -1;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Whether there is a snapshot added before auto complete and it can be undone now\n */\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\n    return (\n        snapshots.autoCompleteIndex >= 0 &&\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\n    );\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getInheritableStyles from './getInheritableStyles';\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setStyles from '../style/setStyles';\nimport toArray from '../utils/toArray';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedAttributes,\n    getAllowedCssClassesRegex,\n    getTagReplacement,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n} from './getAllowedValues';\nimport {\n    AttributeCallbackMap,\n    CssStyleCallbackMap,\n    ElementCallbackMap,\n    HtmlSanitizerOptions,\n    NodeType,\n    PredefinedCssMap,\n    SanitizeHtmlOptions,\n    StringMap,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two featuers:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: CssStyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private tagReplacements: Record<string, string>;\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalPredefinedCssForElement: PredefinedCssMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private unknownTagReplacement: string;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.unknownTagReplacement = options.unknownTagReplacement;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html || '', 'text/html');\n\n        if (doc && doc.body && doc.body.firstChild) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n\n        let shouldKeep = false;\n\n        if (isElement) {\n            const tag = getTagOfNode(node);\n            const callback = this.elementCallbacks[tag];\n            let replacement = this.tagReplacements[tag.toLowerCase()];\n\n            if (replacement === undefined) {\n                replacement = this.unknownTagReplacement;\n            }\n\n            if (callback) {\n                shouldKeep = callback(node as HTMLElement, context);\n            } else if (tag.indexOf(':') > 0) {\n                shouldKeep = true;\n            } else if (tag == replacement || replacement == '*') {\n                shouldKeep = true;\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\n                node = changeElementTag(node as HTMLElement, replacement);\n                shouldKeep = true;\n            }\n        } else if (isText) {\n            const whiteSpace = currentStyle['white-space'];\n            shouldKeep =\n                whiteSpace == 'pre' ||\n                whiteSpace == 'pre-line' ||\n                whiteSpace == 'pre-wrap' ||\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\n        } else if (isFragment) {\n            shouldKeep = true;\n        } else {\n            shouldKeep = false;\n        }\n\n        if (!shouldKeep) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            let element = <HTMLElement>node;\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.preprocessCss(element, thisStyle);\n                this.processCss(element, thisStyle, context);\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\n        const predefinedStyles = getPredefinedCssForElement(\n            element,\n            this.additionalPredefinedCssForElement\n        );\n        if (predefinedStyles) {\n            Object.keys(predefinedStyles).forEach(name => {\n                thisStyle[name] = predefinedStyles[name];\n            });\n        }\n    }\n\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\n        const styles = getStyles(element);\n        Object.keys(styles).forEach(name => {\n            const value = styles[name];\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, thisStyle, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n\n            if (!keep) {\n                delete styles[name];\n            }\n        });\n\n        setStyles(element, styles);\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n}\n","import { cloneObject } from './cloneObject';\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\n\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\n    // Allowed tags\n    a: '*',\n    abbr: '*',\n    address: '*',\n    area: '*',\n    article: '*',\n    aside: '*',\n    b: '*',\n    bdi: '*',\n    bdo: '*',\n    blockquote: '*',\n    body: '*',\n    br: '*',\n    button: '*',\n    canvas: '*',\n    caption: '*',\n    center: '*',\n    cite: '*',\n    code: '*',\n    col: '*',\n    colgroup: '*',\n    data: '*',\n    datalist: '*',\n    dd: '*',\n    del: '*',\n    details: '*',\n    dfn: '*',\n    dialog: '*',\n    dir: '*',\n    div: '*',\n    dl: '*',\n    dt: '*',\n    em: '*',\n    fieldset: '*',\n    figcaption: '*',\n    figure: '*',\n    font: '*',\n    footer: '*',\n    h1: '*',\n    h2: '*',\n    h3: '*',\n    h4: '*',\n    h5: '*',\n    h6: '*',\n    head: '*',\n    header: '*',\n    hgroup: '*',\n    hr: '*',\n    html: '*',\n    i: '*',\n    img: '*',\n    input: '*',\n    ins: '*',\n    kbd: '*',\n    label: '*',\n    legend: '*',\n    li: '*',\n    main: '*',\n    map: '*',\n    mark: '*',\n    menu: '*',\n    menuitem: '*',\n    meter: '*',\n    nav: '*',\n    ol: '*',\n    optgroup: '*',\n    option: '*',\n    output: '*',\n    p: '*',\n    picture: '*',\n    pre: '*',\n    progress: '*',\n    q: '*',\n    rp: '*',\n    rt: '*',\n    ruby: '*',\n    s: '*',\n    samp: '*',\n    section: '*',\n    select: '*',\n    small: '*',\n    span: '*',\n    strike: '*',\n    strong: '*',\n    sub: '*',\n    summary: '*',\n    sup: '*',\n    table: '*',\n    tbody: '*',\n    td: '*',\n    template: '*',\n    textarea: '*',\n    tfoot: '*',\n    th: '*',\n    thead: '*',\n    time: '*',\n    tr: '*',\n    tt: '*',\n    u: '*',\n    ul: '*',\n    var: '*',\n    wbr: '*',\n    xmp: '*',\n\n    // Replaced tags:\n    form: 'SPAN',\n\n    // Disallowed tags\n    applet: null,\n    audio: null,\n    base: null,\n    basefont: null,\n    embed: null,\n    frame: null,\n    frameset: null,\n    iframe: null,\n    link: null,\n    meta: null,\n    noscript: null,\n    object: null,\n    param: null,\n    script: null,\n    slot: null,\n    source: null,\n    style: null,\n    title: null,\n    track: null,\n    video: null,\n};\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,valign,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getTagReplacement(\n    additionalReplacements: Record<string, string>\n): Record<string, string> {\n    const result = { ...HTML_TAG_REPLACEMENT };\n    const replacements = additionalReplacements || {};\n    Object.keys(replacements).forEach(key => {\n        if (key) {\n            result[key.toLowerCase()] = replacements[key];\n        }\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        cssStyleCallbacks: {},\n        additionalTagReplacements: {},\n        additionalAllowedAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        additionalPredefinedCssForElement: {},\n        unknownTagReplacement: null,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<T extends any[], R>(\n    map: Record<string, (...args: T) => R>,\n    name: string,\n    newCallback: (...args: T) => R\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: T) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE = 'contenteditable';\n\n/**\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\n * @param wrapper The entity wrapper element\n * @param type Entity type\n * @param isReadonly Whether this is a readonly entity\n * @param id Optional Id of the entity\n */\nexport default function commitEntity(\n    wrapper: HTMLElement,\n    type: string,\n    isReadonly: boolean,\n    id?: string\n) {\n    if (wrapper) {\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\n            EntityClasses.ENTITY_TYPE_PREFIX\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\n            EntityClasses.ENTITY_READONLY_PREFIX\n        }${isReadonly ? '1' : '0'}`;\n\n        if (isReadonly) {\n            wrapper.contentEditable = 'false';\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\n            wrapper.removeAttribute(CONTENT_EDITABLE);\n        }\n    }\n}\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    element?.className?.split(' ').forEach(name => {\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\n            isEntity = true;\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\n        }\n    });\n\n    return isEntity\n        ? {\n              wrapper: element,\n              id,\n              type,\n              isReadonly,\n          }\n        : null;\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport default function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\n    let result =\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter();\n    if (event) {\n        event.eventDataCache = event.eventDataCache || {};\n        event.eventDataCache[key] = result;\n    }\n\n    return result;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Clear a cached object by its key from an event object\n * @param event The event object\n * @param key The cache key\n */\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\n    if (event && event.eventDataCache) {\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\n            delete event.eventDataCache[key];\n        } else if (!key) {\n            event.eventDataCache = {};\n        }\n    }\n}\n","import isModifierKey from './isModifierKey';\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && event.key && event.key.length == 1;\n}\n","import { Browser } from '../utils/Browser';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import blockFormat from '../utils/blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    IEditor,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n        });\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Rotate an element visually\n * @param editor The editor instance\n * @param element The element that should be rotated\n * @param angle The degree at which to rotate the element from it's center\n */\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\n    if (element) {\n        editor.addUndoSnapshot(() => {\n            element.style.transform = `rotate(${angle}deg)`;\n        }, ChangeSource.Format);\n    }\n}\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { BlockElement, IEditor, Indentation, RegionBase } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    createVListFromRegion,\r\n    findClosestElementAncestor,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    const handler = indentation == Indentation.Increase ? indent : outdent;\r\n\r\n    blockFormat(editor, (region, start, end) => {\r\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n        const blockGroups: BlockElement[][] = [[]];\r\n\r\n        for (let i = 0; i < blocks.length; i++) {\r\n            const startNode = blocks[i].getStartNode();\r\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\r\n\r\n            if (vList) {\r\n                blockGroups.push([]);\r\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\r\n                    i++;\r\n                }\r\n                vList.setIndentation(start, end, indentation);\r\n                vList.writeBack();\r\n            } else {\r\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\r\n            }\r\n        }\r\n\r\n        blockGroups.forEach(group => handler(region, group));\r\n    });\r\n}\r\n\r\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\r\n    const nodes = collapseNodesInRegion(region, blocks);\r\n    wrap(nodes, BlockWrapper);\r\n}\r\n\r\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\r\n    blocks.forEach(blockElement => {\r\n        let node = blockElement.collapseToSingleElement();\r\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\r\n        if (quote) {\r\n            if (node == quote) {\r\n                node = wrap(toArray(node.childNodes));\r\n            }\r\n\r\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (isNodeInRegion(region, node)) {\r\n                unwrap(node);\r\n            }\r\n        }\r\n    });\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\nimport applyInlineStyle from '../utils/applyInlineStyle';\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environment’s current locale.\n */\nexport default function changeCapitalization(\n    editor: IEditor,\n    capitalization: Capitalization,\n    language?: string\n) {\n    applyInlineStyle(editor, element => {\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\n            if (node.nodeType == NodeType.Text) {\n                try {\n                    node.textContent = getCapitalizedText(node.textContent, language);\n                } catch {\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\n                }\n            }\n        }\n    });\n\n    function getCapitalizedText(originalText: string, language: string): string {\n        switch (capitalization) {\n            case Capitalization.Lowercase:\n                return originalText.toLocaleLowerCase(language);\n            case Capitalization.Uppercase:\n                return originalText.toLocaleUpperCase(language);\n            case Capitalization.CapitalizeEachWord:\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\n                for (let i = 0; i < wordArray.length; i++) {\n                    wordArray[i] =\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\n                }\n                return wordArray.join(' ');\n            case Capitalization.Sentence:\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                // Find a match of a word character either:\n                // - At the beginning of a string with or without preceding whitespace, for\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\n                // - Or preceded by a punctuation mark and at least one whitespace, for\n                // example 'yes. hello world' would match 'y' and 'h'.\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\n                    return match.toLocaleUpperCase(language);\n                });\n        }\n    }\n}\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    toggleListType(editor, ListType.Unordered);\r\n}\r\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n * @param startNumber (Optional) Start number of the list\r\n */\r\nexport default function toggleNumbering(editor: IEditor, startNumber?: number) {\r\n    toggleListType(editor, ListType.Ordered, startNumber);\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    CursorFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: !Browser.isChrome,\n};\n\n/**\n * @internal\n */\nexport const CursorFeatures: Record<\n    keyof CursorFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    noCycleCursorMove: NoCycleCursorMove,\n};\n","import {\n    cacheGetEventData,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    EntityFeatureSettings,\n    EntityOperation,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    operation?: EntityOperation\n) {\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const node = event.rawEvent.target as Node;\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromEnd\n        );\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromStart\n        );\n    },\n};\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    operation?: EntityOperation\n): HTMLElement {\n    const element = cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range).normalize();\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\n            let entityNode: HTMLElement = null;\n\n            if (isAtBeginOrEnd) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = isNext\n                    ? pos.offset == 0\n                        ? traverser.currentInlineElement\n                        : traverser.getNextInlineElement()\n                    : pos.isAtEnd\n                    ? traverser.currentInlineElement\n                    : traverser.getPreviousInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (!collapseOnly) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\n            }\n\n            return entityNode;\n        }\n    );\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * @internal\n */\nexport const EntityFeatures: Record<\n    keyof EntityFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    clickOnEntity: ClickOnEntityFeature,\n    escapeFromEntity: EscapeFromEntityFeature,\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\n};\n","import blockFormat from 'roosterjs-editor-api/lib/utils/blockFormat';\nimport {\n    experimentCommitListChains,\n    setIndentation,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\nimport {\n    Browser,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n    VListChain,\n    createVListFromRegion,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Indentation,\n    ListFeatureSettings,\n    Keys,\n    NodeType,\n    PluginKeyboardEvent,\n    PositionType,\n    QueryScope,\n    RegionBase,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        let range = editor.getSelectionRange();\n        return li && range?.collapsed && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li.previousSibling) {\n            blockFormat(editor, (region, start, end) => {\n                const vList = createVListFromRegion(region, false /*includeSiblingList*/, li);\n                vList.setIndentation(start, end, Indentation.Decrease, true /*softOutdent*/);\n                vList.writeBack();\n                event.rawEvent.preventDefault();\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n    defaultDisabled: true,\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.addUndoSnapshot(\n            () => toggleListAndPreventDefault(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\n};\n\n/**\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = editor.getContentSearcherOfCursor(event);\n            let textBeforeCursor = searcher.getSubStringBefore(4);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return (\n                /^(\\*|-|[0-9]{1,2}\\.)$/.test(textBeforeCursor) &&\n                !searcher.getNearestNonTextInlineElement()\n            );\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.insertContent('&nbsp;');\n        event.rawEvent.preventDefault();\n        editor.addUndoSnapshot(\n            () => {\n                let regions: RegionBase[];\n                let searcher = editor.getContentSearcherOfCursor();\n                let textBeforeCursor = searcher.getSubStringBefore(4);\n                let rangeToDelete = searcher.getRangeFromText(\n                    textBeforeCursor,\n                    true /*exactMatch*/\n                );\n\n                if (!rangeToDelete) {\n                    // no op if the range can't be found\n                } else if (\n                    textBeforeCursor.indexOf('*') == 0 ||\n                    textBeforeCursor.indexOf('-') == 0\n                ) {\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleBullet(editor);\n                } else if (textBeforeCursor.indexOf('1.') == 0) {\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleNumbering(editor);\n                } else if ((regions = editor.getSelectedRegions()) && regions.length == 1) {\n                    const num = parseInt(textBeforeCursor);\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleNumbering(editor, num);\n                }\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n};\n\n/**\n * Maintain the list numbers in list chain\n * e.g. we have two lists:\n * 1, 2, 3 and 4, 5, 6\n * Now we delete list item 2, so the first one becomes \"1, 2\".\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\n */\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\n    shouldHandleEvent: (event, editor) =>\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\nfunction getListChains(editor: IEditor) {\n    return VListChain.createListChains(editor.getSelectedRegions());\n}\n\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\n    range.deleteContents();\n    const node = range.startContainer;\n    if (node?.nodeType == NodeType.Text && node.nodeValue == '' && !node.nextSibling) {\n        const br = editor.getDocument().createElement('BR');\n        editor.insertNode(br);\n        editor.select(br, PositionType.Before);\n    }\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n\n/**\n * @internal\n */\nexport const ListFeatures: Record<\n    keyof ListFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoBullet: AutoBullet,\n    indentWhenTab: IndentWhenTab,\n    outdentWhenShiftTab: OutdentWhenShiftTab,\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n    maintainListChain: MaintainListChain,\n};\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    ChangeSource,\n    IEditor,\n    Keys,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceeding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!!range) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                // set the removal range to include the typed last character.\n                range.setEnd(range.endContainer, range.endOffset + 1);\n\n                // extract content and put it into a new element.\n                const elementToWrap = editor.getDocument().createElement(elementTag);\n                elementToWrap.appendChild(textContentRange.extractContents());\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Bolds text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Italicises text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\n */\nconst MarkdownStrikethru: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethru,\n    markdownInlineCode: MarkdownInlineCode,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    QuoteFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) =>\n        editor.addUndoSnapshot(\n            () => splitQuote(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        ),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n\n/**\n * @internal\n */\nexport const QuoteFeatures: Record<\n    keyof QuoteFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n};\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    FontSizeChange,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ShortcutFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: IEditor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n\n/**\n * @internal\n */\nexport const ShortcutFeatures: Record<\n    keyof ShortcutFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    defaultShortcut: DefaultShortcut,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    StructuredNodeFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    fromHtml,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n// Edge can sometimes lose current format when Enter to new line.\n// So here we add an extra SPAN for Edge to workaround this bug\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n\n/**\n * @internal\n */\nexport const StructuredNodeFeatures: Record<\n    keyof StructuredNodeFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n};\n","import { editTable } from 'roosterjs-editor-api';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    NodeType,\n    PluginEvent,\n    PositionType,\n    TableFeatureSettings,\n    TableOperation,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    contains,\n    getTagOfNode,\n    isVoidHtmlElement,\n    Position,\n    VTable,\n} from 'roosterjs-editor-dom';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0) {\n                    editor.select(vtable.table, PositionType.Before);\n                    break;\n                } else if (row >= vtable.cells.length) {\n                    editTable(editor, TableOperation.InsertBelow);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        const td = cacheGetTableCell(event, editor);\n        const vtable = new VTable(td);\n        const isUp = event.rawEvent.which == Keys.UP;\n        const step = isUp ? -1 : 1;\n        const hasShiftKey = event.rawEvent.shiftKey;\n        const selection = editor.getDocument().defaultView?.getSelection();\n        let targetTd: HTMLTableCellElement = null;\n\n        if (selection) {\n            let { anchorNode, anchorOffset } = selection;\n\n            for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n                let cell = vtable.getCell(row, vtable.col);\n                if (cell.td && cell.td != td) {\n                    targetTd = cell.td;\n                    break;\n                }\n            }\n\n            editor.runAsync(editor => {\n                let newContainer = editor.getElementAtCursor();\n                if (\n                    contains(vtable.table, newContainer) &&\n                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n                ) {\n                    let newPos = targetTd\n                        ? new Position(targetTd, PositionType.Begin)\n                        : new Position(\n                              vtable.table,\n                              isUp ? PositionType.Before : PositionType.After\n                          );\n                    if (hasShiftKey) {\n                        newPos =\n                            newPos.node.nodeType == NodeType.Element &&\n                            isVoidHtmlElement(newPos.node)\n                                ? new Position(\n                                      newPos.node,\n                                      newPos.isAtEnd ? PositionType.After : PositionType.Before\n                                  )\n                                : newPos;\n                        const selection = editor.getDocument().defaultView?.getSelection();\n                        selection?.setBaseAndExtent(\n                            anchorNode,\n                            anchorOffset,\n                            newPos.node,\n                            newPos.offset\n                        );\n                    } else {\n                        editor.select(newPos);\n                    }\n                }\n            });\n        }\n    },\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const TableFeatures: Record<\n    keyof TableFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    tabInTable: TabInTable,\n    upDownInTable: UpDownInTable,\n};\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            let allNodes = fromHtml(content, doc);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView?.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Make the editor in \"Shadow Edit\" mode.\r\n     * In Shadow Edit mode, all format change will finally be ignored.\r\n     * This can be used for building a live preview feature for format button, to allow user\r\n     * see format result without really apply it.\r\n     * This function can be called repeatly. If editor is already in shadow edit mode, we can still\r\n     * use this function to do more shadow edit operation.\r\n     */\r\n    public startShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, true /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\r\n     */\r\n    public stopShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, false /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in Shadow Edit mode\r\n     */\r\n    public isInShadowEdit() {\r\n        return !!this.core.lifecycle.shadowEditFragment;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { CoreApiMap } from 'roosterjs-editor-types';\nimport { createPasteFragment } from './createPasteFragment';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { focus } from './focus';\nimport { getContent } from './getContent';\nimport { getSelectionRange } from './getSelectionRange';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { hasFocus } from './hasFocus';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { selectRange } from './selectRange';\nimport { setContent } from './setContent';\nimport { switchShadowEdit } from './switchShadowEdit';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\n\n/**\n * @internal\n */\nexport const coreApiMap: CoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    createPasteFragment,\n    ensureTypeInContainer,\n    focus,\n    getContent,\n    getSelectionRange,\n    getStyleBasedFormatState,\n    hasFocus,\n    insertNode,\n    restoreUndoSnapshot,\n    selectRange,\n    setContent,\n    switchShadowEdit,\n    transformColor,\n    triggerEvent,\n};\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    AddUndoSnapshot,\n    ChangeSource,\n    ContentChangedEvent,\n    EditorCore,\n    NodePosition,\n    PluginEventType,\n    GetContentMode,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The EditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core: EditorCore,\n    callback: (start: NodePosition, end: NodePosition) => any,\n    changeSource: ChangeSource | string,\n    canUndoByBackspace: boolean\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    const isShadowEdit = !!core.lifecycle.shadowEditFragment;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        if (!isShadowEdit) {\n            undoState.snapshotsService.addSnapshot(\n                core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                canUndoByBackspace\n            );\n            undoState.hasNewContent = false;\n        }\n    }\n\n    try {\n        if (callback) {\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested && !isShadowEdit) {\n                undoState.snapshotsService.addSnapshot(\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                    false /*isAutoCompleteSnapshot*/\n                );\n                undoState.hasNewContent = false;\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        let event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\n\n        if (range) {\n            core.undo.hasNewContent = false;\n            core.undo.autoCompletePosition = Position.getStart(range);\n        }\n    }\n};\n","import {\n    AttachDomEvent,\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    EditorCore,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (\n    core: EditorCore,\n    eventMap: Record<string, DOMEventHandler>\n) => {\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\n        let onEvent = (event: UIEvent) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n        core.contentDiv.addEventListener(eventName, onEvent);\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    CreatePasteFragment,\n    EditorCore,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\n/**\n * @internal\n * Create a DocumentFragment for paste from a ClipboardData\n * @param core The EditorCore object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param position The position to paste to\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n * false to keep original foramt\n */\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    if (!clipboardData) {\n        return null;\n    }\n\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData);\n    const { fragment, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const document = core.contentDiv.ownerDocument;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (!pasteAsText && !text && imageDataUri) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        !pasteAsText &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\n    ) {\n        // Paste HTML\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\n                startIndex + START_FRAGMENT.length,\n                endIndex\n            );\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        while (doc.body.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        // Paste text\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n            const textNode = document.createTextNode(line);\n\n            // There are 3 scenarios:\n            // 1. Single line: Paste as it is\n            // 2. Two lines: Add <br> between the lines\n            // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line\n            if (lines.length == 2 && index == 0) {\n                // 1 of 2 lines scenario, add BR\n                fragment.appendChild(textNode);\n                fragment.appendChild(document.createElement('br'));\n            } else if (index > 0 && index < lines.length - 1) {\n                // Middle line of >=3 lines scenario, wrap with DIV\n                fragment.appendChild(wrap(line == '' ? document.createElement('br') : textNode));\n            } else {\n                // All others, paste as it is\n                fragment.appendChild(textNode);\n            }\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedForamt.fontName,\n        fontSize: styleBasedForamt.fontSize,\n        textColor: styleBasedForamt.textColor,\n        backgroundColor: styleBasedForamt.backgroundColor,\n        textColors: styleBasedForamt.textColors,\n        backgroundColors: styleBasedForamt.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    toArray(node.querySelectorAll('style')).forEach(callback);\n}\n","import {\n    ContentPosition,\n    EditorCore,\n    EnsureTypeInContainer,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    applyFormat,\n    Browser,\n    createRange,\n    fromHtml,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\n    core: EditorCore,\n    position: NodePosition,\n    keyboardEvent?: KeyboardEvent\n) => {\n    position = position.normalize();\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = fromHtml(\n            Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\n            core.contentDiv.ownerDocument\n        )[0] as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode.firstChild, PositionType.Begin);\n    }\n\n    if (formatNode) {\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.selectRange(core, createRange(position));\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = (core: EditorCore) => {\n    if (!core.lifecycle.shadowEditFragment) {\n        if (\n            !core.api.hasFocus(core) ||\n            !core.api.getSelectionRange(core, false /*tryGetFromCache*/)\n        ) {\n            // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\n            // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\n            // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\n            // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\n            // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\n            // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\n            // It should be better than the case you cannot type\n            if (\n                !core.domEvent.selectionRange ||\n                !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\n            ) {\n                let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\n                core.api.selectRange(\n                    core,\n                    createRange(node, PositionType.Begin),\n                    true /*skipSameRange*/\n                );\n            }\n        }\n\n        // remember to clear cached selection range\n        core.domEvent.selectionRange = null;\n\n        // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import {\n    ColorTransformDirection,\n    EditorCore,\n    GetContent,\n    GetContentMode,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The EditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\n    let content = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommited shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\n        const clonedRoot = cloneNode(root);\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n        const path = !includeSelectionMarker\n            ? null\n            : core.lifecycle.shadowEditFragment\n            ? core.lifecycle.shadowEditSelectionPath\n            : originalRange\n            ? getSelectionPath(core.contentDiv, originalRange)\n            : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        if (core.lifecycle.isDarkMode) {\n            core.api.transformColor(\n                core,\n                clonedRoot,\n                false /*includeSelf*/,\n                null /*callback*/,\n                ColorTransformDirection.DarkToLight\n            );\n        }\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    } else {\n        content = getHtmlWithSelectionPath(\n            root,\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\n        );\n    }\n\n    return content;\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, createRange } from 'roosterjs-editor-dom';\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get current or cached selection range\n * @param core The EditorCore object\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\n * @returns A Range object of the selection range\n */\nexport const getSelectionRange: GetSelectionRange = (\n    core: EditorCore,\n    tryGetFromCache: boolean\n) => {\n    let result: Range = null;\n\n    if (core.lifecycle.shadowEditFragment) {\n        result =\n            core.lifecycle.shadowEditSelectionPath &&\n            createRange(\n                core.contentDiv,\n                core.lifecycle.shadowEditSelectionPath.start,\n                core.lifecycle.shadowEditSelectionPath.end\n            );\n\n        return result;\n    } else {\n        if (!tryGetFromCache || core.api.hasFocus(core)) {\n            let selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                let range = selection.getRangeAt(0);\n                if (contains(core.contentDiv, range)) {\n                    result = range;\n                }\n            }\n        }\n\n        if (!result && tryGetFromCache) {\n            result = core.domEvent.selectionRange;\n        }\n\n        return result;\n    }\n};\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.lifecycle.isDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor:\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\n                      ] ||\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\n                      ],\n              }\n            : undefined,\n    };\n};\n","import {\n    BlockElement,\n    ContentPosition,\n    ColorTransformDirection,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodeType,\n    NodePosition,\n    PositionType,\n    QueryScope,\n} from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    contains,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    getTagOfNode,\n    isBlockElement,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    isVoidHtmlElement,\n    Position,\n    queryElements,\n    safeInstanceOf,\n    splitBalancedNodeRange,\n    splitTextNode,\n    toArray,\n    unwrap,\n    VTable,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range; rangeToRestore: Range } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n    };\n    let contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    let isBegin = option.position == ContentPosition.Begin;\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[];\n                    if (block) {\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    let insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos = Position.getStart(range);\n                    let blockElement: BlockElement;\n\n                    if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\n                    } else {\n                        adjustSteps.forEach(handler => {\n                            pos = handler(contentDiv, node, pos);\n                        });\n                    }\n\n                    let nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n                    range = createRange(pos);\n                    range.insertNode(node);\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n                    core.api.selectRange(core, rangeToRestore);\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction handleHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter(a => blockElement.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\n        ) {\n            let normalizedPosition = position.normalize();\n            let parentNode = normalizedPosition.node.parentNode;\n            let nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            position = new Position(splitter, PositionType.Before);\n            safeRemove(splitter);\n        }\n    }\n\n    return position;\n}\n\nfunction handleStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let rootNodeToInsert = nodeToInsert;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\n    }\n\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem,\n                isPositionAtBeginningOf(position, listItem)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    } else if (tag == 'TABLE' && trNode) {\n        // When inserting a table into a table, if these tables have the same column count, and\n        // current position is at beginning of a row, then merge these two tables\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\n        if (\n            currentTable.col == 0 &&\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\n            newTable.cells[0] &&\n            newTable.cells[0].length == currentTable.cells[0].length &&\n            isPositionAtBeginningOf(position, tdNode)\n        ) {\n            if (\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\n                !rootNodeToInsert.firstChild.nextSibling\n            ) {\n                unwrap(rootNodeToInsert.firstChild);\n            }\n            unwrap(rootNodeToInsert);\n            position = new Position(trNode, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction handleParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        let pos = position.normalize();\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\nfunction handleVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\nimport { hasFocus } from './hasFocus';\nimport {\n    contains,\n    getPendableFormatState,\n    Position,\n    PendableFormatNames,\n    PendableFormatCommandMap,\n    addRangeToSelection,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Change the editor selection to the given range\n * @param core The EditorCore object\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport const selectRange: SelectRange = (\n    core: EditorCore,\n    range: Range,\n    skipSameRange?: boolean\n) => {\n    if (!core.lifecycle.shadowEditSelectionPath && contains(core.contentDiv, range)) {\n        addRangeToSelection(range, skipSameRange);\n\n        if (!hasFocus(core)) {\n            core.domEvent.selectionRange = range;\n        }\n\n        if (range.collapsed) {\n            // If selected, and current selection is collapsed,\n            // need to restore pending format state if exists.\n            restorePendingFormatState(core);\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Restore cached pending format state (if exist) to current selection\n */\nfunction restorePendingFormatState(core: EditorCore) {\n    const {\n        contentDiv,\n        pendingFormatState,\n        api: { getSelectionRange },\n    } = core;\n\n    if (pendingFormatState.pendableFormatState) {\n        const document = contentDiv.ownerDocument;\n        let formatState = getPendableFormatState(document);\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\n                document.execCommand(PendableFormatCommandMap[key], false, null);\n            }\n        });\n\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\n    }\n}\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    EditorCore,\n    PluginEventType,\n    SetContent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The EditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n */\nexport const setContent: SetContent = (\n    core: EditorCore,\n    content: string,\n    triggerContentChangedEvent: boolean\n) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        const range = setHtmlWithSelectionPath(core.contentDiv, content);\n        core.api.selectRange(core, range);\n        contentChanged = true;\n    }\n\n    // Convert content even if it hasn't changed.\n    core.api.transformColor(\n        core,\n        core.contentDiv,\n        false /*includeSelf*/,\n        null /*callback*/,\n        ColorTransformDirection.LightToDark\n    );\n\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n","import { createRange, getSelectionPath } from 'roosterjs-editor-dom';\nimport { EditorCore, PluginEventType, SwitchShadowEdit } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const switchShadowEdit: SwitchShadowEdit = (core: EditorCore, isOn: boolean): void => {\n    const { lifecycle, contentDiv } = core;\n    let { shadowEditFragment, shadowEditSelectionPath } = lifecycle;\n    const wasInShadowEdit = !!shadowEditFragment;\n\n    if (isOn) {\n        if (!wasInShadowEdit) {\n            // Merge sibling text nodes to avoid inaccuracy of text node offset\n            contentDiv.normalize();\n\n            const range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            shadowEditSelectionPath = range && getSelectionPath(contentDiv, range);\n            shadowEditFragment = core.contentDiv.ownerDocument.createDocumentFragment();\n            while (contentDiv.firstChild) {\n                shadowEditFragment.appendChild(contentDiv.firstChild);\n            }\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment: shadowEditFragment,\n                    selectionPath: shadowEditSelectionPath,\n                },\n                false /*broadcast*/\n            );\n\n            lifecycle.shadowEditFragment = shadowEditFragment;\n            lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;\n        }\n\n        contentDiv.innerHTML = '';\n        contentDiv.appendChild(lifecycle.shadowEditFragment.cloneNode(true /*deep*/));\n    } else {\n        lifecycle.shadowEditFragment = null;\n        lifecycle.shadowEditSelectionPath = null;\n\n        if (wasInShadowEdit) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            contentDiv.innerHTML = '';\n            contentDiv.appendChild(shadowEditFragment);\n            core.api.focus(core);\n\n            if (shadowEditSelectionPath) {\n                core.api.selectRange(\n                    core,\n                    createRange(\n                        contentDiv,\n                        shadowEditSelectionPath.start,\n                        shadowEditSelectionPath.end\n                    )\n                );\n            }\n        }\n    }\n};\n","import { arrayPush, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\nimport {\n    ColorTransformDirection,\n    DarkModeDatasetNames,\n    EditorCore,\n    TransformColor,\n} from 'roosterjs-editor-types';\n\nconst STYLE_DATASET_MAP = {\n    /**\n     * Original style color\n     */\n    [DarkModeDatasetNames.OriginalStyleColor]: (element: HTMLElement, value: string) =>\n        (element.style.color = value),\n\n    /**\n     * Original style background color\n     */\n    [DarkModeDatasetNames.OriginalStyleBackgroundColor]: (element: HTMLElement, value: string) =>\n        (element.style.backgroundColor = value),\n};\nconst ATTR_DATASET_MAP = {\n    /**\n     * Original attribute color\n     */\n    [DarkModeDatasetNames.OriginalAttributeColor]: 'color',\n\n    /**\n     * Original attribute background color\n     */\n    [DarkModeDatasetNames.OriginalAttributeBackgroundColor]: 'bgcolor',\n};\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The EditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n */\nexport const transformColor: TransformColor = (\n    core: EditorCore,\n    rootNode: Node,\n    includeSelf: boolean,\n    callback: () => void,\n    direction: ColorTransformDirection\n) => {\n    let elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\n\n    callback?.();\n\n    elementsToTransform.forEach(element => {\n        if (direction == ColorTransformDirection.DarkToLight && element?.dataset) {\n            // Reset color styles based on the content of the ogsc/ogsb data element.\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\n            Object.keys(STYLE_DATASET_MAP).forEach((name: keyof typeof STYLE_DATASET_MAP) => {\n                STYLE_DATASET_MAP[name](element, getValueOrDefault(element.dataset[name], ''));\n                delete element.dataset[name];\n            });\n\n            // Some elements might have set attribute colors. We need to reset these as well.\n            Object.keys(ATTR_DATASET_MAP).forEach((name: keyof typeof ATTR_DATASET_MAP) => {\n                const value = element.dataset[name];\n                if (getValueOrDefault(value, null)) {\n                    element.setAttribute(ATTR_DATASET_MAP[name], value);\n                } else {\n                    element.removeAttribute(ATTR_DATASET_MAP[name]);\n                }\n                delete element.dataset[name];\n            });\n        } else if (direction == ColorTransformDirection.LightToDark && element) {\n            if (core.lifecycle.onExternalContentTransform) {\n                core.lifecycle.onExternalContentTransform(element);\n            } else {\n                element.style.color = null;\n                element.style.backgroundColor = null;\n            }\n        }\n    });\n};\n\nfunction getValueOrDefault(value: string, defualtValue: string | null) {\n    return value && value != 'undefined' && value != 'null' ? value : defualtValue;\n}\n\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\n        if (includeSelf) {\n            result.push(rootNode);\n        }\n        const allChildren = rootNode.getElementsByTagName('*');\n        arrayPush(result, toArray(allChildren));\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\n        const allChildren = rootNode.querySelectorAll('*');\n        arrayPush(result, toArray(allChildren));\n    }\n\n    return result;\n}\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (\n    core: EditorCore,\n    pluginEvent: PluginEvent,\n    broadcast: boolean\n) => {\n    if (\n        !core.lifecycle.shadowEditFragment &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import CopyPastePlugin from './CopyPastePlugin';\nimport DOMEventPlugin from './DOMEventPlugin';\nimport EditPlugin from './EditPlugin';\nimport EntityPlugin from './EntityPlugin';\nimport LifecyclePlugin from './LifecyclePlugin';\nimport MouseUpPlugin from './MouseUpPlugin';\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\nimport TypeAfterLinkPlugin from './TypeAfterLinkPlugin';\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\nimport UndoPlugin from './UndoPlugin';\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\n\n/**\n * @internal\n * Create Core Plugins\n * @param contentDiv Content DIV of editor\n * @param options Editor options\n */\nexport default function createCorePlugins(\n    contentDiv: HTMLDivElement,\n    options: EditorOptions\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\n    const map = options.corePluginOverride || {};\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\n        edit: map.edit || new EditPlugin(),\n        _placeholder: null,\n        typeAfterLink: map.typeAfterLink || new TypeAfterLinkPlugin(),\n        undo: map.undo || new UndoPlugin(options),\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\n        copyPaste: map.copyPaste || new CopyPastePlugin(options),\n        entity: map.entity || new EntityPlugin(),\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins CorePlugins object\n */\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\n        edit: corePlugins.edit.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        undo: corePlugins.undo.getState(),\n        entity: corePlugins.entity.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n    };\n}\n","import {\n    addRangeToSelection,\n    extractClipboardEvent,\n    fromHtml,\n    readFile,\n    setHtmlWithSelectionPath,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ClipboardData,\n    ContentPosition,\n    CopyPastePluginState,\n    EditorOptions,\n    GetContentMode,\n    IEditor,\n    PluginEventType,\n    ExperimentalFeatures,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML =\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\n\n/**\n * @internal\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nexport default class CopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param options The editor options\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            allowedCustomPasteType: options.allowedCustomPasteType || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: this.onPaste,\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        const originalRange = this.editor.getSelectionRange();\n        if (originalRange && !originalRange.collapsed) {\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\n            const newRange = setHtmlWithSelectionPath(tempDiv, html);\n\n            if (newRange) {\n                addRangeToSelection(newRange);\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event as ClipboardEvent,\n                isCut,\n            });\n\n            this.editor.runAsync(editor => {\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\n\n                if (isCut) {\n                    editor.addUndoSnapshot(() => {\n                        const position = this.editor.deleteSelectedContent();\n                        editor.focus();\n                        editor.select(position);\n                    }, ChangeSource.Cut);\n                }\n            });\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        extractClipboardEvent(\n            event as ClipboardEvent,\n            items => {\n                if (items.rawHtml === undefined) {\n                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\n                    // This is mostly for IE\n                    const originalSelectionRange = this.editor.getSelectionRange();\n                    const tempDiv = this.getTempDiv();\n\n                    this.editor.runAsync(() => {\n                        items.rawHtml = tempDiv.innerHTML;\n                        this.cleanUpAndRestoreSelection(tempDiv, originalSelectionRange);\n                        this.paste(items);\n                    });\n                } else {\n                    this.paste(items);\n                }\n            },\n            {\n                allowLinkPreview: this.editor.isFeatureEnabled(\n                    ExperimentalFeatures.PasteWithLinkPreview\n                ),\n                allowedCustomPasteType: this.state.allowedCustomPasteType,\n            }\n        );\n    };\n\n    private paste(clipboardData: ClipboardData) {\n        if (clipboardData.image) {\n            readFile(clipboardData.image, dataUrl => {\n                clipboardData.imageDataUri = dataUrl;\n                this.editor.paste(clipboardData);\n            });\n        } else {\n            this.editor.paste(clipboardData);\n        }\n    }\n\n    private getTempDiv(forceInLightMode?: boolean) {\n        const div = this.editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = fromHtml(\n                    CONTAINER_HTML,\n                    this.editor.getDocument()\n                )[0] as HTMLDivElement;\n                this.editor.insertNode(tempDiv, {\n                    position: ContentPosition.Outside,\n                });\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        if (forceInLightMode) {\n            div.style.backgroundColor = 'white';\n            div.style.color = 'black';\n        }\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\n        this.editor.select(range);\n        tempDiv.style.backgroundColor = '';\n        tempDiv.style.color = '';\n        tempDiv.style.display = 'none';\n        tempDiv.innerHTML = '';\n    }\n}\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContextMenuProvider,\n    DOMEventHandler,\n    DOMEventPluginState,\n    EditorOptions,\n    IEditor,\n    PluginEventType,\n    PluginWithState,\n    EditorPlugin,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n */\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            selectionRange: null,\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        this.disposer = editor.addDomEventHandler({\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: PluginEventType.MouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drop event\n            drop: this.onDrop,\n\n            // 5. Focus mangement\n            focus: this.onFocus,\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\n\n            // 6. Input event\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\n        });\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDrop = (e: UIEvent) => {\n        this.editor.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onFocus = () => {\n        this.editor.select(this.state.selectionRange);\n        this.state.selectionRange = null;\n    };\n\n    private onBlur = () => {\n        this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\n    };\n\n    private onScroll = (e: UIEvent) => {\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        return this.state.stopPrintableKeyboardEventPropagation\n            ? {\n                  pluginEventType: eventType,\n                  beforeDispatch:\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeybaordEvent,\n              }\n            : eventType;\n    }\n\n    private onKeybaordEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event)) {\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n        const searcher = this.editor.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2) {\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode);\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n                arrayPush(allItems, items);\n            }\n        });\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n        let ctrlOrMeta = false;\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                break;\n            }\n        }\n    }\n}\n","import {\n    Browser,\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    isCharacterValue,\n    toArray,\n    arrayPush,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    EntityClasses,\n    EntityOperation,\n    EntityPluginState,\n    HtmlSanitizerOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    QueryScope,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\n\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\nconst ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            clickingPoint: null,\n            knownEntityElements: [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.knownEntityElements = [];\n        this.state.clickingPoint = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.handleCutEvent(event.rawEvent);\n                }\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n            case PluginEventType.ContextMenu:\n                this.handleContextMenuEvent(event.rawEvent);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent(event: UIEvent) {\n        const node = event.target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n\n        if (entityElement) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\n        }\n    }\n\n    private handleCutEvent = (event: ClipboardEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (range && !range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.state.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        let entityElement: HTMLElement;\n\n        if (\n            this.state.clickingPoint &&\n            this.state.clickingPoint.pageX == pageX &&\n            this.state.clickingPoint.pageY == pageY &&\n            node &&\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\n        ) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.state.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.state.knownEntityElements = resetAll\n            ? []\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\n        const allId = this.state.knownEntityElements\n            .map(e => getEntityFromElement(e)?.id)\n            .filter(x => !!x);\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\n                this.state.knownEntityElements.push(element);\n\n                const entity = getEntityFromElement(element);\n\n                this.hydrateEntity(entity, allId);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\n        });\n    }\n\n    private checkRemoveEntityForRange(event: Event) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                this.triggerEvent(\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\n        const { id, type, wrapper, isReadonly } = entity;\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            if (knownIds.indexOf(newId) < 0) {\n                knownIds.push(newId);\n                break;\n            }\n        }\n\n        commitEntity(wrapper, type, isReadonly, newId);\n\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\n    }\n\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\n        const entity = element && getEntityFromElement(element);\n\n        if (entity) {\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                operation,\n                rawEvent,\n                entity,\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: IEditor) => {\n          editor.runAsync(editor => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import { Browser, getComputedStyles } from 'roosterjs-editor-dom';\nimport {\n    DefaultFormat,\n    DocumentCommand,\n    EditorOptions,\n    IEditor,\n    LifecyclePluginState,\n    PluginEventType,\n    PluginWithState,\n    PluginEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\nconst COMMANDS: {\n    [command: string]: any;\n} = Browser.isFirefox\n    ? {\n          /**\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\n           */\n          [DocumentCommand.EnableObjectResizing]: false,\n          [DocumentCommand.EnableInlineTableEditing]: false,\n      }\n    : Browser.isIE\n    ? {\n          /**\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\n           */\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\n\n          /**\n           * Disable auto link feature in IE since we have our own implementation\n           */\n          [DocumentCommand.AutoUrlDetect]: false,\n      }\n    : {};\n\nconst DARK_MODE_DEFAULT_FORMAT = {\n    backgroundColors: {\n        darkModeColor: 'rgb(51,51,51)',\n        lightModeColor: 'rgb(255,255,255)',\n    },\n    textColors: {\n        darkModeColor: 'rgb(255,255,255)',\n        lightModeColor: 'rgb(0,0,0)',\n    },\n};\n\n/**\n * @internal\n * Lifecycle plugin handles editor initialization and disposing\n */\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor;\n    private state: LifecyclePluginState;\n    private initialContent: string;\n    private contentDivFormat: string[];\n    private initializer: () => void;\n    private disposer: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\n        this.contentDivFormat = getComputedStyles(contentDiv);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                this.setSelectStyle(contentDiv, 'text');\n            };\n            this.disposer = () => {\n                this.setSelectStyle(contentDiv, '');\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\n            };\n        }\n\n        this.state = {\n            customData: {},\n            defaultFormat: options.defaultFormat || null,\n            isDarkMode: !!options.inDarkMode,\n            onExternalContentTransform: options.onExternalContentTransform,\n            experimentalFeatures: options.experimentalFeatures || [],\n            shadowEditFragment: null,\n            shadowEditSelectionPath: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Calculate default format\n        this.recalculateDefaultFormat();\n\n        // Ensure initial content and its format\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Do proper change for browsers to disable some browser-specified behaviors.\n        this.adjustBrowserBehavior();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        Object.keys(this.state.customData).forEach(key => {\n            const data = this.state.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete this.state.customData[key];\n        });\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.recalculateDefaultFormat();\n        }\n    }\n\n    private adjustBrowserBehavior() {\n        Object.keys(COMMANDS).forEach(command => {\n            // Catch any possible exception since this should not block the initialization of editor\n            try {\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\n            } catch {}\n        });\n    }\n\n    private setSelectStyle(node: HTMLElement, value: string) {\n        node.style.userSelect = value;\n        node.style.msUserSelect = value;\n        node.style.webkitUserSelect = value;\n    }\n\n    private recalculateDefaultFormat() {\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\n\n        if (isDarkMode && baseFormat) {\n            if (!baseFormat.backgroundColors) {\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\n            }\n            if (!baseFormat.textColors) {\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\n            }\n        }\n\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\n            return;\n        }\n\n        const {\n            fontFamily,\n            fontSize,\n            textColor,\n            textColors,\n            backgroundColor,\n            backgroundColors,\n            bold,\n            italic,\n            underline,\n        } = baseFormat || <DefaultFormat>{};\n        const defaultFormat = this.contentDivFormat;\n\n        this.state.defaultFormat = {\n            fontFamily: fontFamily || defaultFormat[0],\n            fontSize: fontSize || defaultFormat[1],\n            get textColor() {\n                return textColors\n                    ? isDarkMode\n                        ? textColors.darkModeColor\n                        : textColors.lightModeColor\n                    : textColor || defaultFormat[2];\n            },\n            textColors: textColors,\n            get backgroundColor() {\n                return backgroundColors\n                    ? isDarkMode\n                        ? backgroundColors.darkModeColor\n                        : backgroundColors.lightModeColor\n                    : backgroundColor || '';\n            },\n            backgroundColors: backgroundColors,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n        };\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\n * as long as the mouse was pressed within Editor before\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private editor: IEditor;\n    private mouseUpEventListerAdded: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'MouseUp';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n        }\n    }\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n            });\n        }\n    };\n}\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    IEditor,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChagned event, cache current position and pending format\n                this.state.pendableFormatPosition = this.getCurrentPosition();\n                this.state.pendableFormatState = event.formatState;\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                // If content or position is changed (by keyboard, mouse, or code),\n                // check if current position is still the same with the cached one (if exist),\n                // and clear cached format if position is changed since it is out-of-date now\n                if (\n                    this.state.pendableFormatPosition &&\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\n                ) {\n                    this.clear();\n                }\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n    }\n\n    private getCurrentPosition() {\n        let range = this.editor.getSelectionRange();\n        return range && Position.getStart(range).normalize();\n    }\n}\n","import { Browser, LinkInlineElement } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * TypeAfterLinkPlugin Component helps handle typing event when cursor is right after a link.\n * When typing/pasting after a link, browser may put the new charactor inside link.\n * This plugin overrides this behavior to always insert outside of link.\n */\nexport default class TypeAfterLinkPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeAfterLink';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\n            event.eventType == PluginEventType.BeforePaste\n        ) {\n            let range = this.editor.getSelectionRange();\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\n                const searcher = this.editor.getContentSearcherOfCursor(event);\n                const inlineElementBefore = searcher.getInlineElementBefore();\n                const inlineElementAfter = searcher.getInlineElementAfter();\n                if (inlineElementBefore instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementBefore.getContainerNode(), PositionType.After);\n                } else if (inlineElementAfter instanceof LinkInlineElement) {\n                    this.editor.select(inlineElementAfter.getContainerNode(), PositionType.Before);\n                }\n            }\n        }\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            // If normalization was not possible before the keypress,\n            // check again after the keyboard event has been processed by browser native behaviour.\n            //\n            // This handles the case where the keyboard event that first inserts content happens when\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\n            //\n            // Only scheudle when the range is not collapsed to catch this edge case.\n            let range = this.editor.getSelectionRange();\n\n            if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\n                return;\n            }\n\n            if (range.collapsed) {\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\n            } else {\n                this.editor.runAsync(editor => {\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\n                });\n            }\n        }\n    }\n}\n","import {\n    EditorOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshot,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshots,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapsnot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAXSIZELIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor;\n    private lastKeyPress: number;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                if (!this.state.isRestoring) {\n                    this.clearRedoForInput();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else {\n                let selectionRange = this.editor.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        let range = this.editor.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService {\n    const snapshots = createSnapshots(MAXSIZELIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): string => moveCurrentSnapsnot(snapshots, delta),\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshots(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n","export { default as HyperLink } from './HyperLink';\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string;\n    private trackedLink: HTMLAnchorElement = null;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({\n                mouseover: this.onMouse,\n                mouseout: this.onMouse,\n                blur: this.onBlur,\n            });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor.getElementAtCursor(\n                'A[href]',\n                null /*startFrom*/,\n                event\n            ) as HTMLAnchorElement;\n\n            const shouldCheckUpdateLink =\n                anchor !== this.trackedLink ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            let display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            let href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            let linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor.addUndoSnapshot(() => {\n                    this.trackedLink.href = linkData.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n","export { default as Paste } from './Paste';\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromPowerPoint from './pptConverter/convertPastedContentFromPowerPoint';\nimport convertPastedContentFromTeams from './teamsConverter/convertPastedContentFromTeams';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport handleLineMerge from './lineMerge/handleLineMerge';\nimport { EditorPlugin, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { toArray } from 'roosterjs-editor-dom';\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst PROG_ID_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst POWERPOINT_ATTRIBUTE_VALUE = 'PowerPoint.Slide';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or Onenote Online\n */\nexport default class Paste implements EditorPlugin {\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     */\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize() {}\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {}\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            let wacListElements: Node[];\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[PROG_ID_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event);\n            } else if (htmlAttributes[PROG_ID_NAME] == POWERPOINT_ATTRIBUTE_VALUE) {\n                convertPastedContentFromPowerPoint(event);\n            } else if (\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))) &&\n                wacListElements.length > 0\n            ) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\n            } else {\n                convertPastedContentFromTeams(fragment);\n                handleLineMerge(fragment);\n            }\n\n            // Replace unknown tags with SPAN\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n        }\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param event The BeforePaste event\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\n    const html = excelHandler(clipboardData.html, htmlBefore);\n\n    if (clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(html, 'text/html');\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Convert pasted content from PowerPoint\n * @param event The BeforePaste event\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const { fragment, clipboardData } = event;\n\n    if (clipboardData.html && !clipboardData.text && clipboardData.image) {\n        // It is possible that PowerPoint copied both image and HTML but not plain text.\n        // We always prefer HTML if any.\n        const doc = new DOMParser().parseFromString(clipboardData.html, 'text/html');\n\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n}\n","import { changeElementTag, getTagOfNode, toArray } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Convert content copied from Teams to be well-formed\n */\nexport default function convertPastedContentFromTeams(fragment: DocumentFragment) {\n    const firstChild = fragment.firstChild;\n\n    // When copy from Teams, it is possible that we get LI nodes directly under DIV.\n    // In that case we need to convert DIV to UL. It is also possible to be OL, but we don't know it.\n    // So always assume it is UL here, and later user can change it.\n    if (\n        firstChild &&\n        !firstChild.nextSibling &&\n        getTagOfNode(firstChild) == 'DIV' &&\n        !toArray(firstChild.childNodes).some(node => getTagOfNode(node) != 'LI')\n    ) {\n        changeElementTag(firstChild as HTMLElement, 'UL');\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        element.innerHTML = '&nbsp;';\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import WordConverterArguments from './WordConverterArguments';\nimport WordCustomData, { createCustomData } from './WordCustomData';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    wordCustomData: WordCustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        wordCustomData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item metatada of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                while (node.firstChild != null) {\n                    last.appendChild(node.firstChild);\n                }\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                while (node.firstChild) {\n                    li.appendChild(node.firstChild);\n                }\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.wordCustomData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        while (list.firstChild) {\n            newList.appendChild(list.firstChild);\n        }\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list beofre the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list metadada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listprops = listatt.split(' ');\n                if (listprops.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listprops[1].substr('level'.length)),\n                        wordListId: listatt,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring emtpy text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those unstandard values throug the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    ContentTraverser,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        processBlock(blocks[0]);\n        processBlock(blocks[blocks.length - 1]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\n        block.start = node;\n        block.end = node;\n\n        if (getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument.createTextNode('');\n        end.parentNode?.insertBefore(node, end);\n        block.end = node;\n        end.parentNode?.removeChild(end);\n    }\n}\n\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (blockElement?.contains(sibling)) {\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\n            block.start.ownerDocument.createElement('br'),\n            isFirst ? block.end.nextSibling : block.start\n        );\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock?.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\n","import { fromHtml } from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML = '<div style=\"position: fixed; width: 0; height: 0\"></div>';\n\nexport interface ContextMenuOptions<T> {\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    dismiss?: (container: HTMLElement) => void;\n\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport default class ContextMenu<T> implements EditorPlugin {\n    private container: HTMLElement;\n    private editor: IEditor;\n    private isMenuShowing: boolean;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\n            this.options.render(this.container, items as T[], this.onDismiss);\n            this.isMenuShowing = true;\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container) {\n            this.container = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\n            this.editor.insertNode(this.container, {\n                position: ContentPosition.Outside,\n            });\n        }\n        this.container.style.left = x + 'px';\n        this.container.style.top = y + 'px';\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\n","import {\n    CustomReplacement,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: CustomReplacement[] = [\n    makeReplacement(':)', '🙂', true),\n    makeReplacement(';)', '😉', true),\n    makeReplacement(':O', '😲', true),\n    makeReplacement(':o', '😯', true),\n    makeReplacement('<3', '❤️', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: IEditor;\n    private replacements: CustomReplacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: CustomReplacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = replacement.replacementHTML;\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.addUndoSnapshot(\n            () => {\n                matchingRange.deleteContents();\n                matchingRange.insertNode(nodeToInsert);\n                this.editor.select(nodeToInsert, PositionType.End);\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    }\n\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/CutPasteListChain/index';\n","export { default as CutPasteListChain } from './CutPasteListChain';\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\n */\nexport default class CutPasteListChain implements EditorPlugin {\n    private chains: VListChain[];\n    private expectedChangeSource: ChangeSource;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CutPasteListChain';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.cacheListChains(ChangeSource.Cut);\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.cacheListChains(ChangeSource.Paste);\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\n                    experimentCommitListChains(this.editor, this.chains);\n                    this.chains = null;\n                    this.expectedChangeSource = null;\n                }\n                break;\n        }\n    }\n\n    private onDrop = () => {\n        this.cacheListChains(ChangeSource.Drop);\n    };\n\n    private cacheListChains(source: ChangeSource) {\n        this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\n        this.expectedChangeSource = source;\n    }\n}\n","export * from './plugins/ImageResize/index';\n","export { default as ImageResize } from './ImageResize';\n","import { Browser, fromHtml, getEntitySelector, getTagOfNode, toArray } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n    EntityOperation,\n    Entity,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\nconst DELETE_KEYCODE = 46;\nconst BACKSPACE_KEYCODE = 8;\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\nconst ENTITY_TYPE = 'IMAGE_RESIZE_WRAPPER';\n\nconst HANDLE_SIZE = 7;\nconst HANDLE_MARGIN = 3;\nconst CORNER_HANDLE_POSITIONS = ['nw', 'ne', 'se', 'sw'];\nconst SIDE_HANDLE_POSITIONS = ['n', 'e', 's', 'w'];\nconst ALL_HANDLE_POSITIONS = CORNER_HANDLE_POSITIONS.concat(SIDE_HANDLE_POSITIONS);\n\n/**\n * ImageResize plugin provides the ability to resize an inline image in editor\n */\nexport default class ImageResize implements EditorPlugin {\n    private editor: IEditor;\n    private startPageX: number;\n    private startPageY: number;\n    private startWidth: number;\n    private startHeight: number;\n    private resizeDiv: HTMLElement;\n    private direction: string;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        private minWidth: number = 10,\n        private minHeight: number = 10,\n        private selectionBorderColor: string = '#DB626C',\n        private forcePreserveRatio: boolean = false,\n        private resizableImageSelector: string = 'img'\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ImageResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            dragstart: this.onDragStart,\n            blur: this.onBlur,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.hideResizeHandle();\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        if (e.eventType == PluginEventType.MouseDown) {\n            if (this.resizeDiv) {\n                this.hideResizeHandle();\n            }\n        } else if (e.eventType == PluginEventType.MouseUp) {\n            const event = e.rawEvent;\n            const target = <HTMLElement>(event.srcElement || event.target);\n\n            if (getTagOfNode(target) == 'IMG' && target.isContentEditable) {\n                const parent = target.parentNode as HTMLElement;\n                const elements = parent\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\n                    : [];\n                if (elements.indexOf(target) < 0) {\n                    return;\n                }\n\n                const currentImg = this.getSelectedImage();\n                if (currentImg && currentImg != target) {\n                    this.hideResizeHandle();\n                }\n\n                if (!this.resizeDiv) {\n                    this.showResizeHandle(<HTMLImageElement>target);\n                }\n            }\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\n            const event = e.rawEvent;\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\n                this.editor.addUndoSnapshot(() => {\n                    this.editor.deleteNode(this.resizeDiv);\n                });\n                this.resizeDiv = null;\n                event.preventDefault();\n            } else if (\n                event.which != SHIFT_KEYCODE &&\n                event.which != CTRL_KEYCODE &&\n                event.which != ALT_KEYCODE\n            ) {\n                this.hideResizeHandle(true /*selectImage*/);\n            }\n        } else if (\n            e.eventType == PluginEventType.ContentChanged &&\n            e.source != ChangeSource.ImageResize &&\n            (e.source != ChangeSource.InsertEntity || (<Entity>e.data)?.type != ENTITY_TYPE)\n        ) {\n            this.editor.queryElements(getEntitySelector(ENTITY_TYPE), this.removeResizeDiv);\n            this.resizeDiv = null;\n        } else if (e.eventType == PluginEventType.EntityOperation && e.entity.type == ENTITY_TYPE) {\n            if (e.operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeResizeDiv(e.entity.wrapper);\n            } else if (e.operation == EntityOperation.Click) {\n                this.stopEvent(e.rawEvent);\n            }\n        }\n    }\n\n    /**\n     * Select a given IMG element, show the resize handle\n     * @param img The IMG element to select\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.resizeDiv = this.createResizeDiv(img);\n        this.editor.select(this.resizeDiv, PositionType.After);\n    }\n\n    /**\n     * Hide resize handle of current selected image\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        if (this.resizeDiv) {\n            const transform = this.resizeDiv.style.transform;\n            const img = this.removeResizeDiv(this.resizeDiv);\n\n            if (img) {\n                img.style.transform = transform;\n\n                if (selectImageAfterUnSelect) {\n                    this.editor.select(img);\n                }\n            }\n\n            this.resizeDiv = null;\n        }\n    }\n\n    private startResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            this.startPageX = e.pageX;\n            this.startPageY = e.pageY;\n            this.startWidth = img.clientWidth;\n            this.startHeight = img.clientHeight;\n            this.editor.addUndoSnapshot();\n\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).dataset.direction;\n        }\n\n        this.stopEvent(e);\n    };\n\n    private doResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            let widthChange = e.pageX - this.startPageX;\n            let heightChange = e.pageY - this.startPageY;\n            let newWidth = this.calculateNewWidth(widthChange);\n            let newHeight = this.calculateNewHeight(heightChange);\n            const isSingleDirection =\n                this.isSingleDirectionNS(this.direction) ||\n                this.isSingleDirectionWE(this.direction);\n            const shouldPreserveRatio =\n                !isSingleDirection && (this.forcePreserveRatio || e.shiftKey);\n\n            if (shouldPreserveRatio) {\n                newHeight = Math.min(newHeight, (newWidth * this.startHeight) / this.startWidth);\n                newWidth = Math.min(newWidth, (newHeight * this.startWidth) / this.startHeight);\n\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n                if (ratio > 0) {\n                    if (newWidth < newHeight * ratio) {\n                        newWidth = newHeight * ratio;\n                    } else {\n                        newHeight = newWidth / ratio;\n                    }\n                }\n            }\n\n            img.style.width = newWidth + 'px';\n            img.style.height = newHeight + 'px';\n\n            // double check\n            if (shouldPreserveRatio) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n\n                const clientWidth = Math.floor(img.clientWidth);\n                const clientHeight = Math.floor(img.clientHeight);\n                newWidth = Math.floor(newWidth);\n                newHeight = Math.floor(newHeight);\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\n                    if (clientHeight < newHeight) {\n                        newWidth = clientHeight * ratio;\n                    } else {\n                        newHeight = clientWidth / ratio;\n                    }\n                    img.style.width = newWidth + 'px';\n                    img.style.height = newHeight + 'px';\n                }\n            }\n        }\n        this.stopEvent(e);\n    };\n\n    private calculateNewWidth(widthChange: number): number {\n        let newWidth = this.startWidth;\n        if (!this.isSingleDirectionNS(this.direction)) {\n            newWidth = Math.max(\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\n                this.minWidth\n            );\n        }\n        return newWidth;\n    }\n\n    private calculateNewHeight(heightChange: number): number {\n        let newHeight = this.startHeight;\n        if (!this.isSingleDirectionWE(this.direction)) {\n            newHeight = Math.max(\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\n                this.minHeight\n            );\n        }\n        return newHeight;\n    }\n\n    private finishResize = (e: MouseEvent) => {\n        var img = this.getSelectedImage() as HTMLImageElement;\n        if (this.editor && img) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            let width = img.clientWidth;\n            let height = img.clientHeight;\n            img.style.width = width + 'px';\n            img.style.height = height + 'px';\n            img.width = width;\n            img.height = height;\n            this.resizeDiv.style.width = '';\n            this.resizeDiv.style.height = '';\n        }\n        this.direction = null;\n        this.editor.addUndoSnapshot();\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize, img);\n        this.stopEvent(e);\n    };\n\n    private createResizeDiv(target: HTMLElement) {\n        const { wrapper } = insertEntity(\n            this.editor,\n            ENTITY_TYPE,\n            target,\n            false /*isBlock*/,\n            true /*isReadonly*/\n        );\n\n        wrapper.style.position = 'relative';\n        wrapper.style.display = Browser.isSafari ? 'inline-block' : 'inline-flex';\n\n        const html =\n            (this.editor.isFeatureEnabled(ExperimentalFeatures.SingleDirectionResize)\n                ? ALL_HANDLE_POSITIONS\n                : CORNER_HANDLE_POSITIONS\n            )\n                .map(\n                    pos =>\n                        `<div style=\"position:absolute;${this.isWest(pos) ? 'left' : 'right'}:${\n                            this.isSingleDirectionNS(pos) ? '50%' : '0px'\n                        };${this.isNorth(pos) ? 'top' : 'bottom'}:${\n                            this.isSingleDirectionWE(pos) ? '50%' : '0px'\n                        }\">\n                            <div id=${pos}-handle data-direction=\"${pos}\" style=\"position:relative;width:${HANDLE_SIZE}px;height:${HANDLE_SIZE}px;background-color: ${\n                            this.selectionBorderColor\n                        };cursor: ${pos}-resize;${\n                            this.isNorth(pos) ? 'top' : 'bottom'\n                        }:-${HANDLE_MARGIN}px;${\n                            this.isWest(pos) ? 'left' : 'right'\n                        }:-${HANDLE_MARGIN}px\"></div></div>`\n                )\n                .join('') +\n            `<div style=\"position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${this.selectionBorderColor};pointer-events:none;\">`;\n\n        fromHtml(html, this.editor.getDocument()).forEach(div => {\n            wrapper.appendChild(div);\n            div.addEventListener('mousedown', this.startResize);\n        });\n\n        // If the resizeDiv's image has a transform, apply it to the container\n        const selectedImage = this.getSelectedImage(wrapper);\n        if (selectedImage && selectedImage.style && selectedImage.style.transform) {\n            wrapper.style.transform = selectedImage.style.transform;\n            selectedImage.style.transform = '';\n        }\n\n        return wrapper;\n    }\n\n    private stopEvent = (e: Event) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    private removeResizeDiv = (resizeDiv: HTMLElement): HTMLImageElement => {\n        if (resizeDiv?.parentNode) {\n            const img = resizeDiv.querySelector('img');\n            if (img) {\n                resizeDiv.parentNode.insertBefore(img, resizeDiv);\n            }\n            resizeDiv.parentNode.removeChild(resizeDiv);\n            return img;\n        } else {\n            return null;\n        }\n    };\n\n    private onBlur = (e: FocusEvent) => {\n        this.hideResizeHandle();\n    };\n\n    private getSelectedImage(div?: HTMLElement): HTMLElement {\n        const divWithImage = div || this.resizeDiv;\n        return divWithImage ? <HTMLElement>divWithImage.getElementsByTagName('IMG')[0] : null;\n    }\n\n    private isNorth(direction: string): boolean {\n        return direction && direction.substr(0, 1) == 'n';\n    }\n\n    private isWest(direction: string): boolean {\n        return direction && (direction.substr(1, 1) == 'w' || direction == 'w');\n    }\n\n    private isSingleDirectionNS(direction: string): boolean {\n        return direction && (direction == 'n' || direction == 's');\n    }\n\n    private isSingleDirectionWE(direction: string): boolean {\n        return direction && (direction == 'w' || direction == 'e');\n    }\n\n    private onDragStart = (e: DragEvent) => {\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\n            this.hideResizeHandle(true);\n        }\n    };\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin } from './PickerPlugin';\n","import { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    Browser,\n    createRange,\n    isCharacterValue,\n    isModifierKey,\n    PartialInlineElement,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    NodePosition,\n    PickerDataProvider,\n    PickerPluginOptions,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHARCODE = 'Backspace';\nconst TAB_CHARCODE = 'Tab';\nconst ENTER_CHARCODE = 'Enter';\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPlugin {\n    private editor: IEditor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: IEditor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                this.editor.addUndoSnapshot(\n                    insertNode,\n                    this.pickerOptions.changeSource,\n                    this.pickerOptions.handleAutoComplete\n                );\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undos and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = this.editor.getContentSearcherOfCursor(event);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        positionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHARCODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                // #483: If we are backspacing over the trigger character that triggered this Picker\n                // then we need to hide the Picker\n                const wordBeforeCursor = this.getWord(event);\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\n                    this.setIsSuggesting(false);\n                }\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(editor => {\n                        editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { fromHtml, getComputedStyle, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    Rect,\n    ChangeSource,\n    TableOperation,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_COLOR_DARK_MODE = 'white';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\nconst INSERTER_HOVER_OFFSET = 5;\nconst MIN_CELL_WIDTH = 30;\nconst MIN_CELL_HEIGHT = 20;\nconst CELL_RESIZER_WIDTH = 4;\nconst TABLE_RESIZER_LENGTH = 12;\nconst HORIZONTAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: row-resize; user-select: none\"></div>';\nconst VERTICAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: col-resize; user-select: none\"></div>';\nconst TABLE_RESIZER_HTML_LTR =\n    '<div style=\"position: fixed; cursor: nw-resize; user-select: none; border: 1px solid #808080\"></div>';\nconst TABLE_RESIZER_HTML_RTL =\n    '<div style=\"position: fixed; cursor: ne-resize; user-select: none; border: 1px solid #808080\"\"></div>';\n\nconst enum ResizeState {\n    None,\n    Horizontal,\n    Vertical,\n    Both, // when resizing the whole table\n}\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: IEditor;\n    private onMouseMoveDisposer: () => void;\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\n    private resizerContainer: HTMLDivElement;\n    private tableResizerContainer: HTMLDivElement;\n    private currentTable: HTMLTableElement;\n    private currentTd: HTMLTableCellElement;\n    private currentCellsToResize: HTMLTableCellElement[] = [];\n    private nextCellsToResize: HTMLTableCellElement[] = [];\n    private horizontalResizer: HTMLDivElement;\n    private verticalResizer: HTMLDivElement;\n    private tableResizer: HTMLDivElement;\n    private resizingState: ResizeState = ResizeState.None;\n\n    private currentInsertTd: HTMLTableCellElement;\n    private insertingState: ResizeState = ResizeState.None;\n    private inserter: HTMLDivElement;\n    private isRTL: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.setupResizerContainer();\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onMouseMoveDisposer();\n        this.tableRectMap = null;\n        this.removeResizerContainer();\n        this.setCurrentTable(null);\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.Input:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.Scroll:\n                this.tableRectMap = null;\n                break;\n        }\n    }\n\n    private setupResizerContainer() {\n        const document = this.editor.getDocument();\n        this.resizerContainer = document.createElement('div');\n        this.editor.insertNode(this.resizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n\n        this.tableResizerContainer = document.createElement('div');\n        this.editor.insertNode(this.tableResizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n    }\n\n    private removeResizerContainer() {\n        this.resizerContainer?.parentNode?.removeChild(this.resizerContainer);\n        this.resizerContainer = null;\n        this.tableResizerContainer?.parentNode?.removeChild(this.tableResizerContainer);\n        this.tableResizerContainer = null;\n    }\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (this.resizingState != ResizeState.None) {\n            return;\n        }\n\n        if (!this.tableRectMap) {\n            this.cacheRects();\n        }\n\n        if (this.tableRectMap) {\n            this.setCurrentTable(null);\n            let i = this.tableRectMap.length - 1;\n            while (i >= 0) {\n                const { table, rect } = this.tableRectMap[i];\n\n                if (\n                    e.pageX <=\n                        rect.right + (this.isRTL ? INSERTER_SIDE_LENGTH : TABLE_RESIZER_LENGTH) &&\n                    e.pageX >=\n                        rect.left - (this.isRTL ? TABLE_RESIZER_LENGTH : INSERTER_SIDE_LENGTH) &&\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\n                    e.pageY <= rect.bottom + TABLE_RESIZER_LENGTH\n                ) {\n                    this.setCurrentTable(table);\n                    break;\n                }\n\n                i--;\n            }\n\n            if (this.currentTable) {\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\n                this.setTableResizer(map.rect);\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\n                    const tr = this.currentTable.rows[i];\n                    let j = 0;\n                    for (; j < tr.cells.length; j++) {\n                        const td = tr.cells[j];\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                        if (\n                            tdRect &&\n                            (this.isRTL ? e.pageX >= tdRect.left : e.pageX <= tdRect.right) &&\n                            e.pageY <= tdRect.bottom\n                        ) {\n                            // check vertical inserter\n                            if (i == 0 && e.pageY <= tdRect.top + INSERTER_HOVER_OFFSET) {\n                                let verticalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (\n                                    this.isRTL\n                                        ? e.pageX <=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                        : e.pageX >=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                ) {\n                                    verticalInserterTd = td;\n                                } else if (\n                                    this.isRTL ? e.pageX <= tdRect.right : e.pageX >= tdRect.left\n                                ) {\n                                    // set inserter at previous td if it exists\n                                    const preTd = td.previousElementSibling as HTMLTableCellElement;\n                                    if (preTd) {\n                                        verticalInserterTd = preTd;\n                                    }\n                                }\n                                if (verticalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    // we hide the inserter if left mouse button is pressed\n                                    if (e.buttons == 0) {\n                                        this.setCurrentInsertTd(\n                                            ResizeState.Vertical,\n                                            verticalInserterTd,\n                                            map.rect\n                                        );\n                                    }\n                                    break;\n                                }\n                                // check horizontal inserter\n                            } else if (\n                                j == 0 &&\n                                (this.isRTL\n                                    ? e.pageX >= tdRect.right - INSERTER_HOVER_OFFSET\n                                    : e.pageX <= tdRect.left + INSERTER_HOVER_OFFSET)\n                            ) {\n                                let horizontalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (e.pageY >= tdRect.top + (tdRect.bottom - tdRect.top) / 2.0) {\n                                    horizontalInserterTd = td;\n                                } else if (e.pageY >= tdRect.top) {\n                                    // set insert at previous td if it exists\n                                    const preTd = this.currentTable.rows[i - 1]?.cells[0];\n                                    if (preTd) {\n                                        horizontalInserterTd = preTd;\n                                    }\n                                }\n\n                                if (horizontalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    // we hide the inserter if left mouse button is pressed\n                                    if (e.buttons == 0) {\n                                        this.setCurrentInsertTd(\n                                            ResizeState.Horizontal,\n                                            horizontalInserterTd,\n                                            map.rect\n                                        );\n                                    }\n                                    break;\n                                }\n                            } else {\n                                this.setCurrentTd(\n                                    td,\n                                    map.rect,\n                                    this.isRTL ? tdRect.left : tdRect.right,\n                                    tdRect.bottom\n                                );\n                                this.setCurrentInsertTd(ResizeState.None);\n                                break;\n                            }\n                        }\n                    }\n                    if (j < tr.cells.length) {\n                        break;\n                    }\n                }\n            } else {\n                this.setTableResizer(null);\n            }\n        }\n    };\n\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td: HTMLTableCellElement,\n        tableRect: Rect\n    ): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td?: HTMLTableCellElement,\n        tableRect?: Rect\n    ) {\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\n            if (this.currentInsertTd) {\n                this.inserter?.parentNode?.removeChild(this.inserter);\n                this.inserter = null;\n            }\n            this.insertingState = insertingState;\n            this.currentInsertTd = td;\n            if (this.currentInsertTd) {\n                this.inserter = this.createInserter(tableRect);\n                this.resizerContainer.appendChild(this.inserter);\n            }\n        }\n    }\n\n    private createInserter(tableRect: Rect) {\n        if (this.insertingState == ResizeState.None) {\n            return;\n        }\n\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\n        const inserterColor = this.editor.isDarkMode() ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;\n        const leftOrRight = this.isRTL ? 'right' : 'left';\n\n        const HORIZONTAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; ${leftOrRight}: 12px; top: 5px; height: 3px; border-top: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n        const VERTICAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n\n        const inserter = fromHtml(\n            this.insertingState == ResizeState.Horizontal\n                ? HORIZONTAL_INSERTER_HTML\n                : VERTICAL_INSERTER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n\n        if (rect) {\n            if (this.insertingState == ResizeState.Horizontal) {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.right}px`;\n                } else {\n                    inserter.style.left = `${\n                        rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                    }px`;\n                }\n                inserter.style.top = `${rect.bottom - 8}px`;\n                (inserter.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.left - 8}px`;\n                } else {\n                    inserter.style.left = `${rect.right - 8}px`;\n                }\n                inserter.style.top = `${\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (inserter.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n        }\n\n        inserter.addEventListener('click', this.insertTd);\n\n        return inserter;\n    }\n\n    private insertTd = () => {\n        this.editor.addUndoSnapshot((start, end) => {\n            const vtable = new VTable(this.currentInsertTd);\n            vtable.edit(\n                this.insertingState == ResizeState.Horizontal\n                    ? TableOperation.InsertBelow\n                    : TableOperation.InsertRight\n            );\n            vtable.writeBack();\n            this.editor.select(start, end);\n            this.setCurrentInsertTd(ResizeState.None);\n        }, ChangeSource.Format);\n    };\n\n    private setCurrentTable(table: HTMLTableElement) {\n        if (this.currentTable != table) {\n            this.setCurrentTd(null);\n            this.setCurrentInsertTd(ResizeState.None);\n            this.currentTable = table;\n        }\n    }\n\n    private setCurrentTd(td: null): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect: Rect,\n        resizerPosX: number,\n        bottom: number\n    ): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect?: Rect,\n        resizerPosX?: number,\n        bottom?: number\n    ) {\n        if (this.currentTd != td) {\n            if (this.currentTd) {\n                this.horizontalResizer?.parentNode?.removeChild(this.horizontalResizer);\n                this.verticalResizer?.parentNode?.removeChild(this.verticalResizer);\n                this.horizontalResizer = null;\n                this.verticalResizer = null;\n            }\n\n            this.currentTd = td;\n\n            if (this.currentTd) {\n                this.horizontalResizer = this.createCellsResizer(\n                    true /*horizontal*/,\n                    tableRect.left,\n                    bottom - CELL_RESIZER_WIDTH + 1,\n                    tableRect.right - tableRect.left,\n                    CELL_RESIZER_WIDTH\n                );\n                this.verticalResizer = this.createCellsResizer(\n                    false /*horizontal*/,\n                    resizerPosX - CELL_RESIZER_WIDTH + 1,\n                    tableRect.top,\n                    CELL_RESIZER_WIDTH,\n                    tableRect.bottom - tableRect.top\n                );\n\n                this.resizerContainer.appendChild(this.horizontalResizer);\n                this.resizerContainer.appendChild(this.verticalResizer);\n            }\n        }\n    }\n\n    private setTableResizer(rect: Rect | null): void {\n        // remove old one if exists\n        while (this.tableResizerContainer?.hasChildNodes()) {\n            this.tableResizerContainer.removeChild(this.tableResizerContainer.lastChild);\n        }\n        this.tableResizer = null;\n        // add new one if exists\n        if (rect) {\n            this.tableResizer = this.createTableResizer(rect);\n            this.tableResizerContainer.appendChild(this.tableResizer);\n        }\n    }\n\n    private createTableResizer(rect: Rect): HTMLDivElement {\n        const div = fromHtml(\n            this.isRTL ? TABLE_RESIZER_HTML_RTL : TABLE_RESIZER_HTML_LTR,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n\n        div.style.top = `${rect.bottom}px`;\n        div.style.left = this.isRTL\n            ? `${rect.left - TABLE_RESIZER_LENGTH - 2}px`\n            : `${rect.right}px`;\n        div.style.width = `${TABLE_RESIZER_LENGTH}px`;\n        div.style.height = `${TABLE_RESIZER_LENGTH}px`;\n\n        div.addEventListener('mousedown', this.startResizingTable);\n\n        return div;\n    }\n\n    private createCellsResizer(\n        horizontal: boolean,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ): HTMLDivElement {\n        const div = fromHtml(\n            horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n        div.style.top = `${top}px`;\n        div.style.left = `${left}px`;\n        div.style.width = `${width}px`;\n        div.style.height = `${height}px`;\n\n        div.addEventListener(\n            'mousedown',\n            horizontal ? this.startHorizontalResizeCells : this.startVerticalResizeCells\n        );\n\n        return div;\n    }\n\n    private startResizingTable = (e: MouseEvent) => {\n        if (this.currentTable == null) {\n            return;\n        }\n        this.resizingState = ResizeState.Both;\n        const rect = normalizeRect(this.currentTable.getBoundingClientRect());\n        if (this.isRTL) {\n            this.currentTable.setAttribute('currentLeftBorder', rect.left.toString());\n        } else {\n            this.currentTable.setAttribute('currentRightBorder', rect.right.toString());\n        }\n        this.currentTable.setAttribute('currentBottomBorder', rect.bottom.toString());\n        this.startResizeCells(e);\n    };\n\n    private startHorizontalResizeCells = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Horizontal;\n        this.startResizeCells(e);\n    };\n\n    private startVerticalResizeCells = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Vertical;\n\n        const vtable = new VTable(this.currentTd);\n        if (vtable) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            // calculate and retrieve the cells of the two columns shared by the current vertical resizer\n            this.currentCellsToResize = vtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                !this.isRTL\n            );\n            this.nextCellsToResize = vtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                this.isRTL\n            );\n        }\n\n        this.startResizeCells(e);\n    };\n\n    private startResizeCells(e: MouseEvent) {\n        const doc = this.editor.getDocument();\n        doc.addEventListener('mousemove', this.frameAnimateResizeCells, true);\n        doc.addEventListener('mouseup', this.endResizeCells, true);\n    }\n\n    private frameAnimateResizeCells = (e: MouseEvent) => {\n        this.editor.runAsync(() => this.resizeCells(e));\n    };\n\n    private resizeCells = (e: MouseEvent) => {\n        this.setTableResizer(null);\n        if (this.resizingState === ResizeState.None) {\n            return;\n        } else if (this.resizingState === ResizeState.Both) {\n            let rect = normalizeRect(this.currentTable.getBoundingClientRect());\n            let vtable = new VTable(this.currentTable);\n\n            let currentBorder: number = parseFloat(\n                this.currentTable.getAttribute(\n                    this.isRTL ? 'currentLeftBorder' : 'currentRightBorder'\n                )\n            );\n            const tableBottomBorder: number = parseFloat(\n                this.currentTable.getAttribute('currentBottomBorder')\n            );\n            const ratioX =\n                1.0 +\n                (this.isRTL\n                    ? (currentBorder - e.pageX) / (rect.right - currentBorder)\n                    : (e.pageX - currentBorder) / (currentBorder - rect.left));\n            const ratioY = 1.0 + (e.pageY - tableBottomBorder) / (tableBottomBorder - rect.top);\n\n            const shouldResizeX = Math.abs(ratioX - 1.0) > 1e-3;\n            const shouldResizeY = Math.abs(ratioY - 1.0) > 1e-3;\n            if (shouldResizeX || shouldResizeY) {\n                for (let i = 0; i < vtable.cells.length; i++) {\n                    for (let j = 0; j < vtable.cells[i].length; j++) {\n                        const cell = vtable.cells[i][j];\n                        if (cell.td) {\n                            if (shouldResizeX) {\n                                const originalWidth: number = cell.td.style.width\n                                    ? parseFloat(\n                                          cell.td.style.width.substr(\n                                              0,\n                                              cell.td.style.width.length - 2\n                                          )\n                                      )\n                                    : cell.td.getBoundingClientRect().right -\n                                      cell.td.getBoundingClientRect().left;\n                                const newWidth = originalWidth * ratioX;\n                                cell.td.style.boxSizing = 'border-box';\n                                if (newWidth >= MIN_CELL_WIDTH) {\n                                    cell.td.style.wordBreak = 'break-word';\n                                    cell.td.style.width = `${newWidth}px`;\n                                }\n                            }\n\n                            if (shouldResizeY) {\n                                if (j == 0) {\n                                    const originalHeight =\n                                        cell.td.getBoundingClientRect().bottom -\n                                        cell.td.getBoundingClientRect().top;\n                                    const newHeight = originalHeight * ratioY;\n                                    if (newHeight >= MIN_CELL_HEIGHT) {\n                                        cell.td.style.height = `${newHeight}px`;\n                                    }\n                                } else {\n                                    cell.td.style.height = '';\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            rect = normalizeRect(this.currentTable.getBoundingClientRect());\n            currentBorder = this.isRTL ? rect.left : rect.right;\n            this.currentTable.setAttribute(\n                this.isRTL ? 'currentLeftBorder' : 'currentRightBorder',\n                currentBorder.toString()\n            );\n\n            const currentBottomBorder = this.currentTable.getBoundingClientRect().bottom;\n            this.currentTable.setAttribute('currentBottomBorder', currentBottomBorder.toString());\n            vtable.writeBack();\n            return;\n        } else if (this.currentTd) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            if (rect) {\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\n\n                let vtable = new VTable(this.currentTd);\n\n                if (this.resizingState == ResizeState.Horizontal) {\n                    vtable.table.style.height = null;\n                    vtable.forEachCellOfCurrentRow(cell => {\n                        if (cell.td) {\n                            cell.td.style.height =\n                                cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\n                        }\n                    });\n                } else {\n                    let leftBoundary: number;\n                    let rightBoundary: number;\n\n                    if (this.isRTL) {\n                        leftBoundary =\n                            this.nextCellsToResize.length > 0\n                                ? parseInt(\n                                      this.nextCellsToResize[0].getAttribute('originalLeftBorder')\n                                  )\n                                : 0;\n                        rightBoundary = parseInt(\n                            this.currentCellsToResize[0].getAttribute('originalRightBorder')\n                        );\n                    } else {\n                        leftBoundary = parseInt(\n                            this.currentCellsToResize[0].getAttribute('originalLeftBorder')\n                        );\n                        rightBoundary =\n                            this.nextCellsToResize.length > 0\n                                ? parseInt(\n                                      this.nextCellsToResize[0].getAttribute('originalRightBorder')\n                                  )\n                                : Number.MAX_SAFE_INTEGER;\n                    }\n\n                    if (e.shiftKey) {\n                        if (\n                            (!this.isRTL && newPos <= leftBoundary + MIN_CELL_WIDTH) ||\n                            (this.isRTL && newPos >= rightBoundary - MIN_CELL_WIDTH)\n                        ) {\n                            return;\n                        }\n                    } else if (\n                        newPos <= leftBoundary + MIN_CELL_WIDTH ||\n                        newPos >= rightBoundary - MIN_CELL_WIDTH\n                    ) {\n                        return;\n                    }\n\n                    this.currentCellsToResize.forEach(td => {\n                        const rect = normalizeRect(td.getBoundingClientRect());\n                        td.style.wordBreak = 'break-word';\n                        td.style.boxSizing = 'border-box';\n                        td.style.width = this.isRTL\n                            ? `${rect.right - newPos}px`\n                            : `${newPos - rect.left}px`;\n                    });\n\n                    if (!e.shiftKey) {\n                        this.nextCellsToResize.forEach(td => {\n                            td.style.wordBreak = 'break-word';\n                            const tdWidth = this.isRTL\n                                ? newPos - parseInt(td.getAttribute('originalLeftBorder'))\n                                : parseInt(td.getAttribute('originalRightBorder')) - newPos;\n                            td.style.boxSizing = 'border-box';\n                            td.style.width = `${tdWidth}px`;\n                        });\n                    }\n                }\n                vtable.writeBack();\n            }\n        }\n    };\n\n    private endResizeCells = (e: MouseEvent) => {\n        const doc = this.editor.getDocument();\n        doc.removeEventListener('mousemove', this.frameAnimateResizeCells, true);\n        doc.removeEventListener('mouseup', this.endResizeCells, true);\n        this.currentCellsToResize = [];\n        this.nextCellsToResize = [];\n\n        this.editor.addUndoSnapshot((start, end) => {\n            this.frameAnimateResizeCells(e);\n            this.editor.select(start, end);\n        }, ChangeSource.Format);\n\n        this.setCurrentTd(null);\n        this.setTableResizer(null);\n        this.resizingState = ResizeState.None;\n    };\n\n    private cacheRects() {\n        this.tableRectMap = [];\n        this.editor.queryElements('table', table => {\n            if (table.isContentEditable) {\n                const rect = normalizeRect(table.getBoundingClientRect());\n                if (rect) {\n                    this.tableRectMap.push({\n                        table,\n                        rect,\n                    });\n                }\n            }\n        });\n        this.isRTL = getComputedStyle(this.editor.getDocument().body, 'direction') == 'rtl';\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    DefaultFormat,\n    EditorPlugin,\n    Entity,\n    EntityOperation,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColor: '#aaa',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.showHideWatermark,\n            blur: this.showHideWatermark,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.EditorReady ||\n            (event.eventType == PluginEventType.ContentChanged &&\n                (<Entity>event.data)?.type != ENTITY_TYPE)\n        ) {\n            this.showHideWatermark();\n        } else if (\n            event.eventType == PluginEventType.EntityOperation &&\n            event.entity.type == ENTITY_TYPE\n        ) {\n            const {\n                operation,\n                entity: { wrapper },\n            } = event;\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeWatermark(wrapper);\n            } else if (event.operation == EntityOperation.NewEntity) {\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\n                wrapper.spellcheck = false;\n            }\n        }\n    }\n\n    private showHideWatermark = () => {\n        const hasFocus = this.editor.hasFocus();\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\n        const isShowing = watermarks.length > 0;\n\n        if (hasFocus && isShowing) {\n            watermarks.forEach(this.removeWatermark);\n            this.editor.focus();\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\n            insertEntity(\n                this.editor,\n                ENTITY_TYPE,\n                this.editor.getDocument().createTextNode(this.watermark),\n                false /*isBlock*/,\n                false /*isReadonly*/,\n                ContentPosition.Begin\n            );\n        }\n    };\n\n    private removeWatermark = (wrapper: HTMLElement) => {\n        const parentNode = wrapper.parentNode;\n        parentNode?.removeChild(wrapper);\n\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n        if (\n            this.editor.contains(parentNode) &&\n            getTagOfNode(parentNode) == 'DIV' &&\n            !parentNode.firstChild\n        ) {\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n        }\n    };\n}\n"],"sourceRoot":""}