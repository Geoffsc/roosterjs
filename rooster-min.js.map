{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentToggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getInnerHTML.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentSetIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeAfterLinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","node","nodeType","tagName","toUpperCase","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","internalContains","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","matches","msMatchesSelector","parentElement","CRLF","CRLFSPACE","shouldSkipNode","textContent","replace","region","nodeBefore","nodeAfter","html","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","beforeRunCallback","regions","getSelectedRegions","isFeatureEnabled","VListChain","createListChains","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","findListItems","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","originalLength","splice","mergeOrphanNodesAfter","isOrphanItem","canMerge","mergeItems","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","existingList","getElementAtCursor","parentLINode","currentRange","currentSelectionPath","getSelectionPath","listParent","nextElementSibling","insertAdjacentElement","wrappedContents","wrap","toArray","wrappedRange","wrappedSelectionPath","deleteNode","newRange","childElementCount","newList","listType","startNumber","chains","chain","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","collapseToSingleElement","createVListFromRegion","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","equals","blockElement","HTML_VOID_ELEMENTS","isFirst","getLeafNode","clientRect","left","right","top","bottom","tempNode","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","commit","color","backgroundColor","isDarkMode","darkModeColor","lightModeColor","dataset","fontName","fontFamily","fontSize","lineHeight","wrapFunction","getSelectedBlockElementsInRegion","collapseNodesInRegion","NodeTag","isNodeInRegion","hasFocus","core","activeElement","contentDiv","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","options","defaultFormat","textColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","clipboardData","data","link","matchLink","text","getRangeFromText","word","getWordBefore","trailingPunctuation","match","substring","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","format","elementStyle","textColors","backgroundColors","bold","italic","underline","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","workaroundForEdge","headerValues","parseInt","getAsString","Promise","resolve","types","getData","image","rawHtml","handlers","promise","allowLinkPreview","linkPreview","JSON","parse","all","handler","then","values","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","FileReader","onload","onerror","readAsDataURL","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","orderListStyles","wrapIfNotBlockNode","pop","originalRoot","nextLevel","createListElement","newRoot","listStyleType","checkFirst","checkLast","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","listNode","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rect","getBoundingClientRect","rects","getClientRects","span","areAllPrevousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","getRangeAt","removeAllRanges","e","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","j","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","className","HTML_TAG_REPLACEMENT","a","abbr","address","area","article","aside","b","bdi","bdo","blockquote","br","button","canvas","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","img","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","q","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","base","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","isReadonly","contentEditable","isEntity","eventDataCache","isCtrlOrMetaPressed","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","returnBlockElement","isBlockElement","isVoidHtmlElement","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","nonborderStyles","STYLES_TO_REMOVE","queryElements","getDefaultFormat","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","listTag","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","src","maxWidth","imageFile","readFile","dataUrl","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","VTable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","angle","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","findClosestElementAncestor","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","borderColor","paddingLeft","PRE_TAG","level","wrapped","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","shiftKey","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","isPositionAtBeginningOf","getListChains","experimentCommitListChains","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","isNodeEmpty","OutdentWhenEnterOnEmptyLine","AutoBullet","textBeforeCursor","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","fromHtml","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","hasShiftKey","targetTd","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","existingNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","insertContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","startShadowEdit","switchShadowEdit","stopShadowEdit","isInShadowEdit","shadowEditFragment","experimentalFeatures","undoState","isNested","isShadowEdit","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","imageDataUri","querySelector","attrs","lastIndexOf","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","clonedNode","originalRange","shadowEditSelectionPath","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","adjustSteps","nodeToInsert","safeRemove","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","changeElementTag","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","setHtmlWithSelectionPath","isOn","wasInShadowEdit","STYLE_DATASET_MAP","ATTR_DATASET_MAP","getValueOrDefault","defualtValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","onExternalContentTransform","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","getTempDiv","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","forceInLightMode","tempDiv","onDrop","onFocus","onBlur","onScroll","onKeybaordEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","height","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","clear","getCurrentPosition","undoSnapshotService","createSnapshots","delta","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","y","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","ENTITY_TYPE","CORNER_HANDLE_POSITIONS","ALL_HANDLE_POSITIONS","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","startPageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","stopEvent","widthChange","heightChange","newWidth","calculateNewWidth","newHeight","calculateNewHeight","shouldPreserveRatio","isSingleDirectionNS","isSingleDirectionWE","ratio","resizeDiv","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","currentImg","showResizeHandle","createResizeDiv","selectImageAfterUnSelect","isWest","isNorth","selectedImage","divWithImage","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","inlineElementBefore","inlineElementAfter","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","tableRectMap","resizingState","insertingState","onMouseMove","cacheRects","setCurrentTable","tdRect","normalizeRect","setCurrentTd","setCurrentInsertTd","insertTd","currentInsertTd","startHorizontalResizeTable","startResizeTable","startVerticalResizeTable","frameAnimateResizeTable","resizeTable","currentTd","wordBreak","endResizeTable","setupResizerContainer","onMouseMoveDisposer","destoryRectMap","removeResizerContainer","resizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","HORIZONTAL_INSERTER_HTML","VERTICAL_INSERTER_HTML","horizontalResizer","verticalResizer","createResizer","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 83);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as arrayPush } from './utils/arrayPush';\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as normalizeRect } from './utils/normalizeRect';\r\nexport { default as toArray } from './utils/toArray';\r\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\r\nexport { default as readFile } from './utils/readFile';\r\nexport { default as getInnerHTML } from './utils/getInnerHTML';\r\n\r\nexport { default as VTable } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\nexport { default as VListChain } from './list/VListChain';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\r\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\r\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as commitEntity } from './entity/commitEntity';\r\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\r\nexport { default as getEntitySelector } from './entity/getEntitySelector';\r\n\r\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\r\nexport { default as isModifierKey } from './event/isModifierKey';\r\nexport { default as isCharacterValue } from './event/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\r\n\r\nexport { default as getStyles } from './style/getStyles';\r\nexport { default as setStyles } from './style/setStyles';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * @internal Export for test only\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: any,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    IEditor,\n    NodePosition,\n    Region,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: IEditor,\n    callback: (\n        region: Region,\n        start: NodePosition,\n        end: NodePosition,\n        chains: VListChain[]\n    ) => void,\n    beforeRunCallback?: () => boolean\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        if (!beforeRunCallback || beforeRunCallback()) {\n            const regions = editor.getSelectedRegions();\n            const chains = editor.isFeatureEnabled(ExperimentalFeatures.ListChain)\n                ? VListChain.createListChains(regions, start?.node)\n                : [];\n            regions.forEach(region => callback(region, start, end, chains));\n            experimentCommitListChains(editor, chains);\n        }\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\n * A type-safe wrapper for Array.prototype.push.apply()\n * @param mainArray The main array to push items into\n * @param itemsArray The items to push to main array\n */\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\n    Array.prototype.push.apply(mainArray, itemsArray);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    private items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get list number of the last item in this VList.\n     * If there is no order list item, result will be undefined\n     */\n    getLastItemNumber(): number | undefined {\n        const start = getStart(this.rootList);\n\n        return start === undefined\n            ? start\n            : start -\n                  1 +\n                  this.items.filter(\n                      item => item.getListType() == ListType.Ordered && item.getLevel() == 1\n                  ).length;\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const doc = this.rootList.ownerDocument;\n        const listStack: Node[] = [doc.createDocumentFragment()];\n        const placeholder = doc.createTextNode('');\n        let start = getStart(this.rootList) || 1;\n        let lastList: Node;\n\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\n\n        this.items.forEach(item => {\n            item.writeBack(listStack, this.rootList);\n            const topList = listStack[1];\n\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\n                if (lastList != topList) {\n                    if (start == 1) {\n                        topList.removeAttribute('start');\n                    } else {\n                        topList.start = start;\n                    }\n                }\n\n                if (item.getLevel() == 1) {\n                    start++;\n                }\n            }\n\n            lastList = topList;\n        });\n\n        // Restore the content to the positioni of placeholder\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease ? item.outdent() : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        const nodeTag = getTagOfNode(node);\n\n        // Change DIV tag to SPAN. Otherwise we can create new list item by Enter key in Safari\n        if (nodeTag == 'DIV') {\n            node = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag != 'LI') {\n            node = wrap(node, 'LI');\n        }\n\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            const originalLength = this.items.length;\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n\n            this.mergeOrphanNodesAfter(originalLength - 1);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private mergeOrphanNodesAfter(startIndex: number) {\n        const item = this.items[startIndex];\n\n        if (item && !item.isOrphanItem()) {\n            for (let i = startIndex + 1; i <= this.items.length; i++) {\n                if (!item || !item.canMerge(this.items[i])) {\n                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));\n                    break;\n                }\n            }\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n            this.mergeOrphanNodesAfter(endIndex);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n\n        for (let item = list.firstChild; !!item; item = item.nextSibling) {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item as HTMLOListElement | HTMLUListElement, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        }\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { Region, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get the selection range in the given region.\n * The original range can cover multiple regions, this function will narrow the origianl selection\n * of a region into current region\n * @param regionBase The region to get range from\n */\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\n    if (!regionBase) {\n        return null;\n    }\n\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\n\n    if (!isRegion(regionBase)) {\n        return regionRange;\n    } else if (regionRange) {\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            return createRange(start, end);\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\n    const region = regionBase as Region;\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\n}\n","/**\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport default function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","/**\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\n * @param element The element to set styles\n * @param styles The styles to set, in name-value pair format\n */\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\n    if (element) {\n        const style = Object.keys(styles || {})\n            .map(name => {\n                let value = styles[name];\n                name = name ? name.trim() : null;\n                value = value ? value.trim() : null;\n                return name && value ? `${name}:${value}` : null;\n            })\n            .filter(x => x)\n            .join(';');\n        if (style) {\n            element.setAttribute('style', style);\n        } else {\n            element.removeAttribute('style');\n        }\n    }\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    createRange,\r\n    getSelectionPath,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type ValidProcessListDocumentCommands =\r\n    | DocumentCommand.Outdent\r\n    | DocumentCommand.Indent\r\n    | DocumentCommand.InsertOrderedList\r\n    | DocumentCommand.InsertUnorderedList;\r\n\r\n/**\r\n * @internal\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(\r\n    editor: IEditor,\r\n    command: ValidProcessListDocumentCommands\r\n): Node {\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    if (Browser.isChrome && command !== DocumentCommand.Indent) {\r\n        // Chrome has a bug where certain information about elements are deleted when outdent or enter on empty line occurs.\r\n        // We need to clone our current LI node so we can replace the new LI node with it post outdent / enter.\r\n        const parentLINode = editor.getElementAtCursor('LI');\r\n        // We must first be in an LI node to do something to fix this.\r\n        if (parentLINode) {\r\n            // We also don't want to try to handle the multi select outdent case at this time.\r\n            // These are already pretty stable in Chromium.\r\n            const currentRange = editor.getSelectionRange();\r\n            const currentSelectionPath = getSelectionPath(parentLINode, currentRange);\r\n            if (\r\n                currentRange &&\r\n                (currentRange.collapsed ||\r\n                    (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&\r\n                        editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode))\r\n            ) {\r\n                // Handle the case for toggling between the two list types as a special case.\r\n                // We'll let the browser handle this for now.\r\n                if (\r\n                    (existingList.tagName === 'OL' &&\r\n                        command === DocumentCommand.InsertUnorderedList) ||\r\n                    (existingList.tagName === 'UL' && command === DocumentCommand.InsertOrderedList)\r\n                ) {\r\n                    editor.getDocument().execCommand(command, false, null);\r\n                } else {\r\n                    // Get the next highest list element.\r\n                    // In well formed HTML, this should just be the existing list's parent container.\r\n                    const listParent = existingList.parentElement;\r\n                    if (listParent.tagName == 'OL' || listParent.tagName == 'UL') {\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n                        existingList.insertAdjacentElement('afterend', parentLINode);\r\n                        editor.select(\r\n                            createRange(\r\n                                parentLINode,\r\n                                currentSelectionPath.start,\r\n                                currentSelectionPath.end\r\n                            )\r\n                        );\r\n                    } else {\r\n                        // In this case, we're going out to the parent root.\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n\r\n                        const wrappedContents = wrap(toArray(parentLINode.childNodes));\r\n                        const wrappedRange = createRange(\r\n                            wrappedContents,\r\n                            currentSelectionPath.start,\r\n                            currentSelectionPath.end\r\n                        );\r\n                        const wrappedSelectionPath = getSelectionPath(\r\n                            wrappedContents,\r\n                            wrappedRange\r\n                        );\r\n\r\n                        existingList.insertAdjacentElement('afterend', wrappedContents);\r\n                        editor.deleteNode(parentLINode);\r\n                        let newRange = createRange(\r\n                            wrappedContents,\r\n                            wrappedSelectionPath.start,\r\n                            wrappedSelectionPath.end\r\n                        );\r\n                        editor.select(newRange);\r\n                    }\r\n\r\n                    if (existingList.childElementCount == 0) {\r\n                        editor.deleteNode(existingList);\r\n                    }\r\n                }\r\n            } else {\r\n                editor.getDocument().execCommand(command, false, null);\r\n            }\r\n        } else {\r\n            editor.getDocument().execCommand(command, false, null);\r\n        }\r\n    } else {\r\n        editor.getDocument().execCommand(command, false, null);\r\n    }\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n    return newList;\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\nimport { IEditor, ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function experimentToggleListType(editor: IEditor, listType: ListType): void;\nexport default function experimentToggleListType(\n    editor: IEditor,\n    listType: ListType.Ordered,\n    startNumber: number\n): void;\n\nexport default function experimentToggleListType(\n    editor: IEditor,\n    listType: ListType,\n    startNumber?: number\n) {\n    blockFormat(editor, (region, start, end, chains) => {\n        const chain =\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\n        const vList =\n            chain && start.equalTo(end)\n                ? chain.createVListAtBlock(\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\n                      startNumber\n                  )\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\n\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","export * from './plugins/ContentEdit/index';\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\nimport { CursorFeatures } from './features/cursorFeatures';\nimport { EntityFeatures } from './features/entityFeatures';\nimport { ListFeatures } from './features/listFeatures';\nimport { MarkdownFeatures } from './features/markdownFeatures';\nimport { QuoteFeatures } from './features/quoteFeatures';\nimport { ShortcutFeatures } from './features/shortcutFeatures';\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\nimport { TableFeatures } from './features/tableFeatures';\nimport {\n    BuildInEditFeature,\n    ContentEditFeatureSettings,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\nconst allFeatures = {\n    ...ListFeatures,\n    ...QuoteFeatures,\n    ...TableFeatures,\n    ...StructuredNodeFeatures,\n    ...AutoLinkFeatures,\n    ...ShortcutFeatures,\n    ...CursorFeatures,\n    ...MarkdownFeatures,\n    ...EntityFeatures,\n};\n\n/**\n * Get all content edit features provided by roosterjs\n */\nexport default function getAllFeatures(): Record<\n    keyof ContentEditFeatureSettings,\n    BuildInEditFeature<PluginEvent>\n> {\n    return allFeatures;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\n\n/**\n * Get innerHTML of the given node\n * @param node The DOM node to get innerHTML from\n */\nexport default function getInnerHTML(node: HTMLElement | DocumentFragment) {\n    if (safeInstanceOf(node, 'HTMLElement')) {\n        return node.innerHTML;\n    } else if (node) {\n        const tempNode = node.ownerDocument.createElement('span');\n        tempNode.appendChild(node.cloneNode(true /*deep*/));\n        return tempNode.innerHTML;\n    } else {\n        return '';\n    }\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport { RegionBase } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A type map from selector string to HTML element type\n */\nexport interface SelectorToTypeMap {\n    ol: HTMLOListElement;\n    ul: HTMLUListElement;\n    'ol,ul': HTMLOListElement | HTMLUListElement;\n}\n\n/**\n * @internal\n * Get Root list node from the given node within the given region\n * @param region Region to scope the search inot\n * @param selector The selector to search\n * @param node The start node\n */\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\n    region: RegionBase,\n    selector: TSelector,\n    node: Node\n): SelectorToTypeMap[TSelector] {\n    let list =\n        region &&\n        (findClosestElementAncestor(\n            node,\n            region.rootNode,\n            selector\n        ) as SelectorToTypeMap[TSelector]);\n\n    if (list) {\n        let ancestor: SelectorToTypeMap[TSelector];\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                selector\n            ) as SelectorToTypeMap[TSelector])\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport fromHtml from '../utils/fromHtml';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get all block elements covered by the selection under this region\n * @param regionBase The region to get block elements from\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\n * any blocks in the region. Default value is false\n */\nexport default function getSelectedBlockElementsInRegion(\n    regionBase: RegionBase,\n    createBlockIfEmpty?: boolean\n): BlockElement[] {\n    const range = getSelectionRangeInRegion(regionBase);\n    let blocks: BlockElement[] = [];\n\n    if (range) {\n        const { rootNode, skipTags } = regionBase;\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n        for (\n            let block = traverser?.currentBlockElement;\n            !!block;\n            block = traverser.getNextBlockElement()\n        ) {\n            blocks.push(block);\n        }\n\n        // Remove unmeaningful nodes\n        blocks = blocks.filter(block => {\n            const startNode = block.getStartNode();\n            const endNode = block.getEndNode();\n\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\n                startNode.parentNode?.removeChild(startNode);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\n        const newNode = fromHtml('<div><br></div>', regionBase.rootNode.ownerDocument)[0];\n        regionBase.rootNode.appendChild(newNode);\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created acording to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child bundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ascenstor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport setStyles from '../style/setStyles';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\nimport { collapse } from '../utils/collapseNodes';\nimport { safeInstanceOf } from '..';\n\n/**\n * Merge a BlockElement of given node after another node\n * @param region Region to operate in\n * @param refNode The node to merge after\n * @param targetNode The node of target block element\n */\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\n    let block: BlockElement;\n\n    if (\n        !isNodeInRegion(region, refNode) ||\n        !isNodeInRegion(region, targetNode) ||\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\n        block.contains(refNode)\n    ) {\n        return;\n    }\n\n    const blockRoot = block.collapseToSingleElement();\n    const commonContainer = collapse(\n        region.rootNode,\n        blockRoot,\n        refNode,\n        false /*isStart*/,\n        true /*canSplitParent*/\n    );\n\n    // Copy styles of parent nodes into blockRoot\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\n        const parent = node.parentNode;\n        if (safeInstanceOf(parent, 'HTMLElement')) {\n            const styles = {\n                ...(getPredefinedCssForElement(parent) || {}),\n                ...getStyles(parent),\n                ...getStyles(blockRoot),\n            };\n            setStyles(blockRoot, styles);\n        }\n        node = parent;\n    }\n\n    let nodeToRemove: Node = null;\n    let nodeToMerge =\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\n            ? blockRoot.firstChild\n            : changeElementTag(blockRoot, 'SPAN');\n\n    // Remove empty node\n    for (\n        let node: Node = nodeToMerge;\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\n        node = node.parentNode\n    ) {\n        // If the only child is the one which is about to be removed, this node should also be removed\n        nodeToRemove = node.parentNode;\n    }\n\n    // Finally, merge blocks, and remove empty nodes\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\n\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\n    B: {\n        'font-weight': 'bold',\n    },\n    EM: {\n        'font-style': 'italic',\n    },\n    I: {\n        'font-style': 'italic',\n    },\n    U: {\n        'text-decoration': 'underline',\n    },\n    P: {\n        'margin-top': '1em',\n        'margin-bottom': '1em',\n    },\n    PRE: {\n        'white-space': 'pre',\n    },\n    S: {\n        'text-decoration': 'line-through',\n    },\n    STRIKE: {\n        'text-decoration': 'line-through',\n    },\n    SUB: {\n        'vertical-align': 'sub',\n        'font-size': 'smaller',\n    },\n    SUP: {\n        'vertical-align': 'super',\n        'font-size': 'smaller',\n    },\n};\n\n/**\n * @internal\n * Get a map for browser built-in CSS definations of elements\n */\nexport default function getPredefinedCssForElement(\n    element: HTMLElement,\n    additionalPredefinedCssForElement?: PredefinedCssMap\n): StringMap {\n    const tag = getTagOfNode(element);\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: Node, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: Node): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","const CTRL_CHARCODE = 'Control';\nconst ALT_CHARCODE = 'Alt';\nconst META_CHARCODE = 'Meta';\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport default function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Position, VListChain } from 'roosterjs-editor-dom';\n\n/**\n * Commit changes of all list changes when experiment features are allowed\n * @param editor The Editor object\n * @param chains List chains to commit\n */\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\n    if (chains?.length > 0) {\n        const range = editor.getSelectionRange();\n        const start = range && Position.getStart(range);\n        const end = range && Position.getEnd(range);\n        chains.forEach(chain => chain.commit());\n        editor.select(start, end);\n    }\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from './blockFormat';\nimport { IEditor } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Toggle a tag at selection, if selection already contains elements of such tag,\n * the elements will be untagge and other elements will take no affect\n * @param editor The editor instance\n * @param wrapFunction  The wrap function\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\n * the loop for regions will be skipped\n */\nexport default function blockWrap(\n    editor: IEditor,\n    wrapFunction: (nodes: Node[]) => void,\n    beforeRunCallback: () => boolean\n): void {\n    blockFormat(\n        editor,\n        region => {\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n            let nodes = collapseNodesInRegion(region, blocks);\n            if (nodes.length > 0) {\n                if (nodes.length == 1) {\n                    const NodeTag = getTagOfNode(nodes[0]);\n                    if (NodeTag == 'BR') {\n                        nodes = [wrap(nodes[0])];\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\n                        nodes = toArray(nodes[0].childNodes);\n                    }\n                }\n\n                while (\n                    nodes[0] &&\n                    isNodeInRegion(region, nodes[0].parentNode) &&\n                    nodes.some(node => getTagOfNode(node) == 'LI')\n                ) {\n                    nodes = [splitBalancedNodeRange(nodes)];\n                }\n\n                wrapFunction(nodes);\n            }\n        },\n        beforeRunCallback\n    );\n}\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The EditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = (core: EditorCore) => {\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\n    return (\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\n    );\n};\n","export * from './plugins/HyperLink/index';\n","export * from './plugins/Paste/index';\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface WordCustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty WordCustomData\n */\nexport function createCustomData(): WordCustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!wordCustomData.dict[id]) {\n                // First time dictionary creation\n                wordCustomData.dict[id] = {};\n            }\n            wordCustomData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = wordCustomData.nextNodeId.toString();\n        wordCustomData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\nexport { default as getAllFeatures } from './getAllFeatures';\n","import getAllFeatures from './getAllFeatures';\nimport {\n    ContentEditFeatureSettings,\n    EditorPlugin,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    /**\n     * Create instance of ContentEdit plugin\n     * @param settingsOverride An optional feature set to override default feature settings\n     * @param additionalFeatures Optional. More features to add\n     */\n    constructor(\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor): void {\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\n        const allFeatures = getAllFeatures();\n\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\n            const feature = allFeatures[key];\n            const hasSettingForKey =\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\n\n            if (\n                (hasSettingForKey && this.settingsOverride[key]) ||\n                (!hasSettingForKey && !feature.defaultDisabled)\n            ) {\n                features.push(feature);\n            }\n        });\n\n        features\n            .concat(this.additionalFeatures || [])\n            .forEach(feature => editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose(): void {}\n}\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    AutoLinkFeatureSettings,\n    BuildInEditFeature,\n    ChangeSource,\n    ClipboardData,\n    IEditor,\n    Keys,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    clearEventDataCache,\n    LinkInlineElement,\n    matchLink,\n} from 'roosterjs-editor-dom';\n\n/**\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\n * we need to trim off the trailing puncatuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = editor.getContentSearcherOfCursor(event);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: IEditor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(editor => {\n        editor.addUndoSnapshot(\n            () => {\n                replaceWithNode(\n                    editor,\n                    linkData.originalUrl,\n                    anchor,\n                    false /* exactMatch */,\n                    searcher\n                );\n\n                // The content at cursor has changed. Should also clear the cursor data cache\n                clearEventDataCache(event);\n                return anchor;\n            },\n            ChangeSource.AutoLink,\n            true /*canUndoByBackspace*/\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const AutoLinkFeatures: Record<\n    keyof AutoLinkFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoLink: AutoLink,\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n};\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DarkModeDatasetNames, DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            elementStyle.color =\r\n                (isDarkMode ? textColors?.darkModeColor : textColors?.lightModeColor) || textColor;\r\n\r\n            if (textColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] =\r\n                    textColors.lightModeColor;\r\n            }\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            elementStyle.backgroundColor =\r\n                (isDarkMode ? backgroundColors?.darkModeColor : backgroundColors?.lightModeColor) ||\r\n                backgroundColor;\r\n\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    backgroundColors.lightModeColor;\r\n            }\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport {\r\n    ClipboardData,\r\n    EdgeLinkPreview,\r\n    ExtractClipboardEventOption,\r\n} from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardData) => void,\r\n    options?: ExtractClipboardEventOption\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardData = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        rawHtml: undefined,\r\n    };\r\n\r\n    const handlers: {\r\n        promise: Promise<string>;\r\n        callback: (value: string) => void;\r\n    }[] = [];\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n\r\n        // Set rawHtml to null so that caller knows that we have tried\r\n        result.rawHtml = null;\r\n        const items = event.clipboardData.items;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n\r\n            switch (item.type) {\r\n                case 'text/html':\r\n                    handlers.push({\r\n                        promise: getAsString(item),\r\n                        callback: value => {\r\n                            result.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value;\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'text/link-preview':\r\n                    if (options?.allowLinkPreview) {\r\n                        handlers.push({\r\n                            promise: getAsString(item),\r\n                            callback: value => {\r\n                                try {\r\n                                    result.linkPreview = JSON.parse(value) as EdgeLinkPreview;\r\n                                } catch {}\r\n                            },\r\n                        });\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Promise.all(handlers.map(handler => handler.promise)).then(values => {\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            handlers[i].callback(values[i]);\r\n        }\r\n\r\n        callback(result);\r\n    });\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n\r\nfunction getAsString(item: DataTransferItem): Promise<string> {\r\n    return new Promise<string>(resolve => {\r\n        item.getAsString(value => {\r\n            resolve(value);\r\n        });\r\n    });\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\n    if (file && callback) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represnets list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(private node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): Node {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is an orphan item.\n     *\n     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag\n     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.\n     *\n     * For example:\n     * ```html\n     * <ol>\n     *   <div>Orphan node</div>\n     *   <li>first item</li>\n     * </ol>\n     * ```\n     * Here the first DIV tag is an orphan item.\n     *\n     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be\n     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,\n     * those nodes will be merged into LI, so that ideally here they should not exist.\n     */\n    isOrphanItem(): boolean {\n        return getTagOfNode(this.node) != 'LI';\n    }\n\n    /**\n     * Check if the given item can be merged into this item.\n     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.\n     * @param item The item to check\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * Merge items into this item.\n     * @example Before merge:\n     * ```html\n     * <ol>\n     *   <li>Current item</li>\n     *   <div>line 1</div>\n     *   <div>line 2</div>\n     * </ol>\n     * ```\n     * After merge then two DIVs into LI:\n     * ```html\n     * <ol>\n     *   <li>Current item\n     *     <div>line 1</div>\n     *     <div>line 2</div>\n     *   </li>\n     * </ol>\n     * ```\n     * @param items The items to merge\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     */\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            while (originalRoot.firstChild) {\n                originalRoot.removeChild(originalRoot.firstChild);\n            }\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import fromHtml from '../utils/fromHtml';\nimport getRootListNode from './getRootListNode';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport Position from '../selection/Position';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport toArray from '../utils/toArray';\nimport VList from './VList';\nimport wrap from '../utils/wrap';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { ListType, Region } from 'roosterjs-editor-types';\nimport { PositionType } from 'roosterjs-editor-types';\n\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, ListSelector, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n                if (\n                    nodes.length == 1 &&\n                    safeInstanceOf(list, 'HTMLOListElement') &&\n                    list.start > 1\n                ) {\n                    // Do not include sibling lists if this list is not start from 1\n                    includeSiblingLists = false;\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\n            const newNode = fromHtml('<div><br></div>', region.rootNode.ownerDocument)[0];\n            region.rootNode.appendChild(newNode);\n            nodes.push(newNode);\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\n        }\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, ListSelector, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\n                // Only include sibling list when\n                // 1. This is a unordered list, OR\n                // 2. This list starts from 1\n                nodes.push(node);\n            }\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Wrap all child nodes under a single one, and put the new list under original root node\n    // so that the list can carry over styles under the root node.\n    const childNodes = toArray(node.childNodes);\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\n\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.appendChild(listNode);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(nodeForItem, ListType.None);\n\n    return vList;\n}\n","import arrayPush from '../utils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList {\n        if (container) {\n            const list = container.ownerDocument.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     */\n    commit() {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n            list.start = lastNumber + 1;\n\n            const vlist = new VList(list);\n\n            lastNumber = vlist.getLastItemNumber();\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack();\n        }\n    }\n\n    /**\n     * Contruct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber();\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getInnerHTML from '../utils/getInnerHTML';\nimport getSelectionPath from './getSelectionPath';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport queryElements from '../utils/queryElements';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(\n    rootNode: HTMLElement | DocumentFragment,\n    range: Range\n): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\n    let isDOMChanged = false;\n\n    queryElements(rootNode, 'table', table => {\n        let tbody: HTMLTableSectionElement = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            if (getTagOfNode(child) == 'TR') {\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n\n                isDOMChanged = true;\n            } else {\n                tbody = null;\n            }\n        }\n    });\n\n    if (range && isDOMChanged) {\n        try {\n            range.setStart(startContainer, startOffset);\n            range.setEnd(endContainer, endOffset);\n        } catch {}\n    }\n\n    const content = getInnerHTML(rootNode);\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\n\n/**\n * Add the given range into selection of the given document\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\n * otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\n    if (selection) {\n        let needAddRange = true;\n\n        if (selection.rangeCount > 0) {\n            // Workaround IE exception 800a025e\n            try {\n                let currentRange: Range;\n                // Do not remove/add range if current selection is the same with target range\n                // Without this check, execCommand() may fail in Edge since we changed the selection\n                if (\n                    (skipSameRange || Browser.isEdge) &&\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\n                    currentRange.startContainer == range.startContainer &&\n                    currentRange.startOffset == range.startOffset &&\n                    currentRange.endContainer == range.endContainer &&\n                    currentRange.endOffset == range.endOffset\n                ) {\n                    needAddRange = false;\n                } else {\n                    selection.removeAllRanges();\n                }\n            } catch (e) {}\n        }\n\n        if (needAddRange) {\n            selection.addRange(range);\n        }\n    }\n}\n","import arrayPush from '../utils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from './Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new positon to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\n    let nodeBefore: Node = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detecte them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes =>\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\n    );\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node = node.childNodes[offset - 1];\n        let nodeAfter: Node = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument.createTextNode('');\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore, nodeAfter];\n    }\n}\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        snapshots.autoCompleteIndex = -1;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Whether there is a snapshot added before auto complete and it can be undone now\n */\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\n    return (\n        snapshots.autoCompleteIndex >= 0 &&\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\n    );\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getInheritableStyles from './getInheritableStyles';\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setStyles from '../style/setStyles';\nimport toArray from '../utils/toArray';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedAttributes,\n    getAllowedCssClassesRegex,\n    getTagReplacement,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n} from './getAllowedValues';\nimport {\n    AttributeCallbackMap,\n    CssStyleCallbackMap,\n    ElementCallbackMap,\n    HtmlSanitizerOptions,\n    NodeType,\n    PredefinedCssMap,\n    SanitizeHtmlOptions,\n    StringMap,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two featuers:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: CssStyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private tagReplacements: Record<string, string>;\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalPredefinedCssForElement: PredefinedCssMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private unknownTagReplacement: string;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.unknownTagReplacement = options.unknownTagReplacement;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html || '', 'text/html');\n\n        if (doc && doc.body && doc.body.firstChild) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n\n        let shouldKeep = false;\n\n        if (isElement) {\n            const tag = getTagOfNode(node);\n            const callback = this.elementCallbacks[tag];\n            let replacement = this.tagReplacements[tag.toLowerCase()];\n\n            if (replacement === undefined) {\n                replacement = this.unknownTagReplacement;\n            }\n\n            if (callback) {\n                shouldKeep = callback(node as HTMLElement, context);\n            } else if (tag.indexOf(':') > 0) {\n                shouldKeep = true;\n            } else if (tag == replacement || replacement == '*') {\n                shouldKeep = true;\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\n                node = changeElementTag(node as HTMLElement, replacement);\n                shouldKeep = true;\n            }\n        } else if (isText) {\n            const whiteSpace = currentStyle['white-space'];\n            shouldKeep =\n                whiteSpace == 'pre' ||\n                whiteSpace == 'pre-line' ||\n                whiteSpace == 'pre-wrap' ||\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\n        } else if (isFragment) {\n            shouldKeep = true;\n        } else {\n            shouldKeep = false;\n        }\n\n        if (!shouldKeep) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            let element = <HTMLElement>node;\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.preprocessCss(element, thisStyle);\n                this.processCss(element, thisStyle, context);\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\n        const predefinedStyles = getPredefinedCssForElement(\n            element,\n            this.additionalPredefinedCssForElement\n        );\n        if (predefinedStyles) {\n            Object.keys(predefinedStyles).forEach(name => {\n                thisStyle[name] = predefinedStyles[name];\n            });\n        }\n    }\n\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\n        const styles = getStyles(element);\n        Object.keys(styles).forEach(name => {\n            const value = styles[name];\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, thisStyle, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n\n            if (!keep) {\n                delete styles[name];\n            }\n        });\n\n        setStyles(element, styles);\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n}\n","import { cloneObject } from './cloneObject';\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\n\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\n    // Allowed tags\n    a: '*',\n    abbr: '*',\n    address: '*',\n    area: '*',\n    article: '*',\n    aside: '*',\n    b: '*',\n    bdi: '*',\n    bdo: '*',\n    blockquote: '*',\n    body: '*',\n    br: '*',\n    button: '*',\n    canvas: '*',\n    caption: '*',\n    center: '*',\n    cite: '*',\n    code: '*',\n    col: '*',\n    colgroup: '*',\n    data: '*',\n    datalist: '*',\n    dd: '*',\n    del: '*',\n    details: '*',\n    dfn: '*',\n    dialog: '*',\n    dir: '*',\n    div: '*',\n    dl: '*',\n    dt: '*',\n    em: '*',\n    fieldset: '*',\n    figcaption: '*',\n    figure: '*',\n    font: '*',\n    footer: '*',\n    h1: '*',\n    h2: '*',\n    h3: '*',\n    h4: '*',\n    h5: '*',\n    h6: '*',\n    head: '*',\n    header: '*',\n    hgroup: '*',\n    hr: '*',\n    html: '*',\n    i: '*',\n    img: '*',\n    input: '*',\n    ins: '*',\n    kbd: '*',\n    label: '*',\n    legend: '*',\n    li: '*',\n    main: '*',\n    map: '*',\n    mark: '*',\n    menu: '*',\n    menuitem: '*',\n    meter: '*',\n    nav: '*',\n    ol: '*',\n    optgroup: '*',\n    option: '*',\n    output: '*',\n    p: '*',\n    picture: '*',\n    pre: '*',\n    progress: '*',\n    q: '*',\n    rp: '*',\n    rt: '*',\n    ruby: '*',\n    s: '*',\n    samp: '*',\n    section: '*',\n    select: '*',\n    small: '*',\n    span: '*',\n    strike: '*',\n    strong: '*',\n    sub: '*',\n    summary: '*',\n    sup: '*',\n    table: '*',\n    tbody: '*',\n    td: '*',\n    template: '*',\n    textarea: '*',\n    tfoot: '*',\n    th: '*',\n    thead: '*',\n    time: '*',\n    tr: '*',\n    tt: '*',\n    u: '*',\n    ul: '*',\n    var: '*',\n    wbr: '*',\n    xmp: '*',\n\n    // Replaced tags:\n    form: 'SPAN',\n\n    // Disallowed tags\n    applet: null,\n    audio: null,\n    base: null,\n    basefont: null,\n    embed: null,\n    frame: null,\n    frameset: null,\n    iframe: null,\n    link: null,\n    meta: null,\n    noscript: null,\n    object: null,\n    param: null,\n    script: null,\n    slot: null,\n    source: null,\n    style: null,\n    title: null,\n    track: null,\n    video: null,\n};\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getTagReplacement(\n    additionalReplacements: Record<string, string>\n): Record<string, string> {\n    const result = { ...HTML_TAG_REPLACEMENT };\n    const replacements = additionalReplacements || {};\n    Object.keys(replacements).forEach(key => {\n        if (key) {\n            result[key.toLowerCase()] = replacements[key];\n        }\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        cssStyleCallbacks: {},\n        additionalTagReplacements: {},\n        additionalAllowedAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        additionalPredefinedCssForElement: {},\n        unknownTagReplacement: null,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<T extends any[], R>(\n    map: Record<string, (...args: T) => R>,\n    name: string,\n    newCallback: (...args: T) => R\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: T) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE = 'contenteditable';\n\n/**\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\n * @param wrapper The entity wrapper element\n * @param type Entity type\n * @param isReadonly Whether this is a readonly entity\n * @param id Optional Id of the entity\n */\nexport default function commitEntity(\n    wrapper: HTMLElement,\n    type: string,\n    isReadonly: boolean,\n    id?: string\n) {\n    if (wrapper) {\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\n            EntityClasses.ENTITY_TYPE_PREFIX\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\n            EntityClasses.ENTITY_READONLY_PREFIX\n        }${isReadonly ? '1' : '0'}`;\n\n        if (isReadonly) {\n            wrapper.contentEditable = 'false';\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\n            wrapper.removeAttribute(CONTENT_EDITABLE);\n        }\n    }\n}\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    element?.className?.split(' ').forEach(name => {\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\n            isEntity = true;\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\n        }\n    });\n\n    return isEntity\n        ? {\n              wrapper: element,\n              id,\n              type,\n              isReadonly,\n          }\n        : null;\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport default function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\n    let result =\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter();\n    if (event) {\n        event.eventDataCache = event.eventDataCache || {};\n        event.eventDataCache[key] = result;\n    }\n\n    return result;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Clear a cached object by its key from an event object\n * @param event The event object\n * @param key The cache key\n */\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\n    if (event && event.eventDataCache) {\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\n            delete event.eventDataCache[key];\n        } else if (!key) {\n            event.eventDataCache = {};\n        }\n    }\n}\n","import isModifierKey from './isModifierKey';\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && event.key && event.key.length == 1;\n}\n","import { Browser } from '../utils/Browser';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import blockFormat from '../utils/blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    IEditor,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n        });\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Rotate an element visually\n * @param editor The editor instance\n * @param element The element that should be rotated\n * @param angle The degree at which to rotate the element from it's center\n */\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\n    if (element) {\n        editor.addUndoSnapshot(() => {\n            element.style.transform = `rotate(${angle}deg)`;\n        }, ChangeSource.Format);\n    }\n}\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import experimentSetIndentation from '../experiment/experimentSetIndentation';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    Indentation,\r\n    QueryScope,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewIndentation)) {\r\n        experimentSetIndentation(editor, indentation);\r\n    } else {\r\n        let command: DocumentCommand.Indent | DocumentCommand.Outdent =\r\n            indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n        editor.addUndoSnapshot(() => {\r\n            editor.focus();\r\n            let listNode = editor.getElementAtCursor('OL,UL');\r\n            let newNode: Node;\r\n\r\n            if (listNode) {\r\n                // There is already list node, setIndentation() will increase/decrease the list level,\r\n                // so we need to process the list when change indentation\r\n                newNode = processList(editor, command);\r\n            } else {\r\n                // No existing list node, browser will create <Blockquote> node for indentation.\r\n                // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n                editor.getDocument().execCommand(command, false, null);\r\n                editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                    newNode = newNode || node;\r\n                    node.style.marginTop = '0px';\r\n                    node.style.marginBottom = '0px';\r\n                });\r\n            }\r\n\r\n            return newNode;\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { BlockElement, IEditor, Indentation, RegionBase } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    createVListFromRegion,\n    findClosestElementAncestor,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\n\n/**\n * @internal\n */\nexport default function experimentSetIndentation(editor: IEditor, indentation: Indentation) {\n    const handler = indentation == Indentation.Increase ? indent : outdent;\n\n    blockFormat(editor, (region, start, end) => {\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n        const blockGroups: BlockElement[][] = [[]];\n\n        for (let i = 0; i < blocks.length; i++) {\n            const startNode = blocks[i].getStartNode();\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\n\n            if (vList) {\n                blockGroups.push([]);\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\n                    i++;\n                }\n                vList.setIndentation(start, end, indentation);\n                vList.writeBack();\n            } else {\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\n            }\n        }\n\n        blockGroups.forEach(group => handler(region, group));\n    });\n}\n\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\n    const nodes = collapseNodesInRegion(region, blocks);\n    wrap(nodes, BlockWrapper);\n}\n\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\n    blocks.forEach(blockElement => {\n        let node = blockElement.collapseToSingleElement();\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\n        if (quote) {\n            if (node == quote) {\n                node = wrap(toArray(node.childNodes));\n            }\n\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\n                node = splitBalancedNodeRange(node);\n            }\n\n            if (isNodeInRegion(region, node)) {\n                unwrap(node);\n            }\n        }\n    });\n}\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\nimport applyInlineStyle from '../utils/applyInlineStyle';\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environment’s current locale.\n */\nexport default function changeCapitalization(\n    editor: IEditor,\n    capitalization: Capitalization,\n    language?: string\n) {\n    applyInlineStyle(editor, element => {\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\n            if (node.nodeType == NodeType.Text) {\n                try {\n                    node.textContent = getCapitalizedText(node.textContent, language);\n                } catch {\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\n                }\n            }\n        }\n    });\n\n    function getCapitalizedText(originalText: string, language: string): string {\n        switch (capitalization) {\n            case Capitalization.Lowercase:\n                return originalText.toLocaleLowerCase(language);\n            case Capitalization.Uppercase:\n                return originalText.toLocaleUpperCase(language);\n            case Capitalization.CapitalizeEachWord:\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\n                for (let i = 0; i < wordArray.length; i++) {\n                    wordArray[i] =\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\n                }\n                return wordArray.join(' ');\n            case Capitalization.Sentence:\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                // Find a match of a word character either:\n                // - At the beginning of a string with or without preceding whitespace, for\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\n                // - Or preceded by a punctuation mark and at least one whitespace, for\n                // example 'yes. hello world' would match 'y' and 'h'.\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\n                    return match.toLocaleUpperCase(language);\n                });\n        }\n    }\n}\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    ListType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewBullet)) {\r\n        experimentToggleListType(editor, ListType.Unordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    ListType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: IEditor) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewNumbering)) {\r\n        experimentToggleListType(editor, ListType.Ordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertOrderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    CursorFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: !Browser.isChrome,\n};\n\n/**\n * @internal\n */\nexport const CursorFeatures: Record<\n    keyof CursorFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    noCycleCursorMove: NoCycleCursorMove,\n};\n","import {\n    cacheGetEventData,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    EntityFeatureSettings,\n    EntityOperation,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    operation?: EntityOperation\n) {\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const node = event.rawEvent.target as Node;\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromEnd\n        );\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromStart\n        );\n    },\n};\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    operation?: EntityOperation\n): HTMLElement {\n    const element = cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range).normalize();\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\n            let entityNode: HTMLElement = null;\n\n            if (isAtBeginOrEnd) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = isNext\n                    ? pos.offset == 0\n                        ? traverser.currentInlineElement\n                        : traverser.getNextInlineElement()\n                    : pos.isAtEnd\n                    ? traverser.currentInlineElement\n                    : traverser.getPreviousInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (!collapseOnly) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\n            }\n\n            return entityNode;\n        }\n    );\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * @internal\n */\nexport const EntityFeatures: Record<\n    keyof EntityFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    clickOnEntity: ClickOnEntityFeature,\n    escapeFromEntity: EscapeFromEntityFeature,\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\n};\n","import experimentToggleListType from 'roosterjs-editor-api/lib/experiment/experimentToggleListType';\nimport {\n    experimentCommitListChains,\n    setIndentation,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\nimport {\n    Browser,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n    VListChain,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Indentation,\n    ListFeatureSettings,\n    Keys,\n    NodeType,\n    PluginKeyboardEvent,\n    PositionType,\n    ListType,\n    QueryScope,\n    RegionBase,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        let range = editor.getSelectionRange();\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li.previousSibling) {\n            const chains = getListChains(editor);\n            editor.runAsync(editor => {\n                let br = editor.getDocument().createElement('BR');\n                editor.insertNode(br);\n                editor.select(br, PositionType.After);\n                experimentCommitListChains(editor, chains);\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n    defaultDisabled: true,\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.addUndoSnapshot(\n            () => toggleListAndPreventDefault(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\n};\n\n/**\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = editor.getContentSearcherOfCursor(event);\n            let textBeforeCursor = searcher.getSubStringBefore(4);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return (\n                /^(\\*|-|[0-9]{1,2}\\.)$/.test(textBeforeCursor) &&\n                !searcher.getNearestNonTextInlineElement()\n            );\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.runAsync(editor => {\n            editor.addUndoSnapshot(\n                () => {\n                    let regions: RegionBase[];\n                    let searcher = editor.getContentSearcherOfCursor();\n                    let textBeforeCursor = searcher.getSubStringBefore(4);\n                    let rangeToDelete = searcher.getRangeFromText(\n                        textBeforeCursor,\n                        true /*exactMatch*/\n                    );\n\n                    if (!rangeToDelete) {\n                        // no op if the range can't be found\n                    } else if (\n                        textBeforeCursor.indexOf('*') == 0 ||\n                        textBeforeCursor.indexOf('-') == 0\n                    ) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleBullet(editor);\n                    } else if (textBeforeCursor.indexOf('1.') == 0) {\n                        prepareAutoBullet(editor, rangeToDelete);\n                        toggleNumbering(editor);\n                    } else if (\n                        editor.isFeatureEnabled(ExperimentalFeatures.ListChain) &&\n                        (regions = editor.getSelectedRegions()) &&\n                        regions.length == 1\n                    ) {\n                        const num = parseInt(textBeforeCursor);\n                        prepareAutoBullet(editor, rangeToDelete);\n                        experimentToggleListType(editor, ListType.Ordered, num);\n                    }\n                },\n                null /*changeSource*/,\n                true /*canUndoByBackspace*/\n            );\n        });\n    },\n};\n\n/**\n * Maintain the list numbers in list chain\n * e.g. we have two lists:\n * 1, 2, 3 and 4, 5, 6\n * Now we delete list item 2, so the first one becomes \"1, 2\".\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\n */\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\n    shouldHandleEvent: (event, editor) =>\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\nfunction getListChains(editor: IEditor) {\n    return editor.isFeatureEnabled(ExperimentalFeatures.ListChain)\n        ? VListChain.createListChains(editor.getSelectedRegions())\n        : [];\n}\n\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\n    range.deleteContents();\n    const node = range.startContainer;\n    if (node?.nodeType == NodeType.Text && node.nodeValue == '' && !node.nextSibling) {\n        const br = editor.getDocument().createElement('BR');\n        editor.insertNode(br);\n        editor.select(br, PositionType.Before);\n    }\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n\n/**\n * @internal\n */\nexport const ListFeatures: Record<\n    keyof ListFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoBullet: AutoBullet,\n    indentWhenTab: IndentWhenTab,\n    outdentWhenShiftTab: OutdentWhenShiftTab,\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n    maintainListChain: MaintainListChain,\n};\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    ChangeSource,\n    IEditor,\n    Keys,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceeding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!!range) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                // set the removal range to include the typed last character.\n                range.setEnd(range.endContainer, range.endOffset + 1);\n\n                // extract content and put it into a new element.\n                const elementToWrap = editor.getDocument().createElement(elementTag);\n                elementToWrap.appendChild(textContentRange.extractContents());\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Bolds text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Italicises text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\n */\nconst MarkdownStrikethru: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethru,\n    markdownInlineCode: MarkdownInlineCode,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    QuoteFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) =>\n        editor.addUndoSnapshot(\n            () => splitQuote(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        ),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n\n/**\n * @internal\n */\nexport const QuoteFeatures: Record<\n    keyof QuoteFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n};\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    FontSizeChange,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ShortcutFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: IEditor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n\n/**\n * @internal\n */\nexport const ShortcutFeatures: Record<\n    keyof ShortcutFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    defaultShortcut: DefaultShortcut,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    StructuredNodeFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    fromHtml,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n// Edge can sometimes lose current format when Enter to new line.\n// So here we add an extra SPAN for Edge to workaround this bug\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n\n/**\n * @internal\n */\nexport const StructuredNodeFeatures: Record<\n    keyof StructuredNodeFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n};\n","import { editTable } from 'roosterjs-editor-api';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    NodeType,\n    PluginEvent,\n    PositionType,\n    TableFeatureSettings,\n    TableOperation,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    contains,\n    getTagOfNode,\n    isVoidHtmlElement,\n    Position,\n    VTable,\n} from 'roosterjs-editor-dom';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0) {\n                    editor.select(vtable.table, PositionType.Before);\n                    break;\n                } else if (row >= vtable.cells.length) {\n                    editTable(editor, TableOperation.InsertBelow);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        const td = cacheGetTableCell(event, editor);\n        const vtable = new VTable(td);\n        const isUp = event.rawEvent.which == Keys.UP;\n        const step = isUp ? -1 : 1;\n        const hasShiftKey = event.rawEvent.shiftKey;\n        const selection = editor.getDocument().defaultView?.getSelection();\n        let targetTd: HTMLTableCellElement = null;\n\n        if (selection) {\n            let { anchorNode, anchorOffset } = selection;\n\n            for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n                let cell = vtable.getCell(row, vtable.col);\n                if (cell.td && cell.td != td) {\n                    targetTd = cell.td;\n                    break;\n                }\n            }\n\n            editor.runAsync(editor => {\n                let newContainer = editor.getElementAtCursor();\n                if (\n                    contains(vtable.table, newContainer) &&\n                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n                ) {\n                    let newPos = targetTd\n                        ? new Position(targetTd, PositionType.Begin)\n                        : new Position(\n                              vtable.table,\n                              isUp ? PositionType.Before : PositionType.After\n                          );\n                    if (hasShiftKey) {\n                        newPos =\n                            newPos.node.nodeType == NodeType.Element &&\n                            isVoidHtmlElement(newPos.node)\n                                ? new Position(\n                                      newPos.node,\n                                      newPos.isAtEnd ? PositionType.After : PositionType.Before\n                                  )\n                                : newPos;\n                        const selection = editor.getDocument().defaultView?.getSelection();\n                        selection?.setBaseAndExtent(\n                            anchorNode,\n                            anchorOffset,\n                            newPos.node,\n                            newPos.offset\n                        );\n                    } else {\n                        editor.select(newPos);\n                    }\n                }\n            });\n        }\n    },\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const TableFeatures: Record<\n    keyof TableFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    tabInTable: TabInTable,\n    upDownInTable: UpDownInTable,\n};\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            let allNodes = fromHtml(content, doc);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView?.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Make the editor in \"Shadow Edit\" mode.\r\n     * In Shadow Edit mode, all format change will finally be ignored.\r\n     * This can be used for building a live preview feature for format button, to allow user\r\n     * see format result without really apply it.\r\n     * This function can be called repeatly. If editor is already in shadow edit mode, we can still\r\n     * use this function to do more shadow edit operation.\r\n     */\r\n    public startShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, true /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\r\n     */\r\n    public stopShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, false /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in Shadow Edit mode\r\n     */\r\n    public isInShadowEdit() {\r\n        return !!this.core.lifecycle.shadowEditFragment;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { CoreApiMap } from 'roosterjs-editor-types';\nimport { createPasteFragment } from './createPasteFragment';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { focus } from './focus';\nimport { getContent } from './getContent';\nimport { getSelectionRange } from './getSelectionRange';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { hasFocus } from './hasFocus';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { selectRange } from './selectRange';\nimport { setContent } from './setContent';\nimport { switchShadowEdit } from './switchShadowEdit';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\n\n/**\n * @internal\n */\nexport const coreApiMap: CoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    createPasteFragment,\n    ensureTypeInContainer,\n    focus,\n    getContent,\n    getSelectionRange,\n    getStyleBasedFormatState,\n    hasFocus,\n    insertNode,\n    restoreUndoSnapshot,\n    selectRange,\n    setContent,\n    switchShadowEdit,\n    transformColor,\n    triggerEvent,\n};\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    AddUndoSnapshot,\n    ChangeSource,\n    ContentChangedEvent,\n    EditorCore,\n    NodePosition,\n    PluginEventType,\n    GetContentMode,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The EditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core: EditorCore,\n    callback: (start: NodePosition, end: NodePosition) => any,\n    changeSource: ChangeSource | string,\n    canUndoByBackspace: boolean\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    const isShadowEdit = !!core.lifecycle.shadowEditFragment;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        if (!isShadowEdit) {\n            undoState.snapshotsService.addSnapshot(\n                core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                canUndoByBackspace\n            );\n            undoState.hasNewContent = false;\n        }\n    }\n\n    try {\n        if (callback) {\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested && !isShadowEdit) {\n                undoState.snapshotsService.addSnapshot(\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                    false /*isAutoCompleteSnapshot*/\n                );\n                undoState.hasNewContent = false;\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        let event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\n\n        if (range) {\n            core.undo.hasNewContent = false;\n            core.undo.autoCompletePosition = Position.getStart(range);\n        }\n    }\n};\n","import {\n    AttachDomEvent,\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    EditorCore,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (\n    core: EditorCore,\n    eventMap: Record<string, DOMEventHandler>\n) => {\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\n        let onEvent = (event: UIEvent) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n        core.contentDiv.addEventListener(eventName, onEvent);\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    CreatePasteFragment,\n    EditorCore,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\n/**\n * @internal\n * Create a DocumentFragment for paste from a ClipboardData\n * @param core The EditorCore object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param position The position to paste to\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n * false to keep original foramt\n */\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    if (!clipboardData) {\n        return null;\n    }\n\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData);\n    const { fragment, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const document = core.contentDiv.ownerDocument;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (!pasteAsText && !text && imageDataUri) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        !pasteAsText &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\n    ) {\n        // Paste HTML\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\n                startIndex + START_FRAGMENT.length,\n                endIndex\n            );\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        while (doc.body.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        // Paste text\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n\n            const node = line == '' ? document.createElement('br') : document.createTextNode(line);\n\n            fragment.appendChild(index == 0 || index == lines.length - 1 ? node : wrap(node));\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedForamt.fontName,\n        fontSize: styleBasedForamt.fontSize,\n        textColor: styleBasedForamt.textColor,\n        backgroundColor: styleBasedForamt.backgroundColor,\n        textColors: styleBasedForamt.textColors,\n        backgroundColors: styleBasedForamt.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    toArray(node.querySelectorAll('style')).forEach(callback);\n}\n","import {\n    ContentPosition,\n    EditorCore,\n    EnsureTypeInContainer,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    applyFormat,\n    Browser,\n    createRange,\n    fromHtml,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\n    core: EditorCore,\n    position: NodePosition,\n    keyboardEvent?: KeyboardEvent\n) => {\n    position = position.normalize();\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = fromHtml(\n            Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\n            core.contentDiv.ownerDocument\n        )[0] as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode.firstChild, PositionType.Begin);\n    }\n\n    if (formatNode) {\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.selectRange(core, createRange(position));\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = (core: EditorCore) => {\n    if (!core.lifecycle.shadowEditFragment) {\n        if (\n            !core.api.hasFocus(core) ||\n            !core.api.getSelectionRange(core, false /*tryGetFromCache*/)\n        ) {\n            // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\n            // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\n            // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\n            // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\n            // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\n            // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\n            // It should be better than the case you cannot type\n            if (\n                !core.domEvent.selectionRange ||\n                !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\n            ) {\n                let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\n                core.api.selectRange(\n                    core,\n                    createRange(node, PositionType.Begin),\n                    true /*skipSameRange*/\n                );\n            }\n        }\n\n        // remember to clear cached selection range\n        core.domEvent.selectionRange = null;\n\n        // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import {\n    ColorTransformDirection,\n    EditorCore,\n    GetContent,\n    GetContentMode,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The EditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\n    let content = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommited shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\n        const clonedRoot = cloneNode(root);\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n        const path = !includeSelectionMarker\n            ? null\n            : core.lifecycle.shadowEditFragment\n            ? core.lifecycle.shadowEditSelectionPath\n            : originalRange\n            ? getSelectionPath(core.contentDiv, originalRange)\n            : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        if (core.lifecycle.isDarkMode) {\n            core.api.transformColor(\n                core,\n                clonedRoot,\n                false /*includeSelf*/,\n                null /*callback*/,\n                ColorTransformDirection.DarkToLight\n            );\n        }\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    } else {\n        content = getHtmlWithSelectionPath(\n            root,\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\n        );\n    }\n\n    return content;\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, createRange } from 'roosterjs-editor-dom';\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get current or cached selection range\n * @param core The EditorCore object\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\n * @returns A Range object of the selection range\n */\nexport const getSelectionRange: GetSelectionRange = (\n    core: EditorCore,\n    tryGetFromCache: boolean\n) => {\n    let result: Range = null;\n\n    if (core.lifecycle.shadowEditFragment) {\n        result =\n            core.lifecycle.shadowEditSelectionPath &&\n            createRange(\n                core.contentDiv,\n                core.lifecycle.shadowEditSelectionPath.start,\n                core.lifecycle.shadowEditSelectionPath.end\n            );\n\n        return result;\n    } else {\n        if (!tryGetFromCache || core.api.hasFocus(core)) {\n            let selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                let range = selection.getRangeAt(0);\n                if (contains(core.contentDiv, range)) {\n                    result = range;\n                }\n            }\n        }\n\n        if (!result && tryGetFromCache) {\n            result = core.domEvent.selectionRange;\n        }\n\n        return result;\n    }\n};\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.lifecycle.isDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor:\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\n                      ] ||\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\n                      ],\n              }\n            : undefined,\n    };\n};\n","import {\n    BlockElement,\n    ContentPosition,\n    ColorTransformDirection,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodeType,\n    NodePosition,\n    PositionType,\n    QueryScope,\n} from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    contains,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    getTagOfNode,\n    isBlockElement,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    isVoidHtmlElement,\n    Position,\n    queryElements,\n    safeInstanceOf,\n    splitBalancedNodeRange,\n    splitTextNode,\n    toArray,\n    unwrap,\n    VTable,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range; rangeToRestore: Range } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n    };\n    let contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    let isBegin = option.position == ContentPosition.Begin;\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[];\n                    if (block) {\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    let insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos = Position.getStart(range);\n                    let blockElement: BlockElement;\n\n                    if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\n                    } else {\n                        adjustSteps.forEach(handler => {\n                            pos = handler(contentDiv, node, pos);\n                        });\n                    }\n\n                    let nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n                    range = createRange(pos);\n                    range.insertNode(node);\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n                    core.api.selectRange(core, rangeToRestore);\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n\nfunction handleHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter(a => blockElement.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\n        ) {\n            let normalizedPosition = position.normalize();\n            let parentNode = normalizedPosition.node.parentNode;\n            let nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            position = new Position(splitter, PositionType.Before);\n            safeRemove(splitter);\n        }\n    }\n\n    return position;\n}\n\nfunction handleStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    let rootNodeToInsert = nodeToInsert;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\n    }\n\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem,\n                isPositionAtBeginningOf(position, listItem)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    } else if (tag == 'TABLE' && trNode) {\n        // When inserting a table into a table, if these tables have the same column count, and\n        // current position is at beginning of a row, then merge these two tables\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\n        if (\n            currentTable.col == 0 &&\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\n            newTable.cells[0] &&\n            newTable.cells[0].length == currentTable.cells[0].length &&\n            isPositionAtBeginningOf(position, tdNode)\n        ) {\n            if (\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\n                !rootNodeToInsert.firstChild.nextSibling\n            ) {\n                unwrap(rootNodeToInsert.firstChild);\n            }\n            unwrap(rootNodeToInsert);\n            position = new Position(trNode, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\nfunction handleParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        let pos = position.normalize();\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\nfunction handleVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: NodePosition\n): NodePosition {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\nimport { hasFocus } from './hasFocus';\nimport {\n    contains,\n    getPendableFormatState,\n    Position,\n    PendableFormatNames,\n    PendableFormatCommandMap,\n    addRangeToSelection,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Change the editor selection to the given range\n * @param core The EditorCore object\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport const selectRange: SelectRange = (\n    core: EditorCore,\n    range: Range,\n    skipSameRange?: boolean\n) => {\n    if (!core.lifecycle.shadowEditSelectionPath && contains(core.contentDiv, range)) {\n        addRangeToSelection(range, skipSameRange);\n\n        if (!hasFocus(core)) {\n            core.domEvent.selectionRange = range;\n        }\n\n        if (range.collapsed) {\n            // If selected, and current selection is collapsed,\n            // need to restore pending format state if exists.\n            restorePendingFormatState(core);\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Restore cached pending format state (if exist) to current selection\n */\nfunction restorePendingFormatState(core: EditorCore) {\n    const {\n        contentDiv,\n        pendingFormatState,\n        api: { getSelectionRange },\n    } = core;\n\n    if (pendingFormatState.pendableFormatState) {\n        const document = contentDiv.ownerDocument;\n        let formatState = getPendableFormatState(document);\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\n                document.execCommand(PendableFormatCommandMap[key], false, null);\n            }\n        });\n\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\n    }\n}\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    EditorCore,\n    PluginEventType,\n    SetContent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The EditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n */\nexport const setContent: SetContent = (\n    core: EditorCore,\n    content: string,\n    triggerContentChangedEvent: boolean\n) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        const range = setHtmlWithSelectionPath(core.contentDiv, content);\n        core.api.selectRange(core, range);\n        contentChanged = true;\n    }\n\n    // Convert content even if it hasn't changed.\n    core.api.transformColor(\n        core,\n        core.contentDiv,\n        false /*includeSelf*/,\n        null /*callback*/,\n        ColorTransformDirection.LightToDark\n    );\n\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n","import { createRange, getSelectionPath } from 'roosterjs-editor-dom';\nimport { EditorCore, PluginEventType, SwitchShadowEdit } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const switchShadowEdit: SwitchShadowEdit = (core: EditorCore, isOn: boolean): void => {\n    const { lifecycle, contentDiv } = core;\n    let { shadowEditFragment, shadowEditSelectionPath } = lifecycle;\n    const wasInShadowEdit = !!shadowEditFragment;\n\n    if (isOn) {\n        if (!wasInShadowEdit) {\n            const range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            shadowEditSelectionPath = range && getSelectionPath(contentDiv, range);\n            shadowEditFragment = core.contentDiv.ownerDocument.createDocumentFragment();\n            while (contentDiv.firstChild) {\n                shadowEditFragment.appendChild(contentDiv.firstChild);\n            }\n\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment: shadowEditFragment,\n                    selectionPath: shadowEditSelectionPath,\n                },\n                false /*broadcast*/\n            );\n\n            lifecycle.shadowEditFragment = shadowEditFragment;\n            lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;\n        }\n\n        contentDiv.innerHTML = '';\n        contentDiv.appendChild(lifecycle.shadowEditFragment.cloneNode(true /*deep*/));\n    } else {\n        lifecycle.shadowEditFragment = null;\n        lifecycle.shadowEditSelectionPath = null;\n\n        if (wasInShadowEdit) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            contentDiv.innerHTML = '';\n            contentDiv.appendChild(shadowEditFragment);\n            core.api.focus(core);\n\n            if (shadowEditSelectionPath) {\n                core.api.selectRange(\n                    core,\n                    createRange(\n                        contentDiv,\n                        shadowEditSelectionPath.start,\n                        shadowEditSelectionPath.end\n                    )\n                );\n            }\n        }\n    }\n};\n","import { arrayPush, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\nimport {\n    ColorTransformDirection,\n    DarkModeDatasetNames,\n    EditorCore,\n    TransformColor,\n} from 'roosterjs-editor-types';\n\nconst STYLE_DATASET_MAP = {\n    /**\n     * Original style color\n     */\n    [DarkModeDatasetNames.OriginalStyleColor]: (element: HTMLElement, value: string) =>\n        (element.style.color = value),\n\n    /**\n     * Original style background color\n     */\n    [DarkModeDatasetNames.OriginalStyleBackgroundColor]: (element: HTMLElement, value: string) =>\n        (element.style.backgroundColor = value),\n};\nconst ATTR_DATASET_MAP = {\n    /**\n     * Original attribute color\n     */\n    [DarkModeDatasetNames.OriginalAttributeColor]: 'color',\n\n    /**\n     * Original attribute background color\n     */\n    [DarkModeDatasetNames.OriginalAttributeBackgroundColor]: 'bgcolor',\n};\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The EditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n */\nexport const transformColor: TransformColor = (\n    core: EditorCore,\n    rootNode: Node,\n    includeSelf: boolean,\n    callback: () => void,\n    direction: ColorTransformDirection\n) => {\n    let elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\n\n    callback?.();\n\n    elementsToTransform.forEach(element => {\n        if (direction == ColorTransformDirection.DarkToLight && element?.dataset) {\n            // Reset color styles based on the content of the ogsc/ogsb data element.\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\n            Object.keys(STYLE_DATASET_MAP).forEach((name: keyof typeof STYLE_DATASET_MAP) => {\n                STYLE_DATASET_MAP[name](element, getValueOrDefault(element.dataset[name], ''));\n                delete element.dataset[name];\n            });\n\n            // Some elements might have set attribute colors. We need to reset these as well.\n            Object.keys(ATTR_DATASET_MAP).forEach((name: keyof typeof ATTR_DATASET_MAP) => {\n                const value = element.dataset[name];\n                if (getValueOrDefault(value, null)) {\n                    element.setAttribute(ATTR_DATASET_MAP[name], value);\n                } else {\n                    element.removeAttribute(ATTR_DATASET_MAP[name]);\n                }\n                delete element.dataset[name];\n            });\n        } else if (direction == ColorTransformDirection.LightToDark && element) {\n            if (core.lifecycle.onExternalContentTransform) {\n                core.lifecycle.onExternalContentTransform(element);\n            } else {\n                element.style.color = null;\n                element.style.backgroundColor = null;\n            }\n        }\n    });\n};\n\nfunction getValueOrDefault(value: string, defualtValue: string | null) {\n    return value && value != 'undefined' && value != 'null' ? value : defualtValue;\n}\n\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\n        if (includeSelf) {\n            result.push(rootNode);\n        }\n        const allChildren = rootNode.getElementsByTagName('*');\n        arrayPush(result, toArray(allChildren));\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\n        const allChildren = rootNode.querySelectorAll('*');\n        arrayPush(result, toArray(allChildren));\n    }\n\n    return result;\n}\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (\n    core: EditorCore,\n    pluginEvent: PluginEvent,\n    broadcast: boolean\n) => {\n    if (\n        !core.lifecycle.shadowEditFragment &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import CopyPastePlugin from './CopyPastePlugin';\nimport DOMEventPlugin from './DOMEventPlugin';\nimport EditPlugin from './EditPlugin';\nimport EntityPlugin from './EntityPlugin';\nimport LifecyclePlugin from './LifecyclePlugin';\nimport MouseUpPlugin from './MouseUpPlugin';\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\nimport TypeAfterLinkPlugin from './TypeAfterLinkPlugin';\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\nimport UndoPlugin from './UndoPlugin';\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\n\n/**\n * @internal\n * Create Core Plugins\n * @param contentDiv Content DIV of editor\n * @param options Editor options\n */\nexport default function createCorePlugins(\n    contentDiv: HTMLDivElement,\n    options: EditorOptions\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\n    const map = options.corePluginOverride || {};\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\n        edit: map.edit || new EditPlugin(),\n        _placeholder: null,\n        typeAfterLink: map.typeAfterLink || new TypeAfterLinkPlugin(),\n        undo: map.undo || new UndoPlugin(options),\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\n        copyPaste: map.copyPaste || new CopyPastePlugin(),\n        entity: map.entity || new EntityPlugin(),\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins CorePlugins object\n */\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\n        edit: corePlugins.edit.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        undo: corePlugins.undo.getState(),\n        entity: corePlugins.entity.getState(),\n    };\n}\n","import {\n    addRangeToSelection,\n    extractClipboardEvent,\n    fromHtml,\n    readFile,\n    setHtmlWithSelectionPath,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ClipboardData,\n    ContentPosition,\n    EditorPlugin,\n    GetContentMode,\n    IEditor,\n    PluginEventType,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML =\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\n\n/**\n * @internal\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nexport default class CopyPastePlugin implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: this.onPaste,\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        const originalRange = this.editor.getSelectionRange();\n        if (originalRange && !originalRange.collapsed) {\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\n            const newRange = setHtmlWithSelectionPath(tempDiv, html);\n\n            if (newRange) {\n                addRangeToSelection(newRange);\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event as ClipboardEvent,\n                isCut,\n            });\n\n            this.editor.runAsync(editor => {\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\n\n                if (isCut) {\n                    editor.addUndoSnapshot(() => {\n                        const position = this.editor.deleteSelectedContent();\n                        editor.focus();\n                        editor.select(position);\n                    }, ChangeSource.Cut);\n                }\n            });\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        extractClipboardEvent(\n            event as ClipboardEvent,\n            items => {\n                if (items.rawHtml === undefined) {\n                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\n                    // This is mostly for IE\n                    const originalSelectionRange = this.editor.getSelectionRange();\n                    const tempDiv = this.getTempDiv();\n\n                    this.editor.runAsync(() => {\n                        items.rawHtml = tempDiv.innerHTML;\n                        this.cleanUpAndRestoreSelection(tempDiv, originalSelectionRange);\n                        this.paste(items);\n                    });\n                } else {\n                    this.paste(items);\n                }\n            },\n            {\n                allowLinkPreview: this.editor.isFeatureEnabled(\n                    ExperimentalFeatures.PasteWithLinkPreview\n                ),\n            }\n        );\n    };\n\n    private paste(clipboardData: ClipboardData) {\n        if (clipboardData.image) {\n            readFile(clipboardData.image, dataUrl => {\n                clipboardData.imageDataUri = dataUrl;\n                this.editor.paste(clipboardData);\n            });\n        } else {\n            this.editor.paste(clipboardData);\n        }\n    }\n\n    private getTempDiv(forceInLightMode?: boolean) {\n        const div = this.editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = fromHtml(\n                    CONTAINER_HTML,\n                    this.editor.getDocument()\n                )[0] as HTMLDivElement;\n                this.editor.insertNode(tempDiv, {\n                    position: ContentPosition.Outside,\n                });\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        if (forceInLightMode) {\n            div.style.backgroundColor = 'white';\n            div.style.color = 'black';\n        }\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\n        this.editor.select(range);\n        tempDiv.style.backgroundColor = '';\n        tempDiv.style.color = '';\n        tempDiv.style.display = 'none';\n        tempDiv.innerHTML = '';\n    }\n}\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContextMenuProvider,\n    DOMEventHandler,\n    DOMEventPluginState,\n    EditorOptions,\n    IEditor,\n    PluginEventType,\n    PluginWithState,\n    EditorPlugin,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n */\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            selectionRange: null,\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        this.disposer = editor.addDomEventHandler({\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: PluginEventType.MouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drop event\n            drop: this.onDrop,\n\n            // 5. Focus mangement\n            focus: this.onFocus,\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\n\n            // 6. Input event\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\n        });\n\n        // 7. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDrop = (e: UIEvent) => {\n        this.editor.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onFocus = () => {\n        this.editor.select(this.state.selectionRange);\n        this.state.selectionRange = null;\n    };\n\n    private onBlur = () => {\n        this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\n    };\n\n    private onScroll = (e: UIEvent) => {\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        return this.state.stopPrintableKeyboardEventPropagation\n            ? {\n                  pluginEventType: eventType,\n                  beforeDispatch:\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeybaordEvent,\n              }\n            : eventType;\n    }\n\n    private onKeybaordEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event)) {\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n        const searcher = this.editor.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2) {\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode);\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n                arrayPush(allItems, items);\n            }\n        });\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n        let ctrlOrMeta = false;\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                break;\n            }\n        }\n    }\n}\n","import {\n    Browser,\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    isCharacterValue,\n    toArray,\n    arrayPush,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    EntityClasses,\n    EntityOperation,\n    EntityPluginState,\n    HtmlSanitizerOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    QueryScope,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\n\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\nconst ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            clickingPoint: null,\n            knownEntityElements: [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.knownEntityElements = [];\n        this.state.clickingPoint = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.handleCutEvent(event.rawEvent);\n                }\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n            case PluginEventType.ContextMenu:\n                this.handleContextMenuEvent(event.rawEvent);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent(event: UIEvent) {\n        const node = event.target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n\n        if (entityElement) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\n        }\n    }\n\n    private handleCutEvent = (event: ClipboardEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (range && !range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.state.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        let entityElement: HTMLElement;\n\n        if (\n            this.state.clickingPoint &&\n            this.state.clickingPoint.pageX == pageX &&\n            this.state.clickingPoint.pageY == pageY &&\n            node &&\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\n        ) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.state.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.state.knownEntityElements = resetAll\n            ? []\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\n        const allId = this.state.knownEntityElements\n            .map(e => getEntityFromElement(e)?.id)\n            .filter(x => !!x);\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\n                this.state.knownEntityElements.push(element);\n\n                const entity = getEntityFromElement(element);\n\n                this.hydrateEntity(entity, allId);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\n        });\n    }\n\n    private checkRemoveEntityForRange(event: Event) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                this.triggerEvent(\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\n        const { id, type, wrapper, isReadonly } = entity;\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            if (knownIds.indexOf(newId) < 0) {\n                knownIds.push(newId);\n                break;\n            }\n        }\n\n        commitEntity(wrapper, type, isReadonly, newId);\n\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\n    }\n\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\n        const entity = element && getEntityFromElement(element);\n\n        if (entity) {\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                operation,\n                rawEvent,\n                entity,\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: IEditor) => {\n          editor.runAsync(editor => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import { Browser, getComputedStyles } from 'roosterjs-editor-dom';\nimport {\n    DefaultFormat,\n    DocumentCommand,\n    EditorOptions,\n    IEditor,\n    LifecyclePluginState,\n    PluginEventType,\n    PluginWithState,\n    PluginEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\nconst COMMANDS: {\n    [command: string]: any;\n} = Browser.isFirefox\n    ? {\n          /**\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\n           */\n          [DocumentCommand.EnableObjectResizing]: false,\n          [DocumentCommand.EnableInlineTableEditing]: false,\n      }\n    : Browser.isIE\n    ? {\n          /**\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\n           */\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\n\n          /**\n           * Disable auto link feature in IE since we have our own implementation\n           */\n          [DocumentCommand.AutoUrlDetect]: false,\n      }\n    : {};\n\nconst DARK_MODE_DEFAULT_FORMAT = {\n    backgroundColors: {\n        darkModeColor: 'rgb(51,51,51)',\n        lightModeColor: 'rgb(255,255,255)',\n    },\n    textColors: {\n        darkModeColor: 'rgb(255,255,255)',\n        lightModeColor: 'rgb(0,0,0)',\n    },\n};\n\n/**\n * @internal\n * Lifecycle plugin handles editor initialization and disposing\n */\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor;\n    private state: LifecyclePluginState;\n    private initialContent: string;\n    private contentDivFormat: string[];\n    private initializer: () => void;\n    private disposer: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\n        this.contentDivFormat = getComputedStyles(contentDiv);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                this.setSelectStyle(contentDiv, 'text');\n            };\n            this.disposer = () => {\n                this.setSelectStyle(contentDiv, '');\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\n            };\n        }\n\n        this.state = {\n            customData: {},\n            defaultFormat: options.defaultFormat || null,\n            isDarkMode: !!options.inDarkMode,\n            onExternalContentTransform: options.onExternalContentTransform,\n            experimentalFeatures: options.experimentalFeatures || [],\n            shadowEditFragment: null,\n            shadowEditSelectionPath: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Calculate default format\n        this.recalculateDefaultFormat();\n\n        // Ensure initial content and its format\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Do proper change for browsers to disable some browser-specified behaviors.\n        this.adjustBrowserBehavior();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        Object.keys(this.state.customData).forEach(key => {\n            const data = this.state.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete this.state.customData[key];\n        });\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.recalculateDefaultFormat();\n        }\n    }\n\n    private adjustBrowserBehavior() {\n        Object.keys(COMMANDS).forEach(command => {\n            // Catch any possible exception since this should not block the initialization of editor\n            try {\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\n            } catch {}\n        });\n    }\n\n    private setSelectStyle(node: HTMLElement, value: string) {\n        node.style.userSelect = value;\n        node.style.msUserSelect = value;\n        node.style.webkitUserSelect = value;\n    }\n\n    private recalculateDefaultFormat() {\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\n\n        if (isDarkMode && baseFormat) {\n            if (!baseFormat.backgroundColors) {\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\n            }\n            if (!baseFormat.textColors) {\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\n            }\n        }\n\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\n            return;\n        }\n\n        const {\n            fontFamily,\n            fontSize,\n            textColor,\n            textColors,\n            backgroundColor,\n            backgroundColors,\n            bold,\n            italic,\n            underline,\n        } = baseFormat || <DefaultFormat>{};\n        const defaultFormat = this.contentDivFormat;\n\n        this.state.defaultFormat = {\n            fontFamily: fontFamily || defaultFormat[0],\n            fontSize: fontSize || defaultFormat[1],\n            get textColor() {\n                return textColors\n                    ? isDarkMode\n                        ? textColors.darkModeColor\n                        : textColors.lightModeColor\n                    : textColor || defaultFormat[2];\n            },\n            textColors: textColors,\n            get backgroundColor() {\n                return backgroundColors\n                    ? isDarkMode\n                        ? backgroundColors.darkModeColor\n                        : backgroundColors.lightModeColor\n                    : backgroundColor || '';\n            },\n            backgroundColors: backgroundColors,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n        };\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\n * as long as the mouse was pressed within Editor before\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private editor: IEditor;\n    private mouseUpEventListerAdded: boolean;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'MouseUp';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n        }\n    }\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n            });\n        }\n    };\n}\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    IEditor,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChagned event, cache current position and pending format\n                this.state.pendableFormatPosition = this.getCurrentPosition();\n                this.state.pendableFormatState = event.formatState;\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                // If content or position is changed (by keyboard, mouse, or code),\n                // check if current position is still the same with the cached one (if exist),\n                // and clear cached format if position is changed since it is out-of-date now\n                if (\n                    this.state.pendableFormatPosition &&\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\n                ) {\n                    this.clear();\n                }\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n    }\n\n    private getCurrentPosition() {\n        let range = this.editor.getSelectionRange();\n        return range && Position.getStart(range).normalize();\n    }\n}\n","import { Browser, LinkInlineElement, Position } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * TypeAfterLinkPlugin Component helps handle typing event when cursor is right after a link.\n * When typing/pasting after a link, browser may put the new charactor inside link.\n * This plugin overrides this behavior to always insert outside of link.\n */\nexport default class TypeAfterLinkPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeAfterLink';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\n            event.eventType == PluginEventType.BeforePaste\n        ) {\n            let range = this.editor.getSelectionRange();\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let inlineElement = searcher.getInlineElementBefore();\n                if (inlineElement instanceof LinkInlineElement) {\n                    this.editor.select(\n                        new Position(inlineElement.getContainerNode(), PositionType.After)\n                    );\n                }\n            }\n        }\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            // If normalization was not possible before the keypress,\n            // check again after the keyboard event has been processed by browser native behaviour.\n            //\n            // This handles the case where the keyboard event that first inserts content happens when\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\n            //\n            // Only scheudle when the range is not collapsed to catch this edge case.\n            let range = this.editor.getSelectionRange();\n\n            if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\n                return;\n            }\n\n            if (range.collapsed) {\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\n            } else {\n                this.editor.runAsync(editor => {\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\n                });\n            }\n        }\n    }\n}\n","import {\n    EditorOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshot,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshots,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapsnot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAXSIZELIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor;\n    private lastKeyPress: number;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                if (!this.state.isRestoring) {\n                    this.clearRedoForInput();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else {\n                let selectionRange = this.editor.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        let range = this.editor.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService {\n    const snapshots = createSnapshots(MAXSIZELIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): string => moveCurrentSnapsnot(snapshots, delta),\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshots(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n","export { default as HyperLink } from './HyperLink';\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string;\n    private trackedLink: HTMLAnchorElement = null;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({\n                mouseover: this.onMouse,\n                mouseout: this.onMouse,\n                blur: this.onBlur,\n            });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor.getElementAtCursor(\n                'A[href]',\n                null /*startFrom*/,\n                event\n            ) as HTMLAnchorElement;\n\n            const shouldCheckUpdateLink =\n                anchor !== this.trackedLink ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            let display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            let href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            let linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor.addUndoSnapshot(() => {\n                    this.trackedLink.href = linkData.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n","export { default as Paste } from './Paste';\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport handleLineMerge from './lineMerge/handleLineMerge';\nimport { toArray } from 'roosterjs-editor-dom';\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or Onenote Online\n */\nexport default class Paste implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     */\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {}\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            let wacListElements: Node[];\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event);\n            } else if (\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))) &&\n                wacListElements.length > 0\n            ) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\n            } else if (this.editor.isFeatureEnabled(ExperimentalFeatures.MergePastedLine)) {\n                handleLineMerge(fragment);\n            }\n\n            // Replace unknown tags with SPAN\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n        }\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param doc HTML Document which contains the content from Excel\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\n    const html = excelHandler(clipboardData.html, htmlBefore);\n\n    if (clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(html, 'text/html');\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        element.innerHTML = '&nbsp;';\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import WordConverterArguments from './WordConverterArguments';\nimport WordCustomData, { createCustomData } from './WordCustomData';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    wordCustomData: WordCustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        wordCustomData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item metatada of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                while (node.firstChild != null) {\n                    last.appendChild(node.firstChild);\n                }\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                while (node.firstChild) {\n                    li.appendChild(node.firstChild);\n                }\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.wordCustomData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        while (list.firstChild) {\n            newList.appendChild(list.firstChild);\n        }\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list beofre the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list metadada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listprops = listatt.split(' ');\n                if (listprops.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listprops[1].substr('level'.length)),\n                        wordListId: listatt,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring emtpy text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those unstandard values throug the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    ContentTraverser,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        processBlock(blocks[0]);\n        processBlock(blocks[blocks.length - 1]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\n        block.start = node;\n        block.end = node;\n\n        if (getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument.createTextNode('');\n        end.parentNode?.insertBefore(node, end);\n        block.end = node;\n        end.parentNode?.removeChild(end);\n    }\n}\n\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (blockElement?.contains(sibling)) {\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\n            block.start.ownerDocument.createElement('br'),\n            isFirst ? block.end.nextSibling : block.start\n        );\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock?.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\n","import { fromHtml } from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\nconst CONTAINER_HTML = '<div style=\"position: fixed; width: 0; height: 0\"></div>';\n\nexport interface ContextMenuOptions<T> {\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    dismiss?: (container: HTMLElement) => void;\n\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport default class ContextMenu<T> implements EditorPlugin {\n    private container: HTMLElement;\n    private editor: IEditor;\n    private isMenuShowing: boolean;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\n            this.options.render(this.container, items as T[], this.onDismiss);\n            this.isMenuShowing = true;\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container) {\n            this.container = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\n            this.editor.insertNode(this.container, {\n                position: ContentPosition.Outside,\n            });\n        }\n        this.container.style.left = x + 'px';\n        this.container.style.top = y + 'px';\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\n","import {\n    CustomReplacement,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: CustomReplacement[] = [\n    makeReplacement(':)', '🙂', true),\n    makeReplacement(';)', '😉', true),\n    makeReplacement(':O', '😲', true),\n    makeReplacement(':o', '😯', true),\n    makeReplacement('<3', '❤️', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: IEditor;\n    private replacements: CustomReplacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: CustomReplacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = replacement.replacementHTML;\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.addUndoSnapshot(\n            () => {\n                matchingRange.deleteContents();\n                matchingRange.insertNode(nodeToInsert);\n                this.editor.select(nodeToInsert, PositionType.End);\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    }\n\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/CutPasteListChain/index';\n","export { default as CutPasteListChain } from './CutPasteListChain';\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\n/**\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\n */\nexport default class CutPasteListChain implements EditorPlugin {\n    private chains: VListChain[];\n    private expectedChangeSource: ChangeSource;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CutPasteListChain';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.cacheListChains(ChangeSource.Cut);\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.cacheListChains(ChangeSource.Paste);\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\n                    experimentCommitListChains(this.editor, this.chains);\n                    this.chains = null;\n                    this.expectedChangeSource = null;\n                }\n                break;\n        }\n    }\n\n    private onDrop = () => {\n        this.cacheListChains(ChangeSource.Drop);\n    };\n\n    private cacheListChains(source: ChangeSource) {\n        if (this.editor.isFeatureEnabled(ExperimentalFeatures.ListChain)) {\n            this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\n            this.expectedChangeSource = source;\n        }\n    }\n}\n","export * from './plugins/ImageResize/index';\n","export { default as ImageResize } from './ImageResize';\n","import { fromHtml, getEntitySelector, getTagOfNode, toArray } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n    EntityOperation,\n    Entity,\n    ExperimentalFeatures,\n} from 'roosterjs-editor-types';\n\nconst DELETE_KEYCODE = 46;\nconst BACKSPACE_KEYCODE = 8;\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\nconst ENTITY_TYPE = 'IMAGE_RESIZE_WRAPPER';\n\nconst HANDLE_SIZE = 7;\nconst HANDLE_MARGIN = 3;\nconst CORNER_HANDLE_POSITIONS = ['nw', 'ne', 'se', 'sw'];\nconst SIDE_HANDLE_POSITIONS = ['n', 'e', 's', 'w'];\nconst ALL_HANDLE_POSITIONS = CORNER_HANDLE_POSITIONS.concat(SIDE_HANDLE_POSITIONS);\n\n/**\n * ImageResize plugin provides the ability to resize an inline image in editor\n */\nexport default class ImageResize implements EditorPlugin {\n    private editor: IEditor;\n    private startPageX: number;\n    private startPageY: number;\n    private startWidth: number;\n    private startHeight: number;\n    private resizeDiv: HTMLElement;\n    private direction: string;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        private minWidth: number = 10,\n        private minHeight: number = 10,\n        private selectionBorderColor: string = '#DB626C',\n        private forcePreserveRatio: boolean = false,\n        private resizableImageSelector: string = 'img'\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ImageResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            dragstart: this.onDragStart,\n            blur: this.onBlur,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.hideResizeHandle();\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        if (e.eventType == PluginEventType.MouseDown) {\n            if (this.resizeDiv) {\n                this.hideResizeHandle();\n            }\n        } else if (e.eventType == PluginEventType.MouseUp) {\n            const event = e.rawEvent;\n            const target = <HTMLElement>(event.srcElement || event.target);\n\n            if (getTagOfNode(target) == 'IMG') {\n                const parent = target.parentNode as HTMLElement;\n                const elements = parent\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\n                    : [];\n                if (elements.indexOf(target) < 0) {\n                    return;\n                }\n\n                const currentImg = this.getSelectedImage();\n                if (currentImg && currentImg != target) {\n                    this.hideResizeHandle();\n                }\n\n                if (!this.resizeDiv) {\n                    this.showResizeHandle(<HTMLImageElement>target);\n                }\n            }\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\n            const event = e.rawEvent;\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\n                this.editor.addUndoSnapshot(() => {\n                    this.editor.deleteNode(this.resizeDiv);\n                });\n                this.resizeDiv = null;\n                event.preventDefault();\n            } else if (\n                event.which != SHIFT_KEYCODE &&\n                event.which != CTRL_KEYCODE &&\n                event.which != ALT_KEYCODE\n            ) {\n                this.hideResizeHandle(true /*selectImage*/);\n            }\n        } else if (\n            e.eventType == PluginEventType.ContentChanged &&\n            e.source != ChangeSource.ImageResize &&\n            (e.source != ChangeSource.InsertEntity || (<Entity>e.data)?.type != ENTITY_TYPE)\n        ) {\n            this.editor.queryElements(getEntitySelector(ENTITY_TYPE), this.removeResizeDiv);\n            this.resizeDiv = null;\n        } else if (e.eventType == PluginEventType.EntityOperation && e.entity.type == ENTITY_TYPE) {\n            if (e.operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeResizeDiv(e.entity.wrapper);\n            } else if (e.operation == EntityOperation.Click) {\n                this.stopEvent(e.rawEvent);\n            }\n        }\n    }\n\n    /**\n     * Select a given IMG element, show the resize handle\n     * @param img The IMG element to select\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.resizeDiv = this.createResizeDiv(img);\n        this.editor.select(this.resizeDiv, PositionType.After);\n    }\n\n    /**\n     * Hide resize handle of current selected image\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        if (this.resizeDiv) {\n            const transform = this.resizeDiv.style.transform;\n            const img = this.removeResizeDiv(this.resizeDiv);\n\n            if (img) {\n                img.style.transform = transform;\n\n                if (selectImageAfterUnSelect) {\n                    this.editor.select(img);\n                }\n            }\n\n            this.resizeDiv = null;\n        }\n    }\n\n    private startResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            this.startPageX = e.pageX;\n            this.startPageY = e.pageY;\n            this.startWidth = img.clientWidth;\n            this.startHeight = img.clientHeight;\n            this.editor.addUndoSnapshot();\n\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).dataset.direction;\n        }\n\n        this.stopEvent(e);\n    };\n\n    private doResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            let widthChange = e.pageX - this.startPageX;\n            let heightChange = e.pageY - this.startPageY;\n            let newWidth = this.calculateNewWidth(widthChange);\n            let newHeight = this.calculateNewHeight(heightChange);\n            const isSingleDirection =\n                this.isSingleDirectionNS(this.direction) ||\n                this.isSingleDirectionWE(this.direction);\n            const shouldPreserveRatio =\n                !isSingleDirection && (this.forcePreserveRatio || e.shiftKey);\n\n            if (shouldPreserveRatio) {\n                newHeight = Math.min(newHeight, (newWidth * this.startHeight) / this.startWidth);\n                newWidth = Math.min(newWidth, (newHeight * this.startWidth) / this.startHeight);\n\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n                if (ratio > 0) {\n                    if (newWidth < newHeight * ratio) {\n                        newWidth = newHeight * ratio;\n                    } else {\n                        newHeight = newWidth / ratio;\n                    }\n                }\n            }\n\n            img.style.width = newWidth + 'px';\n            img.style.height = newHeight + 'px';\n\n            // double check\n            if (shouldPreserveRatio) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n\n                const clientWidth = Math.floor(img.clientWidth);\n                const clientHeight = Math.floor(img.clientHeight);\n                newWidth = Math.floor(newWidth);\n                newHeight = Math.floor(newHeight);\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\n                    if (clientHeight < newHeight) {\n                        newWidth = clientHeight * ratio;\n                    } else {\n                        newHeight = clientWidth / ratio;\n                    }\n                    img.style.width = newWidth + 'px';\n                    img.style.height = newHeight + 'px';\n                }\n            }\n        }\n        this.stopEvent(e);\n    };\n\n    private calculateNewWidth(widthChange: number): number {\n        let newWidth = this.startWidth;\n        if (!this.isSingleDirectionNS(this.direction)) {\n            newWidth = Math.max(\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\n                this.minWidth\n            );\n        }\n        return newWidth;\n    }\n\n    private calculateNewHeight(heightChange: number): number {\n        let newHeight = this.startHeight;\n        if (!this.isSingleDirectionWE(this.direction)) {\n            newHeight = Math.max(\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\n                this.minHeight\n            );\n        }\n        return newHeight;\n    }\n\n    private finishResize = (e: MouseEvent) => {\n        var img = this.getSelectedImage() as HTMLImageElement;\n        if (this.editor && img) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            let width = img.clientWidth;\n            let height = img.clientHeight;\n            img.style.width = width + 'px';\n            img.style.height = height + 'px';\n            img.width = width;\n            img.height = height;\n            this.resizeDiv.style.width = '';\n            this.resizeDiv.style.height = '';\n        }\n        this.direction = null;\n        this.editor.addUndoSnapshot();\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize, img);\n        this.stopEvent(e);\n    };\n\n    private createResizeDiv(target: HTMLElement) {\n        const { wrapper } = insertEntity(\n            this.editor,\n            ENTITY_TYPE,\n            target,\n            false /*isBlock*/,\n            true /*isReadonly*/\n        );\n\n        wrapper.style.position = 'relative';\n        wrapper.style.display = 'inline-flex';\n\n        const html =\n            (this.editor.isFeatureEnabled(ExperimentalFeatures.SingleDirectionResize)\n                ? ALL_HANDLE_POSITIONS\n                : CORNER_HANDLE_POSITIONS\n            )\n                .map(\n                    pos =>\n                        `<div style=\"position:absolute;${this.isWest(pos) ? 'left' : 'right'}:${\n                            this.isSingleDirectionNS(pos) ? '50%' : '0px'\n                        };${this.isNorth(pos) ? 'top' : 'bottom'}:${\n                            this.isSingleDirectionWE(pos) ? '50%' : '0px'\n                        }\">\n                            <div id=${pos}-handle data-direction=\"${pos}\" style=\"position:relative;width:${HANDLE_SIZE}px;height:${HANDLE_SIZE}px;background-color: ${\n                            this.selectionBorderColor\n                        };cursor: ${pos}-resize;${\n                            this.isNorth(pos) ? 'top' : 'bottom'\n                        }:-${HANDLE_MARGIN}px;${\n                            this.isWest(pos) ? 'left' : 'right'\n                        }:-${HANDLE_MARGIN}px\"></div></div>`\n                )\n                .join('') +\n            `<div style=\"position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${this.selectionBorderColor};pointer-events:none;\">`;\n\n        fromHtml(html, this.editor.getDocument()).forEach(div => {\n            wrapper.appendChild(div);\n            div.addEventListener('mousedown', this.startResize);\n        });\n\n        // If the resizeDiv's image has a transform, apply it to the container\n        const selectedImage = this.getSelectedImage(wrapper);\n        if (selectedImage && selectedImage.style && selectedImage.style.transform) {\n            wrapper.style.transform = selectedImage.style.transform;\n            selectedImage.style.transform = '';\n        }\n\n        return wrapper;\n    }\n\n    private stopEvent = (e: Event) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    private removeResizeDiv = (resizeDiv: HTMLElement): HTMLImageElement => {\n        if (resizeDiv?.parentNode) {\n            const img = resizeDiv.querySelector('img');\n            if (img) {\n                resizeDiv.parentNode.insertBefore(img, resizeDiv);\n            }\n            resizeDiv.parentNode.removeChild(resizeDiv);\n            return img;\n        } else {\n            return null;\n        }\n    };\n\n    private onBlur = (e: FocusEvent) => {\n        this.hideResizeHandle();\n    };\n\n    private getSelectedImage(div?: HTMLElement): HTMLElement {\n        const divWithImage = div || this.resizeDiv;\n        return divWithImage ? <HTMLElement>divWithImage.getElementsByTagName('IMG')[0] : null;\n    }\n\n    private isNorth(direction: string): boolean {\n        return direction && direction.substr(0, 1) == 'n';\n    }\n\n    private isWest(direction: string): boolean {\n        return direction && (direction.substr(1, 1) == 'w' || direction == 'w');\n    }\n\n    private isSingleDirectionNS(direction: string): boolean {\n        return direction && (direction == 'n' || direction == 's');\n    }\n\n    private isSingleDirectionWE(direction: string): boolean {\n        return direction && (direction == 'w' || direction == 'e');\n    }\n\n    private onDragStart = (e: DragEvent) => {\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\n            this.hideResizeHandle(true);\n        }\n    };\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin } from './PickerPlugin';\n","import { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    Browser,\n    createRange,\n    isCharacterValue,\n    isModifierKey,\n    PartialInlineElement,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    NodePosition,\n    PickerDataProvider,\n    PickerPluginOptions,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHARCODE = 'Backspace';\nconst TAB_CHARCODE = 'Tab';\nconst ENTER_CHARCODE = 'Enter';\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPlugin {\n    private editor: IEditor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: IEditor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                this.editor.addUndoSnapshot(\n                    insertNode,\n                    this.pickerOptions.changeSource,\n                    this.pickerOptions.handleAutoComplete\n                );\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undos and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = this.editor.getContentSearcherOfCursor(event);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        positionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHARCODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                // #483: If we are backspacing over the trigger character that triggered this Picker\n                // then we need to hide the Picker\n                const wordBeforeCursor = this.getWord(event);\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\n                    this.setIsSuggesting(false);\n                }\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(editor => {\n                        editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { fromHtml, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    Rect,\n    ChangeSource,\n    TableOperation,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\nconst INSERTER_HOVER_OFFSET = 5;\n\nconst CELL_RESIZER_WIDTH = 4;\nconst HORIZONTAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: row-resize; user-select: none\"></div>';\nconst VERTICAL_RESIZER_HTML =\n    '<div style=\"position: fixed; cursor: col-resize; user-select: none\"></div>';\n\nconst enum ResizeState {\n    None,\n    Horizontal,\n    Vertical,\n}\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: IEditor;\n    private onMouseMoveDisposer: () => void;\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\n    private resizerContainer: HTMLDivElement;\n    private currentTable: HTMLTableElement;\n    private currentTd: HTMLTableCellElement;\n    private horizontalResizer: HTMLDivElement;\n    private verticalResizer: HTMLDivElement;\n    private resizingState: ResizeState = ResizeState.None;\n\n    private currentInsertTd: HTMLTableCellElement;\n    private insertingState: ResizeState = ResizeState.None;\n    private inserter: HTMLDivElement;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.setupResizerContainer();\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onMouseMoveDisposer();\n        this.destoryRectMap();\n        this.removeResizerContainer();\n\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.Input:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.Scroll:\n                this.destoryRectMap();\n                break;\n        }\n    }\n\n    private setupResizerContainer() {\n        this.resizerContainer = this.editor.getDocument().createElement('div');\n        this.editor.insertNode(this.resizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n    }\n\n    private removeResizerContainer() {\n        this.resizerContainer.parentNode.removeChild(this.resizerContainer);\n        this.resizerContainer = null;\n    }\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (this.resizingState != ResizeState.None) {\n            return;\n        }\n\n        if (!this.tableRectMap) {\n            this.cacheRects();\n        }\n\n        if (this.tableRectMap) {\n            let i = this.tableRectMap.length - 1;\n            for (; i >= 0; i--) {\n                const { table, rect } = this.tableRectMap[i];\n                if (\n                    e.pageX >= rect.left - INSERTER_SIDE_LENGTH &&\n                    e.pageX <= rect.right &&\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\n                    e.pageY <= rect.bottom\n                ) {\n                    this.setCurrentTable(table, rect);\n                    break;\n                }\n            }\n\n            if (i < 0) {\n                this.setCurrentTable(null);\n            }\n\n            if (this.currentTable) {\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\n\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\n                    const tr = this.currentTable.rows[i];\n\n                    let j = 0;\n                    for (; j < tr.cells.length; j++) {\n                        const td = tr.cells[Math.max(0, j)];\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                        if (tdRect && e.pageX <= tdRect.right && e.pageY < tdRect.bottom) {\n                            if (i == 0 && e.pageY <= tdRect.top + INSERTER_HOVER_OFFSET) {\n                                this.setCurrentTd(null);\n                                this.setCurrentInsertTd(ResizeState.Vertical, td, map.rect);\n                                break;\n                            } else if (j == 0 && e.pageX <= tdRect.left + INSERTER_HOVER_OFFSET) {\n                                this.setCurrentTd(null);\n                                this.setCurrentInsertTd(ResizeState.Horizontal, td, map.rect);\n                                break;\n                            } else {\n                                this.setCurrentTd(td, map.rect, tdRect.right, tdRect.bottom);\n                                this.setCurrentInsertTd(ResizeState.None);\n                                break;\n                            }\n                        }\n                    }\n                    if (j < tr.cells.length) {\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td: HTMLTableCellElement,\n        tableRect: Rect\n    ): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td?: HTMLTableCellElement,\n        tableRect?: Rect\n    ) {\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\n            if (this.currentInsertTd) {\n                this.resizerContainer.removeChild(this.inserter);\n                this.inserter = null;\n            }\n            this.insertingState = insertingState;\n            this.currentInsertTd = td;\n            if (this.currentInsertTd) {\n                this.inserter = this.createInserter(tableRect);\n                this.resizerContainer.appendChild(this.inserter);\n            }\n        }\n    }\n\n    private createInserter(tableRect: Rect) {\n        if (this.insertingState == ResizeState.None) {\n            return;\n        }\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\n        const HORIZONTAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${INSERTER_COLOR}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${INSERTER_COLOR}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 12px; top: 5px; height: 3px; border-top: 1px solid ${INSERTER_COLOR}; border-bottom: 1px solid ${INSERTER_COLOR}; border-right: 1px solid ${INSERTER_COLOR}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n        const VERTICAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${INSERTER_COLOR}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${INSERTER_COLOR}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${INSERTER_COLOR}; border-right: 1px solid ${INSERTER_COLOR}; border-bottom: 1px solid ${INSERTER_COLOR}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\n\n        const inserter = fromHtml(\n            this.insertingState == ResizeState.Horizontal\n                ? HORIZONTAL_INSERTER_HTML\n                : VERTICAL_INSERTER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n\n        if (rect) {\n            if (this.insertingState == ResizeState.Horizontal) {\n                inserter.style.left = `${\n                    rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                inserter.style.top = `${rect.bottom - 8}px`;\n                (inserter.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                inserter.style.left = `${rect.right - 8}px`;\n                inserter.style.top = `${\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (inserter.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n        }\n\n        inserter.addEventListener('click', this.insertTd);\n\n        return inserter;\n    }\n\n    private insertTd = () => {\n        this.editor.addUndoSnapshot((start, end) => {\n            const vtable = new VTable(this.currentInsertTd);\n            vtable.edit(\n                this.insertingState == ResizeState.Horizontal\n                    ? TableOperation.InsertBelow\n                    : TableOperation.InsertRight\n            );\n            vtable.writeBack();\n            this.editor.select(start, end);\n            this.setCurrentInsertTd(ResizeState.None);\n        }, ChangeSource.Format);\n    };\n\n    private setCurrentTable(table: HTMLTableElement, rect: Rect): void;\n    private setCurrentTable(table: null): void;\n    private setCurrentTable(table: HTMLTableElement, rect?: Rect) {\n        if (this.currentTable != table) {\n            this.setCurrentTd(null);\n            this.setCurrentInsertTd(ResizeState.None);\n            this.currentTable = table;\n        }\n    }\n\n    private setCurrentTd(td: null): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect: Rect,\n        right: number,\n        bottom: number\n    ): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect?: Rect,\n        right?: number,\n        bottom?: number\n    ) {\n        if (this.currentTd != td) {\n            if (this.currentTd) {\n                this.resizerContainer.removeChild(this.horizontalResizer);\n                this.resizerContainer.removeChild(this.verticalResizer);\n                this.horizontalResizer = null;\n                this.verticalResizer = null;\n            }\n\n            this.currentTd = td;\n\n            if (this.currentTd) {\n                this.horizontalResizer = this.createResizer(\n                    true /*horizontal*/,\n                    tableRect.left,\n                    bottom - CELL_RESIZER_WIDTH + 1,\n                    tableRect.right - tableRect.left,\n                    CELL_RESIZER_WIDTH\n                );\n                this.verticalResizer = this.createResizer(\n                    false /*horizontal*/,\n                    right - CELL_RESIZER_WIDTH + 1,\n                    tableRect.top,\n                    CELL_RESIZER_WIDTH,\n                    tableRect.bottom - tableRect.top\n                );\n\n                this.resizerContainer.appendChild(this.horizontalResizer);\n                this.resizerContainer.appendChild(this.verticalResizer);\n            }\n        }\n    }\n\n    private createResizer(\n        horizontal: boolean,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ) {\n        const div = fromHtml(\n            horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML,\n            this.editor.getDocument()\n        )[0] as HTMLDivElement;\n        div.style.top = `${top}px`;\n        div.style.left = `${left}px`;\n        div.style.width = `${width}px`;\n        div.style.height = `${height}px`;\n\n        div.addEventListener(\n            'mousedown',\n            horizontal ? this.startHorizontalResizeTable : this.startVerticalResizeTable\n        );\n\n        return div;\n    }\n\n    private startHorizontalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Horizontal;\n        this.startResizeTable(e);\n    };\n\n    private startVerticalResizeTable = (e: MouseEvent) => {\n        this.resizingState = ResizeState.Vertical;\n        this.startResizeTable(e);\n    };\n\n    private startResizeTable(e: MouseEvent) {\n        const doc = this.editor.getDocument();\n        doc.addEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.addEventListener('mouseup', this.endResizeTable, true);\n    }\n\n    private frameAnimateResizeTable = (e: MouseEvent) => {\n        this.editor.runAsync(() => this.resizeTable(e));\n    };\n\n    private resizeTable = (e: MouseEvent) => {\n        if (this.currentTd && this.resizingState !== ResizeState.None) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            if (rect) {\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\n\n                let vtable = new VTable(this.currentTd);\n\n                if (this.resizingState == ResizeState.Horizontal) {\n                    vtable.table.style.height = null;\n                    vtable.forEachCellOfCurrentRow(cell => {\n                        if (cell.td) {\n                            cell.td.style.height =\n                                cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\n                        }\n                    });\n                } else {\n                    vtable.table.style.width = '';\n                    vtable.table.width = '';\n                    vtable.forEachCellOfCurrentColumn(cell => {\n                        if (cell.td) {\n                            cell.td.style.wordBreak = 'break-word';\n                            cell.td.style.width =\n                                cell.td == this.currentTd ? `${newPos - rect.left}px` : null;\n                        }\n                    });\n                }\n                vtable.writeBack();\n            }\n        }\n    };\n\n    private endResizeTable = (e: MouseEvent) => {\n        const doc = this.editor.getDocument();\n        doc.removeEventListener('mousemove', this.frameAnimateResizeTable, true);\n        doc.removeEventListener('mouseup', this.endResizeTable, true);\n\n        this.editor.addUndoSnapshot((start, end) => {\n            this.frameAnimateResizeTable(e);\n            this.editor.select(start, end);\n        }, ChangeSource.Format);\n\n        this.setCurrentTd(null);\n        this.resizingState = ResizeState.None;\n    };\n\n    private destoryRectMap() {\n        this.setCurrentTable(null);\n        this.tableRectMap = null;\n    }\n\n    private cacheRects() {\n        this.destoryRectMap();\n        this.tableRectMap = [];\n        this.editor.queryElements('table', table => {\n            const rect = normalizeRect(table.getBoundingClientRect());\n            if (rect) {\n                this.tableRectMap.push({\n                    table,\n                    rect,\n                });\n            }\n        });\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    DefaultFormat,\n    EditorPlugin,\n    Entity,\n    EntityOperation,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColor: '#aaa',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.showHideWatermark,\n            blur: this.showHideWatermark,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.EditorReady ||\n            (event.eventType == PluginEventType.ContentChanged &&\n                (<Entity>event.data)?.type != ENTITY_TYPE)\n        ) {\n            this.showHideWatermark();\n        } else if (\n            event.eventType == PluginEventType.EntityOperation &&\n            event.entity.type == ENTITY_TYPE\n        ) {\n            const {\n                operation,\n                entity: { wrapper },\n            } = event;\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeWatermark(wrapper);\n            } else if (event.operation == EntityOperation.NewEntity) {\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\n                wrapper.spellcheck = false;\n            }\n        }\n    }\n\n    private showHideWatermark = () => {\n        const hasFocus = this.editor.hasFocus();\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\n        const isShowing = watermarks.length > 0;\n\n        if (hasFocus && isShowing) {\n            watermarks.forEach(this.removeWatermark);\n            this.editor.focus();\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\n            insertEntity(\n                this.editor,\n                ENTITY_TYPE,\n                this.editor.getDocument().createTextNode(this.watermark),\n                false /*isBlock*/,\n                false /*isReadonly*/,\n                ContentPosition.Begin\n            );\n        }\n    };\n\n    private removeWatermark = (wrapper: HTMLElement) => {\n        const parentNode = wrapper.parentNode;\n        parentNode?.removeChild(wrapper);\n\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n        if (\n            this.editor.contains(parentNode) &&\n            getTagOfNode(parentNode) == 'DIV' &&\n            !parentNode.firstChild\n        ) {\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n        }\n    };\n}\n"],"sourceRoot":""}