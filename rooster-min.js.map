{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/moveChildNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/createElement.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/getEditInfoFromImage.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/deleteEditInfo.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/types/ImageEditInfo.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/getGeneratedImageSize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchesSelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/clipboard/extractClipboardItems.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/clipboard/extractClipboardItemsForIE.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/setColor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getInnerHTML.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-color-utils/lib/index.ts","webpack://roosterjs/./node_modules/color-name/index.js","webpack://roosterjs/./node_modules/color-convert/conversions.js","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/applyChange.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/checkEditInfoState.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/api/canRegenerateImage.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/imageEditors/Resizer.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/getTargetSizeByPercentage.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/api/isResizedTo.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/clipboard/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/adjustInsertPosition.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/switchShadowEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-color-utils/lib/utils/getDarkColor.ts","webpack://roosterjs/./node_modules/color/index.js","webpack://roosterjs/./node_modules/color-string/index.js","webpack://roosterjs/./node_modules/simple-swizzle/index.js","webpack://roosterjs/./node_modules/is-arrayish/index.js","webpack://roosterjs/./node_modules/color-convert/index.js","webpack://roosterjs/./node_modules/color-convert/route.js","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/commonConverter/convertPastedContentForLI.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/pptConverter/convertPastedContentFromPowerPoint.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/ImageEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/generateDataURL.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/editInfoUtils/saveEditInfo.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/imageEditors/Cropper.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/pluginUtils/DragAndDropHelper.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/imageEditors/Rotator.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/api/resizeByPercentage.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageEdit/api/resetImage.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","KnownCreateElementData","moveCurrentSnapsnot","node","nodeType","tagName","toUpperCase","getTargetWindow","source","commonAncestorContainer","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","container","contained","treatSameNodeAsContain","parentNode","contains","internalContains","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","parentElement","CRLF","CRLF_SPACE","shouldSkipNode","textContent","replace","getDecoratedInline","getContainerNode","getParentBlock","getTextContent","getStartPosition","getEndPosition","PartialInlineElement","pos","isTextualInlineElement","thisStart","otherEnd","styler","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","region","nodeBefore","nodeAfter","beforeRunCallback","regions","getSelectedRegions","VListChain","createListChains","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","keepExistingChildren","removeChild","children","contenteditable","elementData","namespace","className","dataset","createElementNS","HTMLElement","datasetName","attrName","image","json","JSON","parse","safeParseJSON","IMAGE_EDIT_INFO_NAME","src","widthPx","clientWidth","heightPx","clientHeight","naturalWidth","naturalHeight","leftPercent","rightPercent","topPercent","bottomPercent","angleRad","getInitialEditInfo","STYLET_AGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","file","FileReader","onload","onerror","readAsDataURL","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","clientRect","left","right","top","bottom","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","isDummy","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","softOutdent","findListItems","setIsDummy","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","splice","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","editInfo","beforeCrop","width","height","angle","originalWidth","originalHeight","visibleWidth","visibleHeight","targetWidth","abs","cos","sin","targetHeight","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","collapseToSingleElement","equals","blockElement","HTML_VOID_ELEMENTS","matches","msMatchesSelector","html","isFirst","getLeafNode","CLIPBOARD_HTML_HEADER_REGEX","ContentHandlers","data","rawHtml","headerValues","exec","parseInt","substring","workaroundForEdge","text","customValues","tryParseLinkPreview","linkPreview","options","types","contentHandlers","allowLinkPreview","Promise","all","allowedCustomPasteType","textType","getAllowedCustomType","resolve","getAsString","getAsFile","dataUrl","imageDataUri","then","dataTransfer","clipboardData","getData","files","nextStep","getTempDiv","removeTempDiv","contentEditable","setTimeout","color","isBackgroundColor","isDarkMode","colorString","modeIndependentColor","setProperty","darkModeColor","lightModeColor","dataSetName","tempNode","orderListStyles","dummy","isOrphanItem","canMerge","mergeItems","wrapIfNotBlockNode","listType","pop","originalRoot","nextLevel","newList","createListElement","newRoot","listStyleType","checkFirst","checkLast","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","STYLES_TO_REMOVE","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","toArray","b","returnBlockElement","isBlockElement","isVoidHtmlElement","wrap","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","clearBlockFormat","getSelectedBlockElementsInRegion","collapseNodesInRegion","nonborderStyles","isNodeInRegion","clearFormat","formatType","queryElements","defaultFormat","getDefaultFormat","isDefaultFormatEmpty","removeProperty","fontFamily","fontSize","textColor","textColors","backgroundColor","backgroundColors","bold","italic","underline","clearInlineFormat","transverser","isMultiBlockSelection","clearAutoDetectFormat","chains","chain","commit","setColor","fontName","lineHeight","startNumber","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","createVListFromRegion","wrapFunction","NodeTag","hasFocus","core","activeElement","contentDiv","cssKeywords","reverseKeywords","convert","rgb","channels","labels","hsl","hsv","hwb","cmyk","xyz","lab","lch","hex","keyword","ansi16","ansi256","hcg","apple","gray","model","h","g","delta","rdif","gdif","bdif","v","diff","diffc","k","reversed","currentClosestKeyword","y","currentClosestDistance","Infinity","distance","pow","z","t1","t2","t3","val","smin","lmin","hi","floor","f","q","sl","vmin","wh","bl","ratio","y2","x2","z2","a","atan2","PI","sqrt","hr","args","arguments","ansi","mult","rem","string","match","char","integer","hue","chroma","mg","pure","w","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFY_SELECTOR","previousSrc","newSrc","initEditInfo","srcChanged","originalSrc","ROTATE_KEYS","CROP_KEYS","ROTATE_CROP_KEYS","ALL_KEYS","areSameNumber","n1","n2","compareTo","img","canvas","context","getContext","drawImage","getImageData","Xs","Ys","Resizer","onDragStart","onDragging","e","base","deltaX","deltaY","horizontalOnly","verticalOnly","shouldPreserveRatio","preserveRatio","shiftKey","newWidth","minWidth","newHeight","minHeight","rotateCoordinate","hypotenuse","getResizeHandleHTML","borderColor","leftOrRight","topOrBottom","actualWidth","actualHeight","resizeBorderColor","percentage","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","getDarkColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","link","matchLink","getRangeFromText","word","getWordBefore","trailingPunctuation","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","format","elementStyle","fontWeight","fontStyle","textDecoration","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","adjustSteps","nodeToInsert","isNodeEmpty","safeRemove","querySelector","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","findClosestElementAncestor","listNode","tdNode","trNode","newTable","VTable","currentTable","col","getCell","row","td","cells","isPositionAtBeginningOf","shouldInsertListAsText","div","changeElementTag","PositionContentSearcher","inlineElementBefore","inlineElementAfter","handler","normalizeSize","trs","table","getTableFromTd","rows","tr","rowIndex","sourceCol","targetCol","colSpan","rowSpan","hasTd","rect","getBoundingClientRect","spanLeft","spanAbove","cell","recalculateSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","getCellsWithBorder","borderPos","getLeftCells","j","cellRect","found","forEachCellOfRow","getCurrentTd","isNaN","normalizeEmptyTableCells","normalizeTableCellSize","setHTMLElementSizeInPx","boxSizing","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rects","getClientRects","span","areAllPreviousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","trustedHTMLHandler","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","currentRange","getRangeAt","removeAllRanges","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","moveCurrentSnapshot","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","preserveHtmlComments","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","unsafeConvertToTrustedHTML","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","isElement","isText","isFragment","isComment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","trustedTypes","policy","createPolicy","createHTML","HTML_TAG_REPLACEMENT","abbr","address","area","article","aside","bdi","bdo","blockquote","br","button","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","newCallback","isReadonly","isEntity","eventDataCache","isCtrlOrMetaPressed","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","checkXss","prefix","search","applyLinkPrefix","listTag","getElementAtCursor","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","maxWidth","imageFile","readFile","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","paddingLeft","PRE_TAG","level","wrapped","moveChildNodes","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","MaintainListChainWhenDelete","nextSibiling","getCacheNextSibiling","getListChains","experimentCommitListChains","OutdentWhenEnterOnEmptyLine","AutoBullet","isAListPattern","insertContent","textBeforeCursor","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","maintainListChainWhenDelete","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethrough","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","hasShiftKey","targetTd","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","deleteNode","existingNode","toNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","getSelectionPath","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","getRelativeDistanceToEditor","addScroll","editorRect","elementRect","scrollLeft","scrollTop","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","startShadowEdit","switchShadowEdit","stopShadowEdit","isInShadowEdit","shadowEditFragment","isFeatureEnabled","experimentalFeatures","getTrustedHTMLHandler","undoState","isNested","isShadowEdit","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","attrs","lastIndexOf","pendableFormat","styleBasedFormat","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","clonedNode","originalRange","shadowEditSelectionPath","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","adjustInsertPosition","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","newContent","setHtmlWithSelectionPath","isOn","wasInShadowEdit","ColorAttributeName","transformToLightMode","names","getValueOrDefault","defaultValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","transformFunction","onExternalContentTransform","computedValues","styleColor","attrColor","newColor","transformToDarkMode","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","newRange","forceInLightMode","tempDiv","onDrop","onFocus","onKeyDownDocument","defaultPrevented","cacheSelection","onMouseDownDocument","onScroll","onKeyboardEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","eventHandlers","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","adjustColor","doNotAdjustEditorColor","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","isClicking","mouseDownX","mouseDownY","mouseUpEventListerAdded","clear","getCurrentPosition","shouldAlwaysApplyDefaultFormat","undoSnapshotService","createSnapshots","canMoveCurrentSnapshot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","computedColor","Color","colorLab","newLValue","alpha","_slice","skippedModels","hashedModelKeys","sort","limiters","valpha","newArr","zeroArray","hashedKeys","limit","freeze","getset","channel","modifier","maxfn","assertArray","arr","toJSON","places","percentString","percent","unitArray","unitObject","Number","toFixed","roundTo","roundToPlace","red","green","blue","saturationl","lightness","saturationv","white","wblack","cyan","magenta","yellow","black","rgbNumber","luminosity","lum","chan","contrast","color2","lum1","lum2","contrastRatio","isDark","isLight","negate","lighten","darken","saturate","desaturate","whiten","blacken","grayscale","fade","opaquer","rotate","degrees","mix","mixinColor","weight","color1","w1","w2","newAlpha","raw","colorNames","swizzle","reverseNames","cs","clamp","hexDouble","hexAlpha","i2","rgba","hsla","hwba","isArrayish","results","len","fn","getOwnPropertyDescriptor","constructor","conversions","route","fromModel","routes","toModel","wrappedFn","conversion","wrapRounded","wrapRaw","deriveBFS","graph","models","buildGraph","queue","adjacents","adjacent","wrapConversion","cur","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","onBlur","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","isPureLiNode","childNode","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listAttribute","getStyleValue","listProps","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","FeatureToOperationMap","DefaultOptions","minRotateDeg","imageSelector","rotateIconHTML","ImageEditHTMLMap","getCornerResizeHTML","getSideResizeHTML","getRotateHTML","getCropHTML","allowedOperations","setEditingImage","removeWrapper","updateWrapper","getImageWrapper","cropContainers","getEditElements","cropOverlays","rotateCenter","rotateHandle","isCropping","marginHorizontal","marginVertical","cropLeftPx","cropRightPx","cropTopPx","cropBottomPx","getPx","setSize","elementClass","doubleCheckResize","cosAngle","adjustedDistance","MAX_SAFE_INTEGER","rotateGap","ROTATE_GAP","rotateTop","ROTATE_SIZE","clearDndHelpers","matchesSelector","operationOrSelect","selectImage","lastSrc","createWrapper","dndHelpers","createDndHelpers","verticalAlign","rotateHandleBackColor","htmlData","thisOperation","dragAndDrop","commonContext","helper","imageWidth","imageHeight","translate","toDataURL","ROTATION","sw","nw","ne","se","Cropper","dx","dy","widthPercent","heightPercent","fullWidth","fullHeight","newLeft","crop","newRight","newTop","newBottom","basePercentage","deltaValue","fullValue","currentPercentage","minValue","maxValue","getCropHandleHTML","layer","getCropHandleHTMLInternal","overlayHTML","containerHTML","getCropHTMLInternal","trigger","onSubmit","onMouseDown","addDocumentEvents","initX","initY","initValue","onMouseMove","removeDocumentEvents","onDragEnd","DEG_PER_RAD","DEFAULT_ROTATE_HANDLE_HEIGHT","Rotator","newX","newY","angleInRad","angleInDeg","getRotateIconHTML","stroke","handleLeft","selectionBorderColor","forcePreserveRatio","resizableImageSelector","showResizeHandle","hideResizeHandle","selectImageAfterUnSelect","ImageEdit","ImageResize","ESC_CHAR_CODE","LEFT_ARROW_CHAR_CODE","UP_ARROW_CHAR_CODE","RIGHT_ARROW_CHAR_CODE","DOWN_ARROW_CHAR_CODE","DELETE_CHAR_CODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","getHorizontalDistance","toLeft","tableRectMap","currentCellsToResize","nextCellsToResize","resizingState","insertingState","onMouseOutInserter","setCurrentInsertTd","cacheRects","setCurrentTable","isRTL","setTableResizer","tdRect","normalizeRect","verticalInserterTd","preTd","previousElementSibling","setCurrentTd","buttons","horizontalInserterTd","insertTd","currentInsertTd","startResizingTable","resizingVtable","currentTableVerticalBorder","currentTableHorizontalBorder","startResizeCells","startHorizontalResizeCells","currentTd","startVerticalResizeCells","frameAnimateResizeCells","resizeCells","resizeTable","mouseX","mouseY","ratioX","ratioY","shouldResizeX","shouldResizeY","wordBreak","resizeRows","canResizeColumns","resizeColumns","isShiftPressed","endResizeCells","setupResizerContainer","onMouseMoveDisposer","removeResizerContainer","resizerContainer","tableResizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","inserterColor","outerDivStyle","HORIZONTAL_INSERTER","VERTICAL_INSERTER","resizerPosX","horizontalResizer","verticalResizer","createCellsResizer","hasChildNodes","tableResizer","createTableResizer","TABLE_RESIZER_LENGTH","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 105);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\n\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\n\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\n\nexport { default as extractClipboardEvent } from './clipboard/extractClipboardEvent';\nexport { default as extractClipboardItems } from './clipboard/extractClipboardItems';\nexport { default as extractClipboardItemsForIE } from './clipboard/extractClipboardItemsForIE';\n\nexport { default as arrayPush } from './utils/arrayPush';\nexport { default as applyTextStyle } from './utils/applyTextStyle';\nexport { Browser, getBrowserInfo } from './utils/Browser';\nexport { default as applyFormat } from './utils/applyFormat';\nexport { default as changeElementTag } from './utils/changeElementTag';\nexport { default as collapseNodes } from './utils/collapseNodes';\nexport { default as contains } from './utils/contains';\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\nexport { default as fromHtml } from './utils/fromHtml';\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\nexport {\n    default as getPendableFormatState,\n    PendableFormatCommandMap,\n    PendableFormatNames,\n} from './utils/getPendableFormatState';\nexport { default as getTagOfNode } from './utils/getTagOfNode';\nexport { default as isBlockElement } from './utils/isBlockElement';\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\nexport { default as matchLink } from './utils/matchLink';\nexport { default as queryElements } from './utils/queryElements';\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\nexport { default as unwrap } from './utils/unwrap';\nexport { default as wrap } from './utils/wrap';\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\nexport { default as getTextContent } from './utils/getTextContent';\nexport { default as splitTextNode } from './utils/splitTextNode';\nexport { default as normalizeRect } from './utils/normalizeRect';\nexport { default as toArray } from './utils/toArray';\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\nexport { default as readFile } from './utils/readFile';\nexport { default as getInnerHTML } from './utils/getInnerHTML';\nexport { default as setColor } from './utils/setColor';\nexport { default as matchesSelector } from './utils/matchesSelector';\nexport { default as adjustInsertPosition } from './utils/adjustInsertPosition';\nexport { default as createElement, KnownCreateElementData } from './utils/createElement';\nexport { default as moveChildNodes } from './utils/moveChildNodes';\n\nexport { default as VTable } from './table/VTable';\nexport { default as VList } from './list/VList';\nexport { default as VListItem } from './list/VListItem';\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\nexport { default as VListChain } from './list/VListChain';\n\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\n\nexport { default as Position } from './selection/Position';\nexport { default as createRange } from './selection/createRange';\nexport { default as getPositionRect } from './selection/getPositionRect';\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\nexport { default as getSelectionPath } from './selection/getSelectionPath';\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\n\nexport { default as addSnapshot } from './snapshots/addSnapshot';\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\nexport {\n    default as moveCurrentSnapshot,\n    moveCurrentSnapsnot,\n} from './snapshots/moveCurrentSnapshot';\nexport { default as createSnapshots } from './snapshots/createSnapshots';\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\n\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\n\nexport { default as commitEntity } from './entity/commitEntity';\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\nexport { default as getEntitySelector } from './entity/getEntitySelector';\n\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\nexport { default as isModifierKey } from './event/isModifierKey';\nexport { default as isCharacterValue } from './event/isCharacterValue';\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\n\nexport { default as getStyles } from './style/getStyles';\nexport { default as setStyles } from './style/setStyles';\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * @internal Export for test only\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: any,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is inside container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is inside container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the position, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: DataTransferItemList): DataTransferItem[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitrary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancestor\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { createElement } from 'roosterjs-editor-dom';\r\nimport { CreateElementData, KnownCreateElementDataIndex } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * @deprecated\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(\r\n    nodes: Node | Node[],\r\n    wrapper?: CreateElementData | KnownCreateElementDataIndex\r\n): HTMLElement;\r\n\r\nexport default function wrap(\r\n    nodes: Node | Node[],\r\n    wrapper?: string | HTMLElement | CreateElementData | KnownCreateElementDataIndex\r\n): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!wrapper) {\r\n        wrapper = 'div';\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n\r\n        if (typeof wrapper === 'string') {\r\n            wrapper = /^\\w+$/.test(wrapper)\r\n                ? document.createElement(wrapper)\r\n                : (fromHtml(wrapper, document)[0] as HTMLElement); // This will be removed in next major release\r\n        } else {\r\n            wrapper = createElement(wrapper, document) as HTMLElement;\r\n        }\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: ParentNode,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ancestor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start through end after splitting\r\n * False to disallow split parent\r\n * @returns When canSplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treatSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport matchesSelector from './matchesSelector';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (element && element != root && !matchesSelector(element, selector)) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLF_SPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node can be skipped.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLF_SPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only meaningless children is meaningless,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those meaningless nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system information of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import contains from '../utils/contains';\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\nimport { ChangeSource, IEditor, NodePosition, Region } from 'roosterjs-editor-types';\nimport { VListChain } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: IEditor,\n    callback: (\n        region: Region,\n        start: NodePosition,\n        end: NodePosition,\n        chains: VListChain[]\n    ) => void,\n    beforeRunCallback?: () => boolean\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        if (!beforeRunCallback || beforeRunCallback()) {\n            const regions = editor.getSelectedRegions();\n            const chains = VListChain.createListChains(regions, start?.node);\n            regions.forEach(region => callback(region, start, end, chains));\n            experimentCommitListChains(editor, chains);\n        }\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meaning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the trimming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the other half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be represented by a single html node.\r\n * This serves as base for most inline element as it contains most implementation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themselves for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport moveChildNodes from './moveChildNodes';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    moveChildNodes(newElement, element);\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","/**\n * Replace all child nodes of the given target node to the child nodes of source node.\n * @param target Target node, all child nodes of this node will be removed if keepExistingChildren is not set to true\n * @param source (Optional) source node, all child nodes of this node will be move to target node\n * @param keepExistingChildren (Optional) When set to true, all existing child nodes of target will be kept\n */\nexport default function moveChildNodes(\n    target: Node,\n    source?: Node,\n    keepExistingChildren?: boolean\n) {\n    if (!target) {\n        return;\n    }\n\n    while (!keepExistingChildren && target.firstChild) {\n        target.removeChild(target.firstChild);\n    }\n\n    while (source?.firstChild) {\n        target.appendChild(source.firstChild);\n    }\n}\n","import { Browser } from './Browser';\nimport { CreateElementData, KnownCreateElementDataIndex } from 'roosterjs-editor-types';\n\nexport const KnownCreateElementData: Record<KnownCreateElementDataIndex, CreateElementData> = {\n    [KnownCreateElementDataIndex.None]: null,\n\n    // Edge can sometimes lose current format when Enter to new line.\n    // So here we add an extra SPAN for Edge to workaround this bug\n    [KnownCreateElementDataIndex.EmptyLine]: Browser.isEdge\n        ? { tag: 'div', children: [{ tag: 'span', children: [{ tag: 'br' }] }] }\n        : { tag: 'div', children: [{ tag: 'br' }] },\n    [KnownCreateElementDataIndex.BlockquoteWrapper]: {\n        tag: 'blockquote',\n        style: 'margin-top:0;margin-bottom:0',\n    },\n    [KnownCreateElementDataIndex.CopyPasteTempDiv]: {\n        tag: 'div',\n        style:\n            'width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text',\n        attributes: {\n            contenteditable: 'true',\n        },\n    },\n    [KnownCreateElementDataIndex.BlockListItem]: { tag: 'li', style: 'display:block' },\n    [KnownCreateElementDataIndex.ContextMenuWrapper]: {\n        tag: 'div',\n        style: 'position: fixed; width: 0; height: 0',\n    },\n    [KnownCreateElementDataIndex.ImageEditWrapper]: {\n        tag: 'div',\n        style: 'width:100%;height:100%;position:relative;overflow:hidden',\n    },\n    [KnownCreateElementDataIndex.TableHorizontalResizer]: {\n        tag: 'div',\n        style: 'position: fixed; cursor: row-resize; user-select: none',\n    },\n    [KnownCreateElementDataIndex.TableVerticalResizer]: {\n        tag: 'div',\n        style: 'position: fixed; cursor: col-resize; user-select: none',\n    },\n    [KnownCreateElementDataIndex.TableResizerLTR]: {\n        tag: 'div',\n        style: 'position: fixed; cursor: nw-resize; user-select: none; border: 1px solid #808080',\n    },\n    [KnownCreateElementDataIndex.TableResizerRTL]: {\n        tag: 'div',\n        style: 'position: fixed; cursor: ne-resize; user-select: none; border: 1px solid #808080',\n    },\n};\n\nexport default function createElement(\n    elementData: CreateElementData | KnownCreateElementDataIndex,\n    document: Document\n): Element {\n    if (typeof elementData == 'number') {\n        elementData = KnownCreateElementData[elementData];\n    }\n\n    if (!elementData || !elementData.tag) {\n        return null;\n    }\n\n    const { tag, namespace, className, style, dataset, attributes, children } = elementData;\n    const result = namespace\n        ? document.createElementNS(namespace, tag)\n        : document.createElement(tag);\n\n    if (style) {\n        result.setAttribute('style', style);\n    }\n\n    if (className) {\n        result.className = className;\n    }\n\n    if (dataset && result instanceof HTMLElement) {\n        Object.keys(dataset).forEach(datasetName => {\n            result.dataset[datasetName] = dataset[datasetName];\n        });\n    }\n\n    if (attributes) {\n        Object.keys(attributes).forEach(attrName => {\n            result.setAttribute(attrName, attributes[attrName]);\n        });\n    }\n\n    if (children) {\n        children.forEach(child => {\n            if (typeof child === 'string') {\n                result.appendChild(document.createTextNode(child));\n            } else if (child) {\n                result.appendChild(createElement(child, document));\n            }\n        });\n    }\n\n    return result;\n}\n","import checkEditInfoState, { ImageEditInfoState } from './checkEditInfoState';\nimport ImageEditInfo, { IMAGE_EDIT_INFO_NAME } from '../types/ImageEditInfo';\n\n/**\n * @internal\n * Get image edit info from an image. If the image doesn't have edit info, create one from this image.\n * When create new edit info, it will have width/height set to the image's current client width/height, and\n * natural width/height set to the image's natural width/height, src set to its current src, and all\n * other fields set to 0.\n * @param image The image to get edit info from\n */\nexport default function getEditInfoFromImage(image: HTMLImageElement): ImageEditInfo {\n    const obj = safeParseJSON(image?.dataset[IMAGE_EDIT_INFO_NAME]) as ImageEditInfo;\n    return checkEditInfoState(obj) == ImageEditInfoState.Invalid ? getInitialEditInfo(image) : obj;\n}\n\nfunction getInitialEditInfo(image: HTMLImageElement): ImageEditInfo {\n    return {\n        src: image.src,\n        widthPx: image.clientWidth,\n        heightPx: image.clientHeight,\n        naturalWidth: image.naturalWidth,\n        naturalHeight: image.naturalHeight,\n        leftPercent: 0,\n        rightPercent: 0,\n        topPercent: 0,\n        bottomPercent: 0,\n        angleRad: 0,\n    };\n}\n\nfunction safeParseJSON(json: string): any {\n    try {\n        return JSON.parse(json);\n    } catch {\n        return null;\n    }\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLET_AGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLET_AGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\n * Read a file object and invoke a callback function with the data url of this file\n * @param file The file to read\n * @param callback the callback to invoke with data url of the file.\n * If fail to read, dataUrl will be null\n */\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\n    if (file && callback) {\n        const reader = new FileReader();\n        reader.onload = () => {\n            callback(reader.result as string);\n        };\n        reader.onerror = () => {\n            callback(null);\n        };\n        reader.readAsDataURL(file);\n    }\n}\n","/**\n * A type-safe wrapper for Array.prototype.push.apply()\n * @param mainArray The main array to push items into\n * @param itemsArray The items to push to main array\n */\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\n    Array.prototype.push.apply(mainArray, itemsArray);\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    public readonly items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embedded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embedded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get list number of the last item in this VList.\n     * If there is no order list item, result will be undefined\n     */\n    getLastItemNumber(): number | undefined {\n        const start = getStart(this.rootList);\n\n        return start === undefined\n            ? start\n            : start -\n                  1 +\n                  this.items.filter(\n                      item =>\n                          item.getListType() == ListType.Ordered &&\n                          item.getLevel() == 1 &&\n                          !item.isDummy()\n                  ).length;\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const doc = this.rootList.ownerDocument;\n        const listStack: Node[] = [doc.createDocumentFragment()];\n        const placeholder = doc.createTextNode('');\n        let start = getStart(this.rootList) || 1;\n        let lastList: Node;\n\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\n\n        this.items.forEach(item => {\n            item.writeBack(listStack, this.rootList);\n            const topList = listStack[1];\n\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\n                if (lastList != topList) {\n                    if (start == 1) {\n                        topList.removeAttribute('start');\n                    } else {\n                        topList.start = start;\n                    }\n                }\n\n                if (item.getLevel() == 1) {\n                    start++;\n                }\n            }\n\n            lastList = topList;\n        });\n\n        // Restore the content to the position of placeholder\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation): void;\n\n    /**\n     * Outdent the give range of this list\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param indentation Specify to outdent\n     * @param softOutdent (Optional) True to make the item to by dummy (no bullet or number) if the item is not dummy,\n     * otherwise outdent the item\n     */\n    setIndentation(\n        start: NodePosition,\n        end: NodePosition,\n        indentation: Indentation.Decrease,\n        softOutdent?: boolean\n    ): void;\n\n    setIndentation(\n        start: NodePosition,\n        end: NodePosition,\n        indentation: Indentation,\n        softOutdent?: boolean\n    ) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease\n                ? softOutdent && !item.isDummy()\n                    ? item.setIsDummy(true /*isDummy*/)\n                    : item.outdent()\n                : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        const nodeTag = getTagOfNode(node);\n\n        // Change DIV tag to SPAN. Otherwise we cannot create new list item by Enter key in Safari\n        if (nodeTag == 'DIV') {\n            node = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag != 'LI') {\n            node = wrap(node, 'LI');\n        }\n\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n        const items = toArray(list.childNodes);\n\n        items.forEach(item => {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        });\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { Region, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get the selection range in the given region.\n * The original range can cover multiple regions, this function will narrow the original selection\n * of a region into current region\n * @param regionBase The region to get range from\n */\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\n    if (!regionBase) {\n        return null;\n    }\n\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\n\n    if (!isRegion(regionBase)) {\n        return regionRange;\n    } else if (regionRange) {\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            return createRange(start, end);\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\n    const region = regionBase as Region;\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\n}\n","/**\n * Get CSS styles of a given element in name-value pair format\n * @param element The element to get styles from\n */\nexport default function getStyles(element: HTMLElement): Record<string, string> {\n    const result: Record<string, string> = {};\n    const style = element?.getAttribute('style') || '';\n    style.split(';').forEach(pair => {\n        const valueIndex = pair.indexOf(':');\n        const name = pair.slice(0, valueIndex);\n        const value = pair.slice(valueIndex + 1);\n        if (name && value) {\n            result[name.trim()] = value.trim();\n        }\n    });\n    return result;\n}\n","/**\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\n * @param element The element to set styles\n * @param styles The styles to set, in name-value pair format\n */\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\n    if (element) {\n        const style = Object.keys(styles || {})\n            .map(name => {\n                let value = styles[name];\n                name = name ? name.trim() : null;\n                value = value ? value.trim() : null;\n                return name && value ? `${name}:${value}` : null;\n            })\n            .filter(x => x)\n            .join(';');\n        if (style) {\n            element.setAttribute('style', style);\n        } else {\n            element.removeAttribute('style');\n        }\n    }\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { IMAGE_EDIT_INFO_NAME } from '../types/ImageEditInfo';\n\n/**\n * @internal\n * Delete edit info of an image if any\n * @param image The image to delete edit info from\n */\nexport default function deleteEditInfo(image: HTMLImageElement) {\n    if (image) {\n        delete image.dataset[IMAGE_EDIT_INFO_NAME];\n    }\n}\n","export const IMAGE_EDIT_INFO_NAME = 'roosterEditInfo';\n\n/**\n * @internal\n * Edit info for inline image resize\n */\nexport interface ResizeInfo {\n    /**\n     * Width after resize, in px.\n     * If image is cropped, this is the width of visible part\n     * If image is rotated, this is the width before rotation\n     * @default clientWidth of the image\n     */\n    widthPx: number;\n\n    /**\n     * Height after resize, in px.\n     * If image is cropped, this is the height of visible part\n     * If image is rotated, this is the height before rotation\n     * @default clientHeight of the image\n     */\n    heightPx: number;\n}\n\n/**\n * @internal\n * Edit info for inline image crop\n */\nexport interface CropInfo {\n    /**\n     * Left cropped percentage. Rotation or resizing won't impact this percentage value\n     * @default 0\n     */\n    leftPercent: number;\n\n    /**\n     * Right cropped percentage. Rotation or resizing won't impact this percentage value\n     * @default 0\n     */\n    rightPercent: number;\n\n    /**\n     * Top cropped percentage. Rotation or resizing won't impact this percentage value\n     * @default 0\n     */\n    topPercent: number;\n\n    /**\n     * Bottom cropped percentage. Rotation or resizing won't impact this percentage value\n     * @default 0\n     */\n    bottomPercent: number;\n}\n\n/**\n * @internal\n * Edit info for inline image rotate\n */\nexport interface RotateInfo {\n    /**\n     * Rotated angle of inline image, in radian. Cropping or resizing won't impact this percentage value\n     * @default 0\n     */\n    angleRad: number;\n}\n\n/**\n * @internal\n * Edit info for inline image editing\n */\nexport default interface ImageEditInfo extends ResizeInfo, CropInfo, RotateInfo {\n    /**\n     * Original src of the image. This value will not be changed when edit image. We can always use it\n     * to get the original image so that all editing operation will be on top of the original image.\n     */\n    readonly src: string;\n\n    /**\n     * Natural width of the original image (specified by the src field, may not be the current edited image)\n     */\n    readonly naturalWidth: number;\n\n    /**\n     * Natural height of the original image (specified by the src field, may not be the current edited image)\n     */\n    readonly naturalHeight: number;\n}\n","import GeneratedImageSize from '../types/GeneratedImageSize';\nimport ImageEditInfo from '../types/ImageEditInfo';\n\n/**\n * @internal\n * Calculate the target size of an image.\n * For image that is not rotated, target size is the same with resizing/cropping size.\n * For image that is rotated, target size is calculated from resizing/cropping size and its rotate angle\n * Say an image is resized to 100w*100h, cropped 25% on each side, then rotated 45deg, so that cropped size\n * will be (both height and width) 100*(1-0.25-0,25) = 50px, then final image size will be 50*sqrt(2) = 71px\n * @param editInfo The edit info to calculate size from\n * @param beforeCrop True to calculate the full size of original image before crop, false to calculate the size\n * after crop\n * @returns A GeneratedImageSize object which contains original, visible and target target width and height of the image\n */\nexport default function getGeneratedImageSize(\n    editInfo: ImageEditInfo,\n    beforeCrop?: boolean\n): GeneratedImageSize {\n    const {\n        widthPx: width,\n        heightPx: height,\n        angleRad: angle,\n        leftPercent: left,\n        rightPercent: right,\n        topPercent: top,\n        bottomPercent: bottom,\n    } = editInfo;\n\n    // Original image size before crop and rotate\n    const originalWidth = width / (1 - left - right);\n    const originalHeight = height / (1 - top - bottom);\n\n    // Visible size\n    const visibleWidth = beforeCrop ? originalWidth : width;\n    const visibleHeight = beforeCrop ? originalHeight : height;\n\n    // Target size after crop and rotate\n    const targetWidth =\n        Math.abs(visibleWidth * Math.cos(angle)) + Math.abs(visibleHeight * Math.sin(angle));\n    const targetHeight =\n        Math.abs(visibleWidth * Math.sin(angle)) + Math.abs(visibleHeight * Math.cos(angle));\n\n    return {\n        targetWidth,\n        targetHeight,\n        originalWidth,\n        originalHeight,\n        visibleWidth,\n        visibleHeight,\n    };\n}\n","export * from './plugins/ContentEdit/index';\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\nimport { CursorFeatures } from './features/cursorFeatures';\nimport { EntityFeatures } from './features/entityFeatures';\nimport { ListFeatures } from './features/listFeatures';\nimport { MarkdownFeatures } from './features/markdownFeatures';\nimport { QuoteFeatures } from './features/quoteFeatures';\nimport { ShortcutFeatures } from './features/shortcutFeatures';\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\nimport { TableFeatures } from './features/tableFeatures';\nimport {\n    BuildInEditFeature,\n    ContentEditFeatureSettings,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\nconst allFeatures = {\n    ...ListFeatures,\n    ...QuoteFeatures,\n    ...TableFeatures,\n    ...StructuredNodeFeatures,\n    ...AutoLinkFeatures,\n    ...ShortcutFeatures,\n    ...CursorFeatures,\n    ...MarkdownFeatures,\n    ...EntityFeatures,\n};\n\n/**\n * Get all content edit features provided by roosterjs\n */\nexport default function getAllFeatures(): Record<\n    keyof ContentEditFeatureSettings,\n    BuildInEditFeature<PluginEvent>\n> {\n    return allFeatures;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be represented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidentally create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have children\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Type definition of HTMLElement interface for IE\n */\ninterface HTMLElementForIE extends HTMLElement {\n    /**\n     * IE implementation of Element.matches() function\n     *\n     */\n    msMatchesSelector: (selector: string) => boolean;\n}\n\n/**\n * A wrapper function of Element.matches\n * @param element The element to match\n * @param selector The selector to match\n */\nexport default function matchesSelector(element: Node, selector: string): boolean {\n    return (\n        safeInstanceOf(element, 'HTMLElement') &&\n        (element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(element, selector)\n    );\n}\n","import toArray from './toArray';\r\n\r\n/**\r\n * @deprecated\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import readFile from '../utils/readFile';\nimport { Browser } from '../utils/Browser';\nimport {\n    ClipboardData,\n    ContentType,\n    ContentTypePrefix,\n    EdgeLinkPreview,\n    ExtractClipboardItemsOption,\n} from 'roosterjs-editor-types';\n\n// HTML header to indicate where is the HTML content started from.\n// Sample header:\n// Version:0.9\n// StartHTML:71\n// EndHTML:170\n// StartFragment:140\n// EndFragment:160\n// StartSelection:140\n// EndSelection:160\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\nconst OTHER_TEXT_TYPE = ContentTypePrefix.Text + '*';\nconst EDGE_LINK_PREVIEW = 'link-preview';\nconst ContentHandlers: {\n    [contentType: string]: (data: ClipboardData, value: string, type: string) => void;\n} = {\n    [ContentType.HTML]: (data, value) =>\n        (data.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value),\n    [ContentType.PlainText]: (data, value) => (data.text = value),\n    [OTHER_TEXT_TYPE]: (data, value, type) => (data.customValues[type] = value),\n};\n\n/**\n * Extract clipboard items to be a ClipboardData object for IE\n * @param items The clipboard items retrieve from a DataTransfer object\n * @param callback Callback function when data is ready\n * @returns An object with the following properties:\n *  types: Available types from the clipboard event\n *  text: Plain text from the clipboard event\n *  image: Image file from the clipboard event\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\n *   not supported by browser.\n */\nexport default function extractClipboardItems(\n    items: DataTransferItem[],\n    options?: ExtractClipboardItemsOption\n): Promise<ClipboardData> {\n    const data: ClipboardData = {\n        types: [],\n        text: '',\n        image: null,\n        rawHtml: null,\n        customValues: {},\n    };\n\n    const contentHandlers = { ...ContentHandlers };\n\n    if (options?.allowLinkPreview) {\n        contentHandlers[ContentTypePrefix.Text + EDGE_LINK_PREVIEW] = tryParseLinkPreview;\n    }\n\n    return Promise.all(\n        (items || []).map(item => {\n            const type = item.type;\n\n            if (type.indexOf(ContentTypePrefix.Image) == 0 && !data.image) {\n                data.types.push(type);\n                data.image = item.getAsFile();\n                return new Promise(resolve => {\n                    readFile(data.image, dataUrl => {\n                        data.imageDataUri = dataUrl;\n                        resolve();\n                    });\n                });\n            } else {\n                const customType = getAllowedCustomType(type, options?.allowedCustomPasteType);\n                const handler =\n                    contentHandlers[type] || (customType ? contentHandlers[OTHER_TEXT_TYPE] : null);\n                return new Promise(resolve =>\n                    handler\n                        ? item.getAsString(value => {\n                              data.types.push(type);\n                              handler(data, value, customType);\n                              resolve();\n                          })\n                        : resolve()\n                );\n            }\n        })\n    ).then(() => data);\n}\n\n/**\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\n * So we need to remove it in our code\n * @param html The HTML string got from clipboard\n */\nfunction workaroundForEdge(html: string) {\n    const headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\n\n    if (headerValues?.length == 3) {\n        const start = parseInt(headerValues[1]);\n        const end = parseInt(headerValues[2]);\n        if (start > 0 && end > start) {\n            html = html.substring(start, end);\n        }\n    }\n\n    return html;\n}\n\nfunction tryParseLinkPreview(data: ClipboardData, value: string) {\n    try {\n        data.customValues[EDGE_LINK_PREVIEW] = value;\n        data.linkPreview = JSON.parse(value) as EdgeLinkPreview;\n    } catch {}\n}\n\nfunction getAllowedCustomType(type: string, allowedCustomPasteType: string[]) {\n    let textType =\n        type.indexOf(ContentTypePrefix.Text) == 0\n            ? type.substr(ContentTypePrefix.Text.length)\n            : null;\n    return textType && allowedCustomPasteType?.indexOf(textType) >= 0 ? textType : null;\n}\n","import readFile from '../utils/readFile';\nimport toArray from '../utils/toArray';\nimport {\n    ClipboardData,\n    ContentTypePrefix,\n    ExtractClipboardItemsForIEOptions,\n} from 'roosterjs-editor-types';\n\n/**\n * Extract clipboard items to be a ClipboardData object for IE\n * @param dataTransfer The clipboard items retrieve from a DataTransfer object\n * @param callback Callback function when data is ready\n * @returns An object with the following properties:\n *  types: Available types from the clipboard event\n *  text: Plain text from the clipboard event\n *  image: Image file from the clipboard event\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\n *   not supported by browser.\n */\nexport default function extractClipboardItemsForIE(\n    dataTransfer: DataTransfer,\n    callback: (data: ClipboardData) => void,\n    options: ExtractClipboardItemsForIEOptions\n) {\n    const clipboardData: ClipboardData = {\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\n        text: dataTransfer.getData('text'),\n        image: null,\n        rawHtml: null,\n        customValues: {},\n    };\n\n    for (let i = 0; i < (dataTransfer.files ? dataTransfer.files.length : 0); i++) {\n        let file = dataTransfer.files.item(i);\n        if (file.type?.indexOf(ContentTypePrefix.Image) == 0) {\n            clipboardData.image = file;\n            break;\n        }\n    }\n\n    const nextStep = () => {\n        if (clipboardData.image) {\n            readFile(clipboardData.image, dataUrl => {\n                clipboardData.imageDataUri = dataUrl;\n                callback(clipboardData);\n            });\n        } else {\n            callback(clipboardData);\n        }\n    };\n\n    if (options?.getTempDiv && options?.removeTempDiv) {\n        const div = options.getTempDiv();\n        div.contentEditable = 'true';\n        div.innerHTML = '';\n        div.focus();\n        div.ownerDocument.defaultView.setTimeout(() => {\n            clipboardData.rawHtml = div.innerHTML;\n            options.removeTempDiv(div);\n            nextStep();\n        }, 0);\n    } else {\n        clipboardData.rawHtml = undefined;\n        nextStep();\n    }\n}\n","import { DarkModeDatasetNames, ModeIndependentColor } from 'roosterjs-editor-types';\n\nexport default function setColor(\n    element: HTMLElement,\n    color: string | ModeIndependentColor,\n    isBackgroundColor: boolean,\n    isDarkMode?: boolean\n) {\n    const colorString = typeof color === 'string' ? color.trim() : '';\n    const modeIndependentColor = typeof color === 'string' ? null : color;\n\n    if (colorString || modeIndependentColor) {\n        element.style.setProperty(\n            isBackgroundColor ? 'background-color' : 'color',\n            (isDarkMode\n                ? modeIndependentColor?.darkModeColor\n                : modeIndependentColor?.lightModeColor) || colorString\n        );\n\n        if (element.dataset) {\n            const dataSetName = isBackgroundColor\n                ? DarkModeDatasetNames.OriginalStyleBackgroundColor\n                : DarkModeDatasetNames.OriginalStyleColor;\n            if (!isDarkMode) {\n                delete element.dataset[dataSetName];\n            } else if (modeIndependentColor) {\n                element.dataset[dataSetName] = modeIndependentColor.lightModeColor;\n            }\n        }\n    }\n}\n","import safeInstanceOf from '../utils/safeInstanceOf';\n\n/**\n * Get innerHTML of the given node\n * @param node The DOM node to get innerHTML from\n */\nexport default function getInnerHTML(node: HTMLElement | DocumentFragment) {\n    if (safeInstanceOf(node, 'HTMLElement')) {\n        return node.innerHTML;\n    } else if (node) {\n        const tempNode = node.ownerDocument.createElement('span');\n        tempNode.appendChild(node.cloneNode(true /*deep*/));\n        return tempNode.innerHTML;\n    } else {\n        return '';\n    }\n}\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport moveChildNodes from '../utils/moveChildNodes';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { KnownCreateElementDataIndex, ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n    private node: HTMLLIElement;\n    private dummy: boolean;\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represents list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        this.node = safeInstanceOf(node, 'HTMLLIElement')\n            ? node\n            : (wrap(node, KnownCreateElementDataIndex.BlockListItem) as HTMLLIElement);\n        const display = this.node.style.display;\n\n        this.dummy = display != 'list-item' && display != '';\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get the levels of this list item.\n     */\n    getLevel(): number {\n        return this.listTypes.length - 1;\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): HTMLLIElement {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treatSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is a dummy item.\n     * A dummy item is also represented by LI tag, but it won't render a bullet (for Unordered list) or a number (for Ordered list)\n     * normally it has CSS style display set to a value other than \"list-item\"\n     */\n    isDummy() {\n        return this.dummy;\n    }\n\n    /**\n     * @deprecated Always return false\n     */\n    isOrphanItem(): boolean {\n        return false;\n    }\n\n    /**\n     * @deprecated\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * @deprecated\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Set whether the item is a dummy item\n     * @param isDummy Whether the item is a dummy item\n     */\n    setIsDummy(isDummy: boolean) {\n        this.dummy = isDummy;\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     * @param originalRoot Original list root element. It will be reused when write back if possible\n     */\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const newList = createListElement(\n                listStack[0],\n                this.listTypes[nextLevel],\n                nextLevel,\n                originalRoot\n            );\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n        this.node.style.display = this.dummy ? 'block' : null;\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction createListElement(\n    newRoot: Node,\n    listType: ListType,\n    nextLevel: number,\n    originalRoot?: HTMLOListElement | HTMLUListElement\n): HTMLOListElement | HTMLUListElement {\n    const doc = newRoot.ownerDocument;\n    let result: HTMLOListElement | HTMLUListElement;\n\n    // Try to reuse the existing root element\n    // It can be reused when\n    // 1. Current list item is level 1 (top level), AND\n    // 2. Original root exists, AND\n    // 3. They have the same list type AND\n    // 4. The original root is not used yet\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\n        if (contains(newRoot, originalRoot)) {\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\n            (<HTMLOListElement>result).removeAttribute('id');\n        } else {\n            // Remove all child nodes, they will be added back later when write back other items\n            moveChildNodes(originalRoot);\n            result = originalRoot;\n        }\n    } else {\n        // Can't be reused, can't clone, let's create a new one\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n    }\n\n    if (listType == ListType.Ordered && nextLevel > 1) {\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\n    }\n\n    return result;\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport { RegionBase } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A type map from selector string to HTML element type\n */\nexport interface SelectorToTypeMap {\n    ol: HTMLOListElement;\n    ul: HTMLUListElement;\n    'ol,ul': HTMLOListElement | HTMLUListElement;\n}\n\n/**\n * @internal\n * Get Root list node from the given node within the given region\n * @param region Region to scope the search into\n * @param selector The selector to search\n * @param node The start node\n */\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\n    region: RegionBase,\n    selector: TSelector,\n    node: Node\n): SelectorToTypeMap[TSelector] {\n    let list =\n        region &&\n        (findClosestElementAncestor(\n            node,\n            region.rootNode,\n            selector\n        ) as SelectorToTypeMap[TSelector]);\n\n    if (list) {\n        let ancestor: SelectorToTypeMap[TSelector];\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                selector\n            ) as SelectorToTypeMap[TSelector])\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport createElement from '../utils/createElement';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport { BlockElement, KnownCreateElementDataIndex, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Get all block elements covered by the selection under this region\n * @param regionBase The region to get block elements from\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\n * any blocks in the region. Default value is false\n */\nexport default function getSelectedBlockElementsInRegion(\n    regionBase: RegionBase,\n    createBlockIfEmpty?: boolean\n): BlockElement[] {\n    const range = getSelectionRangeInRegion(regionBase);\n    let blocks: BlockElement[] = [];\n\n    if (range) {\n        const { rootNode, skipTags } = regionBase;\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n        for (\n            let block = traverser?.currentBlockElement;\n            !!block;\n            block = traverser.getNextBlockElement()\n        ) {\n            blocks.push(block);\n        }\n\n        // Remove meaningless nodes\n        blocks = blocks.filter(block => {\n            const startNode = block.getStartNode();\n            const endNode = block.getEndNode();\n\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\n                startNode.parentNode?.removeChild(startNode);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\n        const newNode = createElement(\n            KnownCreateElementDataIndex.EmptyLine,\n            regionBase.rootNode.ownerDocument\n        );\n        regionBase.rootNode.appendChild(newNode);\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created according to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these boundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child boundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContainer.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ancestor node under this region\n * @param region The region to collapse nodes in.\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\n * All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(\n    region: RegionBase,\n    nodesOrBlockElements: Node[] | BlockElement[]\n): Node[] {\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\n        return [];\n    }\n\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\n        ? <Node[]>nodesOrBlockElements\n        : [\n              nodesOrBlockElements[0].getStartNode(),\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\n          ];\n\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport contains from '../utils/contains';\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport setStyles from '../style/setStyles';\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\nimport { collapse } from '../utils/collapseNodes';\nimport { safeInstanceOf } from '..';\n\n/**\n * Merge a BlockElement of given node after another node\n * @param region Region to operate in\n * @param refNode The node to merge after\n * @param targetNode The node of target block element\n */\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\n    let block: BlockElement;\n\n    if (\n        !isNodeInRegion(region, refNode) ||\n        !isNodeInRegion(region, targetNode) ||\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\n        block.contains(refNode)\n    ) {\n        return;\n    }\n\n    const blockRoot = block.collapseToSingleElement();\n    const commonContainer = collapse(\n        region.rootNode,\n        blockRoot,\n        refNode,\n        false /*isStart*/,\n        true /*canSplitParent*/\n    );\n\n    // Copy styles of parent nodes into blockRoot\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\n        const parent = node.parentNode;\n        if (safeInstanceOf(parent, 'HTMLElement')) {\n            const styles = {\n                ...(getPredefinedCssForElement(parent) || {}),\n                ...getStyles(parent),\n                ...getStyles(blockRoot),\n            };\n            setStyles(blockRoot, styles);\n        }\n        node = parent;\n    }\n\n    let nodeToRemove: Node = null;\n    let nodeToMerge =\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\n            ? blockRoot.firstChild\n            : changeElementTag(blockRoot, 'SPAN');\n\n    // Remove empty node\n    for (\n        let node: Node = nodeToMerge;\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\n        node = node.parentNode\n    ) {\n        // If the only child is the one which is about to be removed, this node should also be removed\n        nodeToRemove = node.parentNode;\n    }\n\n    // Finally, merge blocks, and remove empty nodes\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\n}\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\n\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\n    B: {\n        'font-weight': 'bold',\n    },\n    EM: {\n        'font-style': 'italic',\n    },\n    I: {\n        'font-style': 'italic',\n    },\n    U: {\n        'text-decoration': 'underline',\n    },\n    P: {\n        'margin-top': '1em',\n        'margin-bottom': '1em',\n    },\n    PRE: {\n        'white-space': 'pre',\n    },\n    S: {\n        'text-decoration': 'line-through',\n    },\n    STRIKE: {\n        'text-decoration': 'line-through',\n    },\n    SUB: {\n        'vertical-align': 'sub',\n        'font-size': 'smaller',\n    },\n    SUP: {\n        'vertical-align': 'super',\n        'font-size': 'smaller',\n    },\n};\n\n/**\n * @internal\n * Get a map for browser built-in CSS definations of elements\n */\nexport default function getPredefinedCssForElement(\n    element: HTMLElement,\n    additionalPredefinedCssForElement?: PredefinedCssMap\n): StringMap {\n    const tag = getTagOfNode(element);\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: Node, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indices into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: Node): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","const CTRL_CHAR_CODE = 'Control';\nconst ALT_CHAR_CODE = 'Alt';\nconst META_CHAR_CODE = 'Meta';\n\n/**\n * Returns true when the event was fired from a modifier key, otherwise false\n * @param event The keyboard event object\n */\nexport default function isModifierKey(event: KeyboardEvent): boolean {\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHAR_CODE;\n    const isAltKey = event.altKey || event.key === ALT_CHAR_CODE;\n    const isMetaKey = event.metaKey || event.key === META_CHAR_CODE;\n\n    return isCtrlKey || isAltKey || isMetaKey;\n}\n","import blockFormat from '../utils/blockFormat';\r\nimport execCommand from '../utils/execCommand';\r\nimport PartialInlineElement from 'roosterjs-editor-dom/lib/inlineElements/PartialInlineElement';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport {\r\n    ChangeSource,\r\n    ClearFormatMode,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * @param editor The editor instance\r\n * @returns if the current selection is composed of two or more block elements\r\n */\r\nfunction isMultiBlockSelection(editor: IEditor): boolean {\r\n    let transverser = editor.getSelectionTraverser();\r\n    let blockElement = transverser.currentBlockElement;\r\n    if (!blockElement) {\r\n        return false;\r\n    }\r\n\r\n    let nextBlockElement = transverser.getNextBlockElement();\r\n\r\n    //At least two blocks are selected\r\n    return !!nextBlockElement;\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Clear the format of the selected text or list of blocks\r\n * If the current selection is compose of multiple block elements then remove the text and struture format for all the selected blocks\r\n * If the current selection is compose of a partial inline element then only the text format is removed from the current selection\r\n * @param editor The editor instance\r\n */\r\nfunction clearAutoDetectFormat(editor: IEditor) {\r\n    const isMultiBlock = isMultiBlockSelection(editor);\r\n    if (!isMultiBlock) {\r\n        const transverser = editor.getSelectionTraverser();\r\n        const inlineElement = transverser.currentInlineElement;\r\n        const isPartial = inlineElement instanceof PartialInlineElement;\r\n        if (isPartial) {\r\n            clearFormat(editor);\r\n            return;\r\n        }\r\n    }\r\n    clearBlockFormat(editor);\r\n}\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nfunction clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearInlineFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n * @param formatType type of format to apply\r\n */\r\nexport default function clearFormat(\r\n    editor: IEditor,\r\n    formatType: ClearFormatMode = ClearFormatMode.Inline\r\n) {\r\n    switch (formatType) {\r\n        case ClearFormatMode.Inline:\r\n            clearInlineFormat(editor);\r\n            break;\r\n        case ClearFormatMode.Block:\r\n            clearBlockFormat(editor);\r\n            break;\r\n        default:\r\n            clearAutoDetectFormat(editor);\r\n    }\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Position, VListChain } from 'roosterjs-editor-dom';\n\n/**\n * Commit changes of all list changes when experiment features are allowed\n * @param editor The Editor object\n * @param chains List chains to commit\n */\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\n    if (chains?.length > 0) {\n        const range = editor.getSelectionRange();\n        const start = range && Position.getStart(range);\n        const end = range && Position.getEnd(range);\n        chains.forEach(chain => chain.commit());\n        editor.select(start, end);\n    }\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\nimport { setColor } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take effect\r\n * Alternatively, you can pass a @typedef ModeIndependentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        setColor(element, isInnerNode ? '' : color, true /*isBackground*/, editor.isDarkMode());\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\nimport { setColor } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndependentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        setColor(element, isInnerNode ? '' : color, false /*isBackground*/, editor.isDarkMode());\r\n    });\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\nimport { IEditor, ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function toggleListType(editor: IEditor, listType: ListType): void;\nexport default function toggleListType(\n    editor: IEditor,\n    listType: ListType.Ordered,\n    startNumber: number\n): void;\n\nexport default function toggleListType(editor: IEditor, listType: ListType, startNumber?: number) {\n    blockFormat(editor, (region, start, end, chains) => {\n        const chain =\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\n        const vList =\n            chain && start.equalTo(end)\n                ? chain.createVListAtBlock(\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\n                      startNumber\n                  )\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\n\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","import blockFormat from './blockFormat';\nimport { IEditor } from 'roosterjs-editor-types';\nimport {\n    collapseNodesInRegion,\n    getSelectedBlockElementsInRegion,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Toggle a tag at selection, if selection already contains elements of such tag,\n * the elements will be untagged and other elements will take no effect\n * @param editor The editor instance\n * @param wrapFunction  The wrap function\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\n * the loop for regions will be skipped\n */\nexport default function blockWrap(\n    editor: IEditor,\n    wrapFunction: (nodes: Node[]) => void,\n    beforeRunCallback: () => boolean\n): void {\n    blockFormat(\n        editor,\n        region => {\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\n            let nodes = collapseNodesInRegion(region, blocks);\n            if (nodes.length > 0) {\n                if (nodes.length == 1) {\n                    const NodeTag = getTagOfNode(nodes[0]);\n                    if (NodeTag == 'BR') {\n                        nodes = [wrap(nodes[0])];\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\n                        nodes = toArray(nodes[0].childNodes);\n                    }\n                }\n\n                while (\n                    nodes[0] &&\n                    isNodeInRegion(region, nodes[0].parentNode) &&\n                    nodes.some(node => getTagOfNode(node) == 'LI')\n                ) {\n                    nodes = [splitBalancedNodeRange(nodes)];\n                }\n\n                wrapFunction(nodes);\n            }\n        },\n        beforeRunCallback\n    );\n}\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Check if the editor has focus now\n * @param core The EditorCore object\n * @returns True if the editor has focus, otherwise false\n */\nexport const hasFocus: HasFocus = (core: EditorCore) => {\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\n    return (\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\n    );\n};\n","export { default as getDarkColor } from './utils/getDarkColor';\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","/* MIT license */\nvar cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","export * from './plugins/HyperLink/index';\n","export * from './plugins/Paste/index';\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface WordCustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty WordCustomData\n */\nexport function createCustomData(): WordCustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!wordCustomData.dict[id]) {\n                // First time dictionary creation\n                wordCustomData.dict[id] = {};\n            }\n            wordCustomData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\n        if (id != '') {\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = wordCustomData.nextNodeId.toString();\n        wordCustomData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFY_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","export * from './plugins/ImageEdit/index';\n","import checkEditInfoState, { ImageEditInfoState } from './checkEditInfoState';\nimport deleteEditInfo from './deleteEditInfo';\nimport generateDataURL from './generateDataURL';\nimport getEditInfoFromImage from './getEditInfoFromImage';\nimport getGeneratedImageSize from './getGeneratedImageSize';\nimport ImageEditInfo from '../types/ImageEditInfo';\nimport saveEditInfo from './saveEditInfo';\nimport { IEditor, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Apply changes from the edit info of an image, write result to the image\n * @param editor The editor object that contains the image\n * @param image The image to apply the change\n * @param editInfo Edit info that contains the changed information of the image\n * @param previousSrc Last src value of the image before the change was made\n * @returns True if the image is changed, otherwise false\n */\nexport default function applyChange(\n    editor: IEditor,\n    image: HTMLImageElement,\n    editInfo: ImageEditInfo,\n    previousSrc: string\n): boolean {\n    let newSrc = '';\n\n    const initEditInfo = getEditInfoFromImage(image);\n    const state = checkEditInfoState(editInfo, initEditInfo);\n\n    switch (state) {\n        case ImageEditInfoState.ResizeOnly:\n            // For resize only case, no need to generate a new image, just reuse the original one\n            newSrc = editInfo.src;\n            break;\n        case ImageEditInfoState.SameWithLast:\n            // For SameWithLast case, image may be resized but the content is still the same with last one,\n            // so no need to create a new image, but just reuse last one\n            newSrc = previousSrc;\n            break;\n        case ImageEditInfoState.FullyChanged:\n            // For other cases (cropped, rotated, ...) we need to create a new image to reflect the change\n            newSrc = generateDataURL(image, editInfo);\n            break;\n    }\n\n    const srcChanged = newSrc != previousSrc;\n\n    if (srcChanged) {\n        // If the src is changed, fire an EditImage event so that plugins knows that a new image is used, and can\n        // replace the new src with some other string and it will be used and set to the image\n        const event = editor.triggerPluginEvent(PluginEventType.EditImage, {\n            image: image,\n            originalSrc: editInfo.src,\n            previousSrc,\n            newSrc,\n        });\n        newSrc = event.newSrc;\n    }\n\n    if (newSrc == editInfo.src) {\n        // If newSrc is the same with original one, it means there is only size change, but no rotation, no cropping,\n        // so we don't need to keep edit info, we can delete it\n        deleteEditInfo(image);\n    } else {\n        // Otherwise, save the new edit info to the image so that next time when we edit the same image, we know\n        // the edit info\n        saveEditInfo(image, editInfo);\n    }\n\n    // Write back the change to image, and set its new size\n    const { targetWidth, targetHeight } = getGeneratedImageSize(editInfo);\n    image.src = newSrc;\n    image.style.width = targetWidth + 'px';\n    image.style.height = targetHeight + 'px';\n    image.width = targetWidth;\n    image.height = targetHeight;\n\n    return (\n        srcChanged ||\n        editInfo.widthPx != initEditInfo.widthPx ||\n        editInfo.heightPx != initEditInfo.heightPx\n    );\n}\n","import ImageEditInfo, { CropInfo, ResizeInfo, RotateInfo } from '../types/ImageEditInfo';\n\nconst RESIZE_KEYS: (keyof ResizeInfo)[] = ['widthPx', 'heightPx'];\nconst ROTATE_KEYS: (keyof RotateInfo)[] = ['angleRad'];\nconst CROP_KEYS: (keyof CropInfo)[] = [\n    'leftPercent',\n    'rightPercent',\n    'topPercent',\n    'bottomPercent',\n];\nconst ROTATE_CROP_KEYS: (keyof RotateInfo | keyof CropInfo)[] = [...ROTATE_KEYS, ...CROP_KEYS];\nconst ALL_KEYS = [...ROTATE_CROP_KEYS, ...RESIZE_KEYS];\n\n/**\n * State of an edit info object for image editing.\n * It is returned by checkEditInfoState() function\n */\nexport const enum ImageEditInfoState {\n    /**\n     * Invalid edit info. It means the given edit info object is either null,\n     * or not all its member are of correct type\n     */\n    Invalid,\n\n    /**\n     * The edit info shows that it is only potentially edited by resizing action.\n     * Image is not rotated or cropped, or event not changed at all.\n     */\n    ResizeOnly,\n\n    /**\n     * When compare with another edit info, this value can be returned when both current\n     * edit info and the other one are not been rotated, and they have same cropping\n     * percentages. So that they can share the same image src, only width and height\n     * need to be adjusted.\n     */\n    SameWithLast,\n\n    /**\n     * When this value is returned, it means the image is edited by either cropping or\n     * rotation, or both. Image source can't be reused, need to generate a new image src\n     * data uri.\n     */\n    FullyChanged,\n}\n\n/**\n * @internal\n * Check the state of an edit info\n * @param editInfo The edit info to check\n * @param compareTo An optional edit info to compare to\n * @returns If the source edit info is not valid (wrong type, missing field, ...), returns Invalid.\n * If the source edit info doesn't contain any rotation or cropping, returns ResizeOnly\n * If the compare edit info exists, and both of them don't contain rotation, and the have same cropping values,\n * returns SameWithLast. Otherwise, returns FullyChanged\n */\nexport default function checkEditInfoState(\n    editInfo: ImageEditInfo,\n    compareTo?: ImageEditInfo\n): ImageEditInfoState {\n    if (!editInfo || !editInfo.src || ALL_KEYS.some(key => !isNumber(editInfo[key]))) {\n        return ImageEditInfoState.Invalid;\n    } else if (ROTATE_CROP_KEYS.every(key => areSameNumber(editInfo[key], 0))) {\n        return ImageEditInfoState.ResizeOnly;\n    } else if (\n        compareTo &&\n        ROTATE_KEYS.every(key => areSameNumber(editInfo[key], 0)) &&\n        ROTATE_KEYS.every(key => areSameNumber(compareTo[key], 0)) &&\n        CROP_KEYS.every(key => areSameNumber(editInfo[key], compareTo[key]))\n    ) {\n        return ImageEditInfoState.SameWithLast;\n    } else {\n        return ImageEditInfoState.FullyChanged;\n    }\n}\n\nfunction isNumber(o: any): o is number {\n    return typeof o === 'number';\n}\n\nfunction areSameNumber(n1: number, n2: number) {\n    return Math.abs(n1 - n2) < 1e-3;\n}\n","/**\n * Check if we can regenerate edited image from the source image.\n * An image can't regenerate result when there is CORS issue of the source content.\n * @param img The image element to test\n * @returns True when we can regenerate the edited image, otherwise false\n */\nexport default function canRegenerateImage(img: HTMLImageElement): boolean {\n    if (!img) {\n        return false;\n    }\n\n    try {\n        const canvas = img.ownerDocument.createElement('canvas');\n        canvas.width = 10;\n        canvas.height = 10;\n        const context = canvas.getContext('2d');\n        context.drawImage(img, 0, 0);\n        context.getImageData(0, 0, 1, 1);\n        return true;\n    } catch {\n        return false;\n    }\n}\n","import DragAndDropContext, { X, Y } from '../types/DragAndDropContext';\nimport DragAndDropHandler from '../../../pluginUtils/DragAndDropHandler';\nimport ImageEditInfo, { ResizeInfo } from '../types/ImageEditInfo';\nimport ImageHtmlOptions from '../types/ImageHtmlOptions';\nimport { CreateElementData } from 'roosterjs-editor-types';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\n\nconst RESIZE_HANDLE_SIZE = 7;\nconst RESIZE_HANDLE_MARGIN = 3;\nconst Xs: X[] = ['w', '', 'e'];\nconst Ys: Y[] = ['s', '', 'n'];\n\n/**\n * The resize drag and drop handler\n */\nconst Resizer: DragAndDropHandler<DragAndDropContext, ResizeInfo> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ x, y, editInfo, options }, e, base, deltaX, deltaY) => {\n        const ratio =\n            base.widthPx > 0 && base.heightPx > 0 ? (base.widthPx * 1.0) / base.heightPx : 0;\n\n        [deltaX, deltaY] = rotateCoordinate(deltaX, deltaY, editInfo.angleRad);\n\n        const horizontalOnly = x == '';\n        const verticalOnly = y == '';\n        const shouldPreserveRatio =\n            !(horizontalOnly || verticalOnly) && (options.preserveRatio || e.shiftKey);\n        let newWidth = horizontalOnly\n            ? base.widthPx\n            : Math.max(base.widthPx + deltaX * (x == 'w' ? -1 : 1), options.minWidth);\n        let newHeight = verticalOnly\n            ? base.heightPx\n            : Math.max(base.heightPx + deltaY * (y == 'n' ? -1 : 1), options.minHeight);\n\n        if (shouldPreserveRatio && ratio > 0) {\n            newHeight = Math.min(newHeight, newWidth / ratio);\n            newWidth = Math.min(newWidth, newHeight * ratio);\n\n            if (newWidth < newHeight * ratio) {\n                newWidth = newHeight * ratio;\n            } else {\n                newHeight = newWidth / ratio;\n            }\n        }\n\n        editInfo.widthPx = newWidth;\n        editInfo.heightPx = newHeight;\n\n        return true;\n    },\n};\n\n/**\n * @internal\n */\nexport default Resizer;\n\n/**\n * @internal Calculate the rotated x and y distance for mouse moving\n * @param x Original x distance\n * @param y Original y distance\n * @param angle Rotated angle, in radian\n * @returns rotated x and y distances\n */\nexport function rotateCoordinate(x: number, y: number, angle: number): [number, number] {\n    if (x == 0 && y == 0) {\n        return [0, 0];\n    }\n    const hypotenuse = Math.sqrt(x * x + y * y);\n    angle = Math.atan2(y, x) - angle;\n    return [hypotenuse * Math.cos(angle), hypotenuse * Math.sin(angle)];\n}\n\n/**\n * @internal\n * Double check if the changed size can satisfy current width of container.\n * When resize an image and preserve ratio, its size can be limited by the size of container.\n * So we need to check the actual size and calculate the size again\n * @param editInfo Edit info of the image\n * @param preserveRatio Whether w/h ratio need to be preserved\n * @param actualWidth Actual width of the image after resize\n * @param actualHeight Actual height of the image after resize\n */\nexport function doubleCheckResize(\n    editInfo: ImageEditInfo,\n    preserveRatio: boolean,\n    actualWidth: number,\n    actualHeight: number\n) {\n    let { widthPx, heightPx } = editInfo;\n    const ratio = heightPx > 0 ? widthPx / heightPx : 0;\n\n    actualWidth = Math.floor(actualWidth);\n    actualHeight = Math.floor(actualHeight);\n    widthPx = Math.floor(widthPx);\n    heightPx = Math.floor(heightPx);\n\n    editInfo.widthPx = actualWidth;\n    editInfo.heightPx = actualHeight;\n\n    if (preserveRatio && ratio > 0 && (widthPx !== actualWidth || heightPx !== actualHeight)) {\n        if (actualWidth < widthPx) {\n            editInfo.heightPx = actualWidth / ratio;\n        } else {\n            editInfo.widthPx = actualHeight * ratio;\n        }\n    }\n}\n\n/**\n * @internal\n * Get HTML for resize handles at the corners\n */\nexport function getCornerResizeHTML({\n    borderColor: resizeBorderColor,\n}: ImageHtmlOptions): CreateElementData[] {\n    const result: CreateElementData[] = [];\n    Xs.forEach(x =>\n        Ys.forEach(y =>\n            result.push(\n                (x == '') == (y == '') ? getResizeHandleHTML(x, y, resizeBorderColor) : null\n            )\n        )\n    );\n    return result;\n}\n\n/**\n * @internal\n * Get HTML for resize handles on the sides\n */\nexport function getSideResizeHTML({\n    borderColor: resizeBorderColor,\n}: ImageHtmlOptions): CreateElementData[] {\n    const result: CreateElementData[] = [];\n    Xs.forEach(x =>\n        Ys.forEach(y =>\n            result.push(\n                (x == '') != (y == '') ? getResizeHandleHTML(x, y, resizeBorderColor) : null\n            )\n        )\n    );\n    return result;\n}\n\nfunction getResizeHandleHTML(x: X, y: Y, borderColor: string): CreateElementData {\n    const leftOrRight = x == 'w' ? 'left' : 'right';\n    const topOrBottom = y == 'n' ? 'top' : 'bottom';\n    const leftOrRightValue = x == '' ? '50%' : '0px';\n    const topOrBottomValue = y == '' ? '50%' : '0px';\n    const direction = y + x;\n\n    return x == '' && y == ''\n        ? {\n              tag: 'div',\n              style: `position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${borderColor};pointer-events:none`,\n          }\n        : {\n              tag: 'div',\n              style: `position:absolute;${leftOrRight}:${leftOrRightValue};${topOrBottom}:${topOrBottomValue}`,\n              children: [\n                  {\n                      tag: 'div',\n                      style: `position:relative;width:${RESIZE_HANDLE_SIZE}px;height:${RESIZE_HANDLE_SIZE}px;background-color: ${borderColor};cursor:${direction}-resize;${topOrBottom}:-${RESIZE_HANDLE_MARGIN}px;${leftOrRight}:-${RESIZE_HANDLE_MARGIN}px`,\n                      className: ImageEditElementClass.ResizeHandle,\n                      dataset: { x, y },\n                  },\n              ],\n          };\n}\n","import ImageEditInfo from '../types/ImageEditInfo';\nimport ImageSize from '../types/ImageSize';\n\n/**\n * @internal\n * Get target size of an image with a percentage\n * @param editInfo\n * @param percentage\n * @returns [width, height] array\n */\nexport default function getTargetSizeByPercentage(\n    editInfo: ImageEditInfo,\n    percentage: number\n): ImageSize {\n    const {\n        naturalWidth,\n        naturalHeight,\n        leftPercent: left,\n        topPercent: top,\n        rightPercent: right,\n        bottomPercent: bottom,\n    } = editInfo;\n    const width = naturalWidth * (1 - left - right) * percentage;\n    const height = naturalHeight * (1 - top - bottom) * percentage;\n    return { width, height };\n}\n","import getEditInfoFromImage from '../editInfoUtils/getEditInfoFromImage';\nimport getTargetSizeByPercentage from '../editInfoUtils/getTargetSizeByPercentage';\n\n/**\n * Check if the image is already resized to the given percentage\n * @param image The image to check\n * @param percentage The percentage to check\n */\nexport default function isResizedTo(image: HTMLImageElement, percentage: number): boolean {\n    const editInfo = getEditInfoFromImage(image);\n    const { width, height } = getTargetSizeByPercentage(editInfo, percentage);\n    return (\n        Math.round(width) == Math.round(editInfo.widthPx) &&\n        Math.round(height) == Math.round(editInfo.heightPx)\n    );\n}\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\nexport * from 'roosterjs-color-utils';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { getDarkColor } from 'roosterjs-color-utils';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        getDarkColor: getDarkColor,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\nexport { default as getAllFeatures } from './getAllFeatures';\n","import getAllFeatures from './getAllFeatures';\nimport {\n    ContentEditFeatureSettings,\n    EditorPlugin,\n    GenericContentEditFeature,\n    IEditor,\n    PluginEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    /**\n     * Create instance of ContentEdit plugin\n     * @param settingsOverride An optional feature set to override default feature settings\n     * @param additionalFeatures Optional. More features to add\n     */\n    constructor(\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor): void {\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\n        const allFeatures = getAllFeatures();\n\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\n            const feature = allFeatures[key];\n            const hasSettingForKey =\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\n\n            if (\n                (hasSettingForKey && this.settingsOverride[key]) ||\n                (!hasSettingForKey && !feature.defaultDisabled)\n            ) {\n                features.push(feature);\n            }\n        });\n\n        features\n            .concat(this.additionalFeatures || [])\n            .forEach(feature => editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose(): void {}\n}\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    AutoLinkFeatureSettings,\n    BuildInEditFeature,\n    ChangeSource,\n    ClipboardData,\n    IEditor,\n    Keys,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    clearEventDataCache,\n    LinkInlineElement,\n    matchLink,\n} from 'roosterjs-editor-dom';\n\n/**\n * When user type, they may end a link with a punctuation, i.e. www.bing.com;\n * we need to trim off the trailing punctuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = editor.getContentSearcherOfCursor(event);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: IEditor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(editor => {\n        editor.addUndoSnapshot(\n            () => {\n                replaceWithNode(\n                    editor,\n                    linkData.originalUrl,\n                    anchor,\n                    false /* exactMatch */,\n                    searcher\n                );\n\n                // The content at cursor has changed. Should also clear the cursor data cache\n                clearEventDataCache(event);\n                return anchor;\n            },\n            ChangeSource.AutoLink,\n            true /*canUndoByBackspace*/\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const AutoLinkFeatures: Record<\n    keyof AutoLinkFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoLink: AutoLink,\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n};\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This represents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides a scope object for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragraph,\r\n     * the one after likely will point to inline in next paragraph which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determines the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textual inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import extractClipboardItems from './extractClipboardItems';\nimport extractClipboardItemsForIE from './extractClipboardItemsForIE';\nimport toArray from '../utils/toArray';\nimport { ClipboardData, ExtractClipboardEventOption } from 'roosterjs-editor-types';\n\ninterface WindowForIE extends Window {\n    clipboardData: DataTransfer;\n}\n\n/**\n * @deprecated Use extractClipboardItems and extractClipboardItemsForIE instead\n * Extract a Clipboard event\n * @param event The paste event\n * @param callback Callback function when data is ready\n * @param options Options to retrieve more items from the event, including HTML string and other customized items\n * @returns An object with the following properties:\n *  types: Available types from the clipboard event\n *  text: Plain text from the clipboard event\n *  image: Image file from the clipboard event\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\n *   not supported by browser.\n */\nexport default function extractClipboardEvent(\n    event: ClipboardEvent,\n    callback: (clipboardData: ClipboardData) => void,\n    options?: ExtractClipboardEventOption\n) {\n    const dataTransfer =\n        event.clipboardData ||\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\n\n    if (dataTransfer.items) {\n        event.preventDefault();\n        extractClipboardItems(toArray(dataTransfer.items), options).then(callback);\n    } else {\n        extractClipboardItemsForIE(dataTransfer, callback, options);\n    }\n}\n","import setColor from './setColor';\r\nimport { DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n\r\n        setColor(element, textColors || textColor, false /*isBackground*/, isDarkMode);\r\n        setColor(element, backgroundColors || backgroundColor, true /*isBackground*/, isDarkMode);\r\n\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in particular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid since it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","import { NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\nimport {\n    changeElementTag,\n    contains,\n    createRange,\n    findClosestElementAncestor,\n    getBlockElementAtNode,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    isVoidHtmlElement,\n    LinkInlineElement,\n    Position,\n    PositionContentSearcher,\n    queryElements,\n    splitBalancedNodeRange,\n    splitTextNode,\n    toArray,\n    unwrap,\n    VTable,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst adjustSteps: ((\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n) => Position)[] = [\n    adjustInsertPositionForHyperLink,\n    adjustInsertPositionForStructuredNode,\n    adjustInsertPositionForParagraph,\n    adjustInsertPositionForVoidElement,\n    adjustInsertPositionForMoveCursorOutOfALink,\n];\n\n/**\n * Adjust position for A tag don't be nested inside another A tag.\n */\nfunction adjustInsertPositionForHyperLink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    let blockElement = getBlockElementAtNode(root, position.node);\n\n    if (blockElement) {\n        // Find the first <A> tag within current block which covers current selection\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\n        let anchor = queryElements(\n            root,\n            'a[href]',\n            null /*forEachCallback*/,\n            QueryScope.OnSelection,\n            createRange(position)\n        ).filter((a: HTMLElement) => blockElement.contains(a))[0];\n\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\n        if (anchor && isNodeEmpty(anchor)) {\n            position = new Position(anchor, PositionType.Before);\n            safeRemove(anchor);\n            anchor = null;\n        }\n\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\n        // otherwise we will have nested A tags which is a wrong HTML structure\n        if (\n            anchor &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector &&\n            (<ParentNode>(nodeToInsert as HTMLElement))?.querySelector('a[href]')\n        ) {\n            let normalizedPosition = position.normalize();\n            let parentNode = normalizedPosition.node.parentNode;\n            let nextNode =\n                normalizedPosition.node.nodeType == NodeType.Text\n                    ? splitTextNode(\n                          <Text>normalizedPosition.node,\n                          normalizedPosition.offset,\n                          false /*returnFirstPart*/\n                      )\n                    : normalizedPosition.isAtEnd\n                    ? normalizedPosition.node.nextSibling\n                    : normalizedPosition.node;\n            let splitter: Node = root.ownerDocument.createTextNode('');\n            parentNode.insertBefore(splitter, nextNode);\n\n            while (contains(anchor, splitter)) {\n                splitter = splitBalancedNodeRange(splitter);\n            }\n\n            position = new Position(splitter, PositionType.Before);\n            safeRemove(splitter);\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node don't be nested inside tags like BR, LI, TD.\n */\nfunction adjustInsertPositionForStructuredNode(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    let rootNodeToInsert = nodeToInsert;\n\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(\n            (n: ChildNode) => getTagOfNode(n) != 'BR'\n        );\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\n    }\n\n    let tag = getTagOfNode(rootNodeToInsert);\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\n\n    if (tag == 'LI') {\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\n    }\n\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\n\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\n            safeRemove(rootNodeToInsert.nextSibling);\n        }\n\n        if (shouldInsertListAsText) {\n            unwrap(rootNodeToInsert.firstChild);\n            unwrap(rootNodeToInsert);\n        } else if (getTagOfNode(listNode) == tag) {\n            unwrap(rootNodeToInsert);\n            position = new Position(\n                listItem,\n                isPositionAtBeginningOf(position, listItem)\n                    ? PositionType.Before\n                    : PositionType.After\n            );\n        }\n    } else if (tag == 'TABLE' && trNode) {\n        // When inserting a table into a table, if these tables have the same column count, and\n        // current position is at beginning of a row, then merge these two tables\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\n        if (\n            currentTable.col == 0 &&\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\n            newTable.cells[0] &&\n            newTable.cells[0].length == currentTable.cells[0].length &&\n            isPositionAtBeginningOf(position, tdNode)\n        ) {\n            if (\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\n                !rootNodeToInsert.firstChild.nextSibling\n            ) {\n                unwrap(rootNodeToInsert.firstChild);\n            }\n            unwrap(rootNodeToInsert);\n            position = new Position(trNode, PositionType.After);\n        }\n    }\n\n    return position;\n}\n\n/**\n * Change P tag to DIV, when a new node when insert node.\n */\n\nfunction adjustInsertPositionForParagraph(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    if (getTagOfNode(position.node) == 'P') {\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\n        // Change P tag to DIV to make sure it works well\n        let pos = position.normalize();\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\n        if (pos.node != div) {\n            position = pos;\n        }\n    }\n\n    return position;\n}\n\n/**\n * Adjust position for a node that can have children.\n */\n\nfunction adjustInsertPositionForVoidElement(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    if (isVoidHtmlElement(position.node)) {\n        position = new Position(\n            position.node,\n            position.isAtEnd ? PositionType.After : PositionType.Before\n        );\n    }\n    return position;\n}\n\n/**\n * Adjust the position cursor out of link when a new node is inserted.\n */\n\nfunction adjustInsertPositionForMoveCursorOutOfALink(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    if (range && range.collapsed) {\n        const searcher = new PositionContentSearcher(root, Position.getStart(range));\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const inlineElementAfter = searcher.getInlineElementAfter();\n        if (inlineElementBefore instanceof LinkInlineElement) {\n            position = new Position(inlineElementBefore.getContainerNode(), PositionType.After);\n        } else if (inlineElementAfter instanceof LinkInlineElement) {\n            position = new Position(inlineElementAfter.getContainerNode(), PositionType.Before);\n        }\n    }\n    return position;\n}\n\n/**\n *\n * @param root the contentDiv of the ditor\n * @param nodeToInsert the node to be inserted\n * @param position the position of the node to be inserted\n * @param range the range current or cached range of the editor\n * @returns the adjusted position of the inserted node\n */\n\nexport default function adjustInsertPositionBySteps(\n    root: HTMLElement,\n    nodeToInsert: Node,\n    position: Position,\n    range: Range\n): Position {\n    adjustSteps.forEach(handler => {\n        position = handler(root, nodeToInsert, position, range);\n    });\n    return position;\n}\n\nfunction safeRemove(node: Node) {\n    node?.parentNode?.removeChild(node);\n}\n","import moveChildNodes from '../utils/moveChildNodes';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement, normalizeSize?: boolean) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            const hasTd: boolean = colSpan + rowSpan == 0;\r\n                            const rect = td.getBoundingClientRect();\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: hasTd ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                                width: hasTd ? rect.width : undefined,\r\n                                height: hasTd ? rect.height : undefined,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (normalizeSize) {\r\n                this.normalizeSize();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildNodes(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalculateSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildNodes(\r\n                                aboveCell.td,\r\n                                belowCell.td,\r\n                                true /*keepExistingChildren*/\r\n                            );\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildNodes(\r\n                                leftCell.td,\r\n                                rightCell.td,\r\n                                true /*keepExistingChildren*/\r\n                            );\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each table cell and get all the cells that share the same border from one side\r\n     * The result is an array of table cell elements\r\n     * @param borderPos The position of the border\r\n     * @param getLeftCells Get left-hand-side or right-hand-side cells of the border\r\n     *\r\n     * Example, consider having a 3 by 4 table as below with merged and split cells\r\n     *\r\n     *     | 1 | 4 | 7 | 8 |\r\n     *     |   5   |   9   |\r\n     *     |   3   |   10  |\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: true\r\n     *  output => [4, 5, 3]\r\n     *\r\n     *  input => borderPos: the 3rd border, getLeftCells: false\r\n     *  output => [7, 9, 10]\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: true\r\n     *  output => [1]\r\n     *\r\n     *  input => borderPos: the 2nd border, getLeftCells: false\r\n     *  output => [4]\r\n     */\r\n    getCellsWithBorder(borderPos: number, getLeftCells: boolean): HTMLTableCellElement[] {\r\n        const cells: HTMLTableCellElement[] = [];\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            for (let j = 0; j < this.cells[i].length; j++) {\r\n                const cell = this.getCell(i, j);\r\n                if (cell.td) {\r\n                    const cellRect = normalizeRect(cell.td.getBoundingClientRect());\r\n                    let found: boolean = false;\r\n                    if (getLeftCells) {\r\n                        if (cellRect.right == borderPos) {\r\n                            found = true;\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        if (cellRect.left == borderPos) {\r\n                            found = true;\r\n                            cells.push(cell.td);\r\n                        } else if (found) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalculateSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private normalizeEmptyTableCells() {\r\n        for (let i = 0, row; (row = this.table.rows[i]); i++) {\r\n            for (let j = 0, cell; (cell = row.cells[j]); j++) {\r\n                if (cell) {\r\n                    if (!cell.innerHTML || !cell.innerHTML.trim()) {\r\n                        cell.appendChild(document.createElement('br'));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* normalize width/height for each cell in the table */\r\n    public normalizeTableCellSize() {\r\n        // remove width/height for each row\r\n        for (let i = 0, row; (row = this.table.rows[i]); i++) {\r\n            row.removeAttribute('width');\r\n            row.style.width = null;\r\n            row.removeAttribute('height');\r\n            row.style.height = null;\r\n        }\r\n\r\n        // set width/height for each cell\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            for (let j = 0; j < this.cells[i].length; j++) {\r\n                const cell = this.cells[i][j];\r\n                if (cell) {\r\n                    setHTMLElementSizeInPx(cell.td, cell.width, cell.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private normalizeSize() {\r\n        this.normalizeEmptyTableCells();\r\n        this.normalizeTableCellSize();\r\n        setHTMLElementSizeInPx(this.table); // Make sure table width/height is fixed to avoid shifting effect\r\n    }\r\n}\r\n\r\nfunction setHTMLElementSizeInPx(element: HTMLElement, newWidth?: number, newHeight?: number) {\r\n    if (!!element) {\r\n        element.removeAttribute('width');\r\n        element.removeAttribute('height');\r\n        element.style.boxSizing = 'border-box';\r\n        const rect = element.getBoundingClientRect();\r\n        element.style.width = `${newWidth !== undefined ? newWidth : rect.width}px`;\r\n        element.style.height = `${newHeight !== undefined ? newHeight : rect.height}px`;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n","import createElement from '../utils/createElement';\nimport getRootListNode from './getRootListNode';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport Position from '../selection/Position';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport toArray from '../utils/toArray';\nimport VList from './VList';\nimport wrap from '../utils/wrap';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { KnownCreateElementDataIndex, ListType, Region } from 'roosterjs-editor-types';\nimport { PositionType } from 'roosterjs-editor-types';\n\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, ListSelector, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n                if (\n                    nodes.length == 1 &&\n                    safeInstanceOf(list, 'HTMLOListElement') &&\n                    list.start > 1\n                ) {\n                    // Do not include sibling lists if this list is not start from 1\n                    includeSiblingLists = false;\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\n            const newNode = createElement(\n                KnownCreateElementDataIndex.EmptyLine,\n                region.rootNode.ownerDocument\n            );\n            region.rootNode.appendChild(newNode);\n            nodes.push(newNode);\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\n        }\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, ListSelector, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\n                // Only include sibling list when\n                // 1. This is a unordered list, OR\n                // 2. This list starts from 1\n                nodes.push(node);\n            }\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Wrap all child nodes under a single one, and put the new list under original root node\n    // so that the list can carry over styles under the root node.\n    const childNodes = toArray(node.childNodes);\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\n\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.appendChild(listNode);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(nodeForItem, ListType.None);\n\n    return vList;\n}\n","import arrayPush from '../utils/arrayPush';\nimport getRootListNode from './getRootListNode';\nimport isNodeAfter from '../utils/isNodeAfter';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport queryElements from '../utils/queryElements';\nimport VList from './VList';\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\n\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\nconst CHAIN_DATASET_NAME = 'listchain';\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\nlet lastChainIndex = 0;\n\n/**\n * Represent a chain of list nodes.\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\n * all others should also be updated in order to main the list number to be continuous.\n */\nexport default class VListChain {\n    private lastNumber = 0;\n    private lastNumberBeforeCursor = 0;\n\n    /**\n     * Create an array of VListChain from current region in editor\n     * @param region The region to create VListChain from\n     * @param currentNode Optional current node, used for mark lists that are after this node\n     * @param nameGenerator Used by test code only\n     */\n    static createListChains(\n        region: RegionBase | RegionBase[],\n        currentNode?: Node,\n        nameGenerator?: () => string\n    ): VListChain[] {\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\n        const result: VListChain[] = [];\n        regions.forEach(region => {\n            const chains: VListChain[] = [];\n            let lastList: HTMLOListElement;\n\n            queryElements(region.rootNode, 'ol', ol => {\n                const list = getRootListNode(region, 'ol', ol);\n\n                if (lastList != list) {\n                    const chain =\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\n                        new VListChain(region, (nameGenerator || createListChainName)());\n                    const index = chains.indexOf(chain);\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\n\n                    if (!afterCurrentNode) {\n                        // Make sure current one is at the front if current block has not been met, so that\n                        // the first chain is always the nearest one from current node\n                        if (index >= 0) {\n                            chains.splice(index, 1);\n                        }\n\n                        chains.unshift(chain);\n                    } else if (index < 0) {\n                        chains.push(chain);\n                    }\n\n                    chain.append(list, afterCurrentNode);\n                    lastList = list;\n                }\n            });\n\n            arrayPush(result, chains);\n        });\n\n        return result;\n    }\n\n    /**\n     * Check if a list with the given start number can be appended next to the last list before cursor\n     * @param startNumber The start number of the new list\n     */\n    canAppendAtCursor(startNumber: number): boolean {\n        return this.lastNumberBeforeCursor + 1 == startNumber;\n    }\n\n    /**\n     * Create a VList to wrap the block of the given node, and append to current chain\n     * @param container The container node to create list at\n     * @param startNumber Start number of the new list\n     */\n    createVListAtBlock(container: Node, startNumber: number): VList {\n        if (container) {\n            const list = container.ownerDocument.createElement('ol');\n\n            list.start = startNumber;\n            this.applyChainName(list);\n            container.parentNode.insertBefore(list, container);\n\n            const vList = new VList(list);\n\n            vList.appendItem(container, ListType.None);\n            return vList;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * After change the lists, commit the change to all lists in this chain to update the list number,\n     * and clear the temporary dataset values added to list node\n     */\n    commit() {\n        const lists = this.getLists();\n        let lastNumber = 0;\n\n        for (let i = 0; i < lists.length; i++) {\n            const list = lists[i];\n            list.start = lastNumber + 1;\n\n            const vlist = new VList(list);\n\n            lastNumber = vlist.getLastItemNumber();\n\n            delete list.dataset[CHAIN_DATASET_NAME];\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\n\n            vlist.writeBack();\n        }\n    }\n\n    /**\n     * Construct a new instance of VListChain class\n     * @param editor Editor object\n     */\n    private constructor(private region: RegionBase, private name: string) {}\n\n    /**\n     * Check if the given list node is can be appended into current list chain\n     * @param list The list node to check\n     */\n    private canAppendToTail(list: HTMLOListElement) {\n        return this.lastNumber + 1 == list.start;\n    }\n\n    /**\n     * Append the given list node into this VListChain\n     * @param list The list node to append\n     * @param isAfterCurrentNode Whether this list is after current node\n     */\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\n        this.applyChainName(list);\n        this.lastNumber = new VList(list).getLastItemNumber();\n\n        if (isAfterCurrentNode) {\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\n        } else {\n            this.lastNumberBeforeCursor = this.lastNumber;\n        }\n    }\n\n    private applyChainName(list: HTMLOListElement) {\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\n    }\n\n    private getLists() {\n        return queryElements(\n            this.region.rootNode,\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\n    }\n}\n\nfunction createListChainName() {\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import createElement from '../utils/createElement';\r\nimport createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The position to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const span = createElement(\r\n            { tag: 'span', children: ['\\u200b'] },\r\n            position.node.ownerDocument\r\n        );\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPreviousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPreviousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getInnerHTML from '../utils/getInnerHTML';\nimport getSelectionPath from './getSelectionPath';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport queryElements from '../utils/queryElements';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(\n    rootNode: HTMLElement | DocumentFragment,\n    range: Range\n): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\n    let isDOMChanged = false;\n\n    queryElements(rootNode, 'table', table => {\n        let tbody: HTMLTableSectionElement = null;\n\n        for (let child = table.firstChild; child; child = child.nextSibling) {\n            if (getTagOfNode(child) == 'TR') {\n                if (!tbody) {\n                    tbody = table.ownerDocument.createElement('tbody');\n                    table.insertBefore(tbody, child);\n                }\n\n                tbody.appendChild(child);\n                child = tbody;\n\n                isDOMChanged = true;\n            } else {\n                tbody = null;\n            }\n        }\n    });\n\n    if (range && isDOMChanged) {\n        try {\n            range.setStart(startContainer, startOffset);\n            range.setEnd(endContainer, endOffset);\n        } catch {}\n    }\n\n    const content = getInnerHTML(rootNode);\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath, TrustedHTMLHandler } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(\r\n    rootNode: HTMLElement,\r\n    html: string,\r\n    trustedHTMLHandler?: TrustedHTMLHandler\r\n): Range {\r\n    html = html || '';\r\n    rootNode.innerHTML = trustedHTMLHandler?.(html) || html;\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\n\n/**\n * Add the given range into selection of the given document\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\n * otherwise it will always remove current selection range and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\n    if (selection) {\n        let needAddRange = true;\n\n        if (selection.rangeCount > 0) {\n            // Workaround IE exception 800a025e\n            try {\n                let currentRange: Range;\n                // Do not remove/add range if current selection is the same with target range\n                // Without this check, execCommand() may fail in Edge since we changed the selection\n                if (\n                    (skipSameRange || Browser.isEdge) &&\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\n                    currentRange.startContainer == range.startContainer &&\n                    currentRange.startOffset == range.startOffset &&\n                    currentRange.endContainer == range.endContainer &&\n                    currentRange.endOffset == range.endOffset\n                ) {\n                    needAddRange = false;\n                } else {\n                    selection.removeAllRanges();\n                }\n            } catch (e) {}\n        }\n\n        if (needAddRange) {\n            selection.addRange(range);\n        }\n    }\n}\n","import arrayPush from '../utils/arrayPush';\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\nimport getRegionsFromRange from '../region/getRegionsFromRange';\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\nimport Position from './Position';\nimport queryElements from '../utils/queryElements';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport splitTextNode from '../utils/splitTextNode';\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Delete selected content, and return the new position to select\n * @param core The EditorCore object.\n * @param range The range to delete\n */\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\n    let nodeBefore: Node = null;\n\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detect them from step 2\n    // since table cells will fall in to different regions\n    const nodesToDelete: Node[] = queryElements(\n        root,\n        'table,tr',\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\n    // We don't delete them directly here because delete node from one region may cause selection range\n    // another region becomes invalid. So we delay the process of deletion.\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\n    const nodesPairToMerge = regions\n        .map(region => {\n            const regionRange = getSelectionRangeInRegion(region);\n            if (!regionRange) {\n                return null;\n            }\n\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\n\n            // Make sure there are node before and after the merging point.\n            // This is required by mergeBlocksInRegion API.\n            // This may create some empty text node as anchor\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\n                endContainer,\n                endOffset,\n                false /*isStart*/\n            );\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\n                startContainer,\n                startOffset,\n                true /*isStart*/\n            );\n            nodeBefore = nodeBefore || beforeStart;\n\n            // Find out all nodes to be deleted\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\n            arrayPush(nodesToDelete, nodes);\n            return { region, beforeStart, afterEnd };\n        })\n        .filter(x => !!x);\n\n    // 3. Delete all nodes that we found\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\n\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\n    nodesPairToMerge.forEach(nodes =>\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\n    );\n\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\n}\n\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\n    if (safeInstanceOf(node, 'Text')) {\n        const newNode = splitTextNode(node, offset, isStart);\n        return isStart ? [newNode, node] : [node, newNode];\n    } else {\n        let nodeBefore: Node = node.childNodes[offset - 1];\n        let nodeAfter: Node = node.childNodes[offset];\n\n        // Condition 1: node child nodes\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\n        // [ I ]\n        // need to use parent node instead to convert to condition 2\n        if (!nodeBefore && !nodeAfter) {\n            if (isStart) {\n                nodeAfter = node;\n                nodeBefore = nodeAfter.previousSibling;\n            } else {\n                nodeBefore = node;\n                nodeAfter = nodeBefore.nextSibling;\n            }\n        }\n\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\n        // [ o I ]  or [ I o]\n        // need to add empty text node to convert to condition 3\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\n            const emptyNode = node.ownerDocument.createTextNode('');\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\n            if (nodeBefore) {\n                nodeAfter = emptyNode;\n            } else {\n                nodeBefore = emptyNode;\n            }\n        }\n\n        // Condition 3: Both nodeBefore and nodeAfter are not null\n        // [o I o]\n        // return the nodes\n        return [nodeBefore, nodeAfter];\n    }\n}\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\nimport { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\n * @param snapshots The snapshots data structure to move\n * @param step The step to move\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\n */\nexport default function moveCurrentSnapshot(snapshots: Snapshots, step: number): string {\n    if (canMoveCurrentSnapshot(snapshots, step)) {\n        snapshots.currentIndex += step;\n        snapshots.autoCompleteIndex = -1;\n        return snapshots.snapshots[snapshots.currentIndex];\n    } else {\n        return null;\n    }\n}\n\n/**\n * @deprecated\n * For backward compatibility only\n */\nexport const moveCurrentSnapsnot = moveCurrentSnapshot;\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\n\n/**\n * Whether there is a snapshot added before auto complete and it can be undone now\n */\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\n    return (\n        snapshots.autoCompleteIndex >= 0 &&\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\n    );\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getInheritableStyles from './getInheritableStyles';\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\nimport getStyles from '../style/getStyles';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport safeInstanceOf from '../utils/safeInstanceOf';\nimport setStyles from '../style/setStyles';\nimport toArray from '../utils/toArray';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedAttributes,\n    getAllowedCssClassesRegex,\n    getTagReplacement,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n} from './getAllowedValues';\nimport {\n    AttributeCallbackMap,\n    CssStyleCallbackMap,\n    ElementCallbackMap,\n    HtmlSanitizerOptions,\n    NodeType,\n    PredefinedCssMap,\n    SanitizeHtmlOptions,\n    StringMap,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two features:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unused HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: CssStyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private tagReplacements: Record<string, string>;\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalPredefinedCssForElement: PredefinedCssMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private preserveHtmlComments: boolean;\n    private unknownTagReplacement: string;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.preserveHtmlComments = options.preserveHtmlComments;\n        this.unknownTagReplacement = options.unknownTagReplacement;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(unsafeConvertToTrustedHTML(html) || '', 'text/html');\n\n        if (doc && doc.body && doc.body.firstChild) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n        const isComment = nodeType == NodeType.Comment;\n\n        let shouldKeep = false;\n\n        if (isElement) {\n            const tag = getTagOfNode(node);\n            const callback = this.elementCallbacks[tag];\n            let replacement = this.tagReplacements[tag.toLowerCase()];\n\n            if (replacement === undefined) {\n                replacement = this.unknownTagReplacement;\n            }\n\n            if (callback) {\n                shouldKeep = callback(node as HTMLElement, context);\n            } else if (tag.indexOf(':') > 0) {\n                shouldKeep = true;\n            } else if (tag == replacement || replacement == '*') {\n                shouldKeep = true;\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\n                node = changeElementTag(node as HTMLElement, replacement);\n                shouldKeep = true;\n            }\n        } else if (isText) {\n            const whiteSpace = currentStyle['white-space'];\n            shouldKeep =\n                whiteSpace == 'pre' ||\n                whiteSpace == 'pre-line' ||\n                whiteSpace == 'pre-wrap' ||\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\n        } else if (isFragment) {\n            shouldKeep = true;\n        } else if (isComment) {\n            shouldKeep = this.preserveHtmlComments;\n        } else {\n            shouldKeep = false;\n        }\n\n        if (!shouldKeep) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            let element = <HTMLElement>node;\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.preprocessCss(element, thisStyle);\n                this.processCss(element, thisStyle, context);\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\n        const predefinedStyles = getPredefinedCssForElement(\n            element,\n            this.additionalPredefinedCssForElement\n        );\n        if (predefinedStyles) {\n            Object.keys(predefinedStyles).forEach(name => {\n                thisStyle[name] = predefinedStyles[name];\n            });\n        }\n    }\n\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\n        const styles = getStyles(element);\n        Object.keys(styles).forEach(name => {\n            const value = styles[name];\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, thisStyle, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n\n            if (!keep) {\n                delete styles[name];\n            }\n        });\n\n        setStyles(element, styles);\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n}\n\nconst trustedTypes = (<any>window).trustedTypes;\nconst policy = trustedTypes?.createPolicy('roosterjsUnsafeConvertHTML', {\n    // This is unsafe. However, we only use this function for HtmlSanitizer which we will\n    // sanitize HTML tree by our own code. So we just directly return the HTML string here.\n    createHTML: (html: string) => html,\n});\n\nconst unsafeConvertToTrustedHTML = policy\n    ? (html: string) => policy.createHTML(html)\n    : (html: string) => html;\n","import { cloneObject } from './cloneObject';\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\n\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\n    // Allowed tags\n    a: '*',\n    abbr: '*',\n    address: '*',\n    area: '*',\n    article: '*',\n    aside: '*',\n    b: '*',\n    bdi: '*',\n    bdo: '*',\n    blockquote: '*',\n    body: '*',\n    br: '*',\n    button: '*',\n    canvas: '*',\n    caption: '*',\n    center: '*',\n    cite: '*',\n    code: '*',\n    col: '*',\n    colgroup: '*',\n    data: '*',\n    datalist: '*',\n    dd: '*',\n    del: '*',\n    details: '*',\n    dfn: '*',\n    dialog: '*',\n    dir: '*',\n    div: '*',\n    dl: '*',\n    dt: '*',\n    em: '*',\n    fieldset: '*',\n    figcaption: '*',\n    figure: '*',\n    font: '*',\n    footer: '*',\n    h1: '*',\n    h2: '*',\n    h3: '*',\n    h4: '*',\n    h5: '*',\n    h6: '*',\n    head: '*',\n    header: '*',\n    hgroup: '*',\n    hr: '*',\n    html: '*',\n    i: '*',\n    img: '*',\n    input: '*',\n    ins: '*',\n    kbd: '*',\n    label: '*',\n    legend: '*',\n    li: '*',\n    main: '*',\n    map: '*',\n    mark: '*',\n    menu: '*',\n    menuitem: '*',\n    meter: '*',\n    nav: '*',\n    ol: '*',\n    optgroup: '*',\n    option: '*',\n    output: '*',\n    p: '*',\n    picture: '*',\n    pre: '*',\n    progress: '*',\n    q: '*',\n    rp: '*',\n    rt: '*',\n    ruby: '*',\n    s: '*',\n    samp: '*',\n    section: '*',\n    select: '*',\n    small: '*',\n    span: '*',\n    strike: '*',\n    strong: '*',\n    sub: '*',\n    summary: '*',\n    sup: '*',\n    table: '*',\n    tbody: '*',\n    td: '*',\n    template: '*',\n    textarea: '*',\n    tfoot: '*',\n    th: '*',\n    thead: '*',\n    time: '*',\n    tr: '*',\n    tt: '*',\n    u: '*',\n    ul: '*',\n    var: '*',\n    wbr: '*',\n    xmp: '*',\n\n    // Replaced tags:\n    form: 'SPAN',\n\n    // Disallowed tags\n    applet: null,\n    audio: null,\n    base: null,\n    basefont: null,\n    embed: null,\n    frame: null,\n    frameset: null,\n    iframe: null,\n    link: null,\n    meta: null,\n    noscript: null,\n    object: null,\n    param: null,\n    script: null,\n    slot: null,\n    source: null,\n    style: null,\n    title: null,\n    track: null,\n    video: null,\n};\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,valign,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getTagReplacement(\n    additionalReplacements: Record<string, string>\n): Record<string, string> {\n    const result = { ...HTML_TAG_REPLACEMENT };\n    const replacements = additionalReplacements || {};\n    Object.keys(replacements).forEach(key => {\n        if (key) {\n            result[key.toLowerCase()] = replacements[key];\n        }\n    });\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        cssStyleCallbacks: {},\n        additionalTagReplacements: {},\n        additionalAllowedAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        additionalPredefinedCssForElement: {},\n        preserveHtmlComments: false,\n        unknownTagReplacement: null,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<TOriginalArgs extends any[], TChainedFn extends (...args: TOriginalArgs) => R,  R>(\n    map: Record<string, (...args: TOriginalArgs) => R>,\n    name: string,\n    newCallback: TChainedFn\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: TOriginalArgs) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE = 'contenteditable';\n\n/**\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\n * @param wrapper The entity wrapper element\n * @param type Entity type\n * @param isReadonly Whether this is a readonly entity\n * @param id Optional Id of the entity\n */\nexport default function commitEntity(\n    wrapper: HTMLElement,\n    type: string,\n    isReadonly: boolean,\n    id?: string\n) {\n    if (wrapper) {\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\n            EntityClasses.ENTITY_TYPE_PREFIX\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\n            EntityClasses.ENTITY_READONLY_PREFIX\n        }${isReadonly ? '1' : '0'}`;\n\n        if (isReadonly) {\n            wrapper.contentEditable = 'false';\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\n            wrapper.removeAttribute(CONTENT_EDITABLE);\n        }\n    }\n}\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    element?.className?.split(' ').forEach(name => {\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\n            isEntity = true;\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\n        }\n    });\n\n    return isEntity\n        ? {\n              wrapper: element,\n              id,\n              type,\n              isReadonly,\n          }\n        : null;\n}\n","import { EntityClasses } from 'roosterjs-editor-types';\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport default function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Gets the cached event data by cache key from event object if there is already one.\n * Otherwise, call getter function to create one, and cache it.\n * @param event The event object\n * @param key Cache key string, need to be unique\n * @param getter Getter function to get the object when it is not in cache yet\n */\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\n    let result =\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\n            ? <T>event.eventDataCache[key]\n            : getter();\n    if (event) {\n        event.eventDataCache = event.eventDataCache || {};\n        event.eventDataCache[key] = result;\n    }\n\n    return result;\n}\n","import { PluginEvent } from 'roosterjs-editor-types';\n\n/**\n * Clear a cached object by its key from an event object\n * @param event The event object\n * @param key The cache key\n */\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\n    if (event && event.eventDataCache) {\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\n            delete event.eventDataCache[key];\n        } else if (!key) {\n            event.eventDataCache = {};\n        }\n    }\n}\n","import isModifierKey from './isModifierKey';\n\n/**\n * Returns true when the event was fired from a key that produces a character value, otherwise false\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\n * So if we missed some case here it is still acceptable.\n * @param event The keyboard event object\n */\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\n    return !isModifierKey(event) && event.key && event.key.length == 1;\n}\n","import { Browser } from '../utils/Browser';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import clearFormat from './clearFormat';\r\nimport { ClearFormatMode, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @deprecated Use clearFormat instead and pass the ClearFormatMode.Block as parameter\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    clearFormat(editor, ClearFormatMode.Block);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const sanitizer = new HtmlSanitizer();\r\n    const a = document.createElement('a');\r\n\r\n    a.href = link || '';\r\n    sanitizer.sanitize(a);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    IEditor,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: IEditor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\n): Entity {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    commitEntity(wrapper, type, isReadonly);\n\n    if (!editor.contains(wrapper)) {\n        let currentRange: Range;\n        let contentPosition:\n            | ContentPosition.Begin\n            | ContentPosition.End\n            | ContentPosition.DomEnd\n            | ContentPosition.SelectionStart;\n\n        if (typeof position == 'number') {\n            contentPosition = position;\n        } else if (position) {\n            currentRange = editor.getSelectionRange();\n            const node = position.normalize().node;\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\n\n            // Do not insert entity into another entity\n            if (existingEntity) {\n                position = new Position(existingEntity, PositionType.After);\n            }\n\n            editor.select(position);\n            contentPosition = ContentPosition.SelectionStart;\n        } else {\n            editor.focus();\n            contentPosition = ContentPosition.SelectionStart;\n        }\n\n        editor.insertNode(wrapper, {\n            updateCursor: false,\n            insertOnNewLine: isBlock,\n            replaceSelection: true,\n            position: contentPosition,\n        });\n\n        if (contentPosition == ContentPosition.SelectionStart) {\n            if (currentRange) {\n                editor.select(currentRange);\n            } else if (!isBlock) {\n                editor.select(wrapper, PositionType.After);\n            }\n        }\n    }\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the target text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the target text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Rotate an element visually\n * @param editor The editor instance\n * @param element The element that should be rotated\n * @param angle The degree at which to rotate the element from it's center\n */\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\n    if (element) {\n        editor.addUndoSnapshot(() => {\n            element.style.transform = `rotate(${angle}deg)`;\n        }, ChangeSource.Format);\n    }\n}\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport {\r\n    BlockElement,\r\n    IEditor,\r\n    Indentation,\r\n    KnownCreateElementDataIndex,\r\n    RegionBase,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    createVListFromRegion,\r\n    findClosestElementAncestor,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    const handler = indentation == Indentation.Increase ? indent : outdent;\r\n\r\n    blockFormat(editor, (region, start, end) => {\r\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n        const blockGroups: BlockElement[][] = [[]];\r\n\r\n        for (let i = 0; i < blocks.length; i++) {\r\n            const startNode = blocks[i].getStartNode();\r\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\r\n\r\n            if (vList) {\r\n                blockGroups.push([]);\r\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\r\n                    i++;\r\n                }\r\n                vList.setIndentation(start, end, indentation);\r\n                vList.writeBack();\r\n            } else {\r\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\r\n            }\r\n        }\r\n\r\n        blockGroups.forEach(group => handler(region, group));\r\n    });\r\n}\r\n\r\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\r\n    const nodes = collapseNodesInRegion(region, blocks);\r\n    wrap(nodes, KnownCreateElementDataIndex.BlockquoteWrapper);\r\n}\r\n\r\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\r\n    blocks.forEach(blockElement => {\r\n        let node = blockElement.collapseToSingleElement();\r\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\r\n        if (quote) {\r\n            if (node == quote) {\r\n                node = wrap(toArray(node.childNodes));\r\n            }\r\n\r\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (isNodeInRegion(region, node)) {\r\n                unwrap(node);\r\n            }\r\n        }\r\n    });\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\nimport applyInlineStyle from '../utils/applyInlineStyle';\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\n\n/**\n * Change the capitalization of text in the selection\n * @param editor The editor instance\n * @param capitalization The case option\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\n * Default is the host environment’s current locale.\n */\nexport default function changeCapitalization(\n    editor: IEditor,\n    capitalization: Capitalization,\n    language?: string\n) {\n    applyInlineStyle(editor, element => {\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\n            if (node.nodeType == NodeType.Text) {\n                try {\n                    node.textContent = getCapitalizedText(node.textContent, language);\n                } catch {\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\n                }\n            }\n        }\n    });\n\n    function getCapitalizedText(originalText: string, language: string): string {\n        switch (capitalization) {\n            case Capitalization.Lowercase:\n                return originalText.toLocaleLowerCase(language);\n            case Capitalization.Uppercase:\n                return originalText.toLocaleUpperCase(language);\n            case Capitalization.CapitalizeEachWord:\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\n                for (let i = 0; i < wordArray.length; i++) {\n                    wordArray[i] =\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\n                }\n                return wordArray.join(' ');\n            case Capitalization.Sentence:\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\n                // Find a match of a word character either:\n                // - At the beginning of a string with or without preceding whitespace, for\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\n                // - Or preceded by a punctuation mark and at least one whitespace, for\n                // example 'yes. hello world' would match 'y' and 'h'.\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\n                    return match.toLocaleUpperCase(language);\n                });\n        }\n    }\n}\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    toggleListType(editor, ListType.Unordered);\r\n}\r\n","import toggleListType from '../utils/toggleListType';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n * @param startNumber (Optional) Start number of the list\r\n */\r\nexport default function toggleNumbering(editor: IEditor, startNumber?: number) {\r\n    toggleListType(editor, ListType.Ordered, startNumber);\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquote elements,\r\n * the blockquote elements will be unquote and other elements will take no effect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, moveChildNodes } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            const div = editor.getDocument().createElement('div');\r\n            moveChildNodes(div, header);\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    CursorFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\n\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: !Browser.isChrome,\n};\n\n/**\n * @internal\n */\nexport const CursorFeatures: Record<\n    keyof CursorFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    noCycleCursorMove: NoCycleCursorMove,\n};\n","import {\n    cacheGetEventData,\n    getEntityFromElement,\n    getEntitySelector,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    EntityFeatureSettings,\n    EntityOperation,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\n    handleEvent: (event, editor) => {\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    operation?: EntityOperation\n) {\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const node = event.rawEvent.target as Node;\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromEnd\n        );\n    },\n};\n\n/**\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/,\n            EntityOperation.RemoveFromStart\n        );\n    },\n};\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    operation?: EntityOperation\n): HTMLElement {\n    const element = cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range).normalize();\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\n            let entityNode: HTMLElement = null;\n\n            if (isAtBeginOrEnd) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = isNext\n                    ? pos.offset == 0\n                        ? traverser.currentInlineElement\n                        : traverser.getNextInlineElement()\n                    : pos.isAtEnd\n                    ? traverser.currentInlineElement\n                    : traverser.getPreviousInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (!collapseOnly) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\n            }\n\n            return entityNode;\n        }\n    );\n\n    if (element && operation !== undefined) {\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent: event.rawEvent,\n            entity: getEntityFromElement(element),\n        });\n    }\n\n    return element;\n}\n\n/**\n * @internal\n */\nexport const EntityFeatures: Record<\n    keyof EntityFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    clickOnEntity: ClickOnEntityFeature,\n    escapeFromEntity: EscapeFromEntityFeature,\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\n};\n","import blockFormat from 'roosterjs-editor-api/lib/utils/blockFormat';\nimport {\n    experimentCommitListChains,\n    setIndentation,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\nimport {\n    Browser,\n    getTagOfNode,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n    VListChain,\n    createVListFromRegion,\n    isBlockElement,\n    cacheGetEventData,\n} from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Indentation,\n    ListFeatureSettings,\n    Keys,\n    PluginKeyboardEvent,\n    QueryScope,\n    RegionBase,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        let range = editor.getSelectionRange();\n        return li && range?.collapsed && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li.previousSibling) {\n            blockFormat(editor, (region, start, end) => {\n                const vList = createVListFromRegion(region, false /*includeSiblingList*/, li);\n                vList.setIndentation(start, end, Indentation.Decrease, true /*softOutdent*/);\n                vList.writeBack();\n                event.rawEvent.preventDefault();\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n    defaultDisabled: true,\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * MaintainListChainWhenDelete edit feature, provides the ability to indent the list if user press\n * DELETE before the first item of a list\n */\nconst MaintainListChainWhenDelete: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) => {\n        const li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        if (li) {\n            return false;\n        }\n        const isAtEnd = Position.getEnd(editor.getSelectionRange()).isAtEnd;\n        const nextSibiling = isAtEnd ? getCacheNextSibiling(event, editor) : null;\n        const isAtEndAndBeforeLI = editor.getElementAtCursor('LI', nextSibiling, event);\n        return isAtEndAndBeforeLI;\n    },\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.addUndoSnapshot(\n            () => toggleListAndPreventDefault(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\n};\n\n/**\n * AutoBullet edit feature, provides the ability to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = editor.getContentSearcherOfCursor(event);\n            let textBeforeCursor = searcher.getSubStringBefore(4);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly matches '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return isAListPattern(textBeforeCursor) && !searcher.getNearestNonTextInlineElement();\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.insertContent('&nbsp;');\n        event.rawEvent.preventDefault();\n        editor.addUndoSnapshot(\n            () => {\n                let regions: RegionBase[];\n                let searcher = editor.getContentSearcherOfCursor();\n                let textBeforeCursor = searcher.getSubStringBefore(4);\n                let rangeToDelete = searcher.getRangeFromText(\n                    textBeforeCursor,\n                    true /*exactMatch*/\n                );\n\n                if (!rangeToDelete) {\n                    // no op if the range can't be found\n                } else if (\n                    textBeforeCursor.indexOf('*') == 0 ||\n                    textBeforeCursor.indexOf('-') == 0\n                ) {\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleBullet(editor);\n                } else if (isAListPattern(textBeforeCursor)) {\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleNumbering(editor);\n                } else if ((regions = editor.getSelectedRegions()) && regions.length == 1) {\n                    const num = parseInt(textBeforeCursor);\n                    prepareAutoBullet(editor, rangeToDelete);\n                    toggleNumbering(editor, num);\n                }\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    },\n};\n\n/**\n * Maintain the list numbers in list chain\n * e.g. we have two lists:\n * 1, 2, 3 and 4, 5, 6\n * Now we delete list item 2, so the first one becomes \"1, 2\".\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\n */\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\n    shouldHandleEvent: (event, editor) =>\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\n    handleEvent: (event, editor) => {\n        const chains = getListChains(editor);\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\n    },\n};\n\n/**\n * Validate if a block of text is considered a list pattern\n * The regex expression will look for patterns of the form:\n * 1.  1>  1)  1-  (1)\n * @returns if a text is considered a list pattern\n */\nfunction isAListPattern(textBeforeCursor: string) {\n    const REGEX: RegExp = /^(\\*|-|[0-9]{1,2}\\.|[0-9]{1,2}\\>|[0-9]{1,2}\\)|[0-9]{1,2}\\-|\\([0-9]{1,2}\\))$/;\n    return REGEX.test(textBeforeCursor);\n}\n\nfunction getListChains(editor: IEditor) {\n    return VListChain.createListChains(editor.getSelectedRegions());\n}\n\nfunction getCacheNextSibiling(event: PluginKeyboardEvent, editor: IEditor): Node | undefined {\n    const element = cacheGetEventData(event, 'nextSibiling', () => {\n        const range = editor.getSelectionRange();\n        const pos = Position.getEnd(range).normalize();\n        const traverser = editor.getBodyTraverser(pos.node);\n        return traverser?.getNextBlockElement()?.getStartNode();\n    });\n    return element;\n}\n\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\n    range.deleteContents();\n\n    const block = editor.getBlockElementAtNode(range.startContainer);\n    const endNode = block?.getEndNode();\n    if (endNode && getTagOfNode(endNode) != 'BR' && block?.getTextContent().trim() === '') {\n        const br = editor.getDocument().createElement('BR');\n        if (isBlockElement(endNode)) {\n            endNode.appendChild(br);\n        } else {\n            endNode.parentNode.insertBefore(br, endNode.nextSibling);\n        }\n        editor.select(range.startContainer, range.startOffset);\n    }\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n\n/**\n * @internal\n */\nexport const ListFeatures: Record<\n    keyof ListFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    autoBullet: AutoBullet,\n    indentWhenTab: IndentWhenTab,\n    outdentWhenShiftTab: OutdentWhenShiftTab,\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n    maintainListChain: MaintainListChain,\n    maintainListChainWhenDelete: MaintainListChainWhenDelete,\n};\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    ChangeSource,\n    IEditor,\n    Keys,\n    MarkdownFeatureSettings,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): BuildInEditFeature<PluginKeyboardEvent> {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(editor => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = editor.getContentSearcherOfCursor(event);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: IEditor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.addUndoSnapshot(\n        () => {\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n            if (!!range) {\n                // get the text content range\n                const textContentRange = range.cloneRange();\n                textContentRange.setStart(\n                    textContentRange.startContainer,\n                    textContentRange.startOffset + 1\n                );\n\n                // set the removal range to include the typed last character.\n                range.setEnd(range.endContainer, range.endOffset + 1);\n\n                // extract content and put it into a new element.\n                const elementToWrap = editor.getDocument().createElement(elementTag);\n                elementToWrap.appendChild(textContentRange.extractContents());\n                range.deleteContents();\n\n                // ZWS here ensures we don't end up inside the newly created node.\n                const nonPrintedSpaceTextNode = editor\n                    .getDocument()\n                    .createTextNode(ZERO_WIDTH_SPACE);\n                range.insertNode(nonPrintedSpaceTextNode);\n                range.insertNode(elementToWrap);\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\n            }\n        },\n        ChangeSource.Format,\n        true /*canUndoByBackspace*/\n    );\n}\n\n/**\n * Markdown bold feature. Make bold text with markdown shortcuts.\n */\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Make italic text with markdown shortcuts.\n */\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethrough feature. MAke strikethrough text with markdown shortcuts.\n */\nconst MarkdownStrikethrough: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n\n/**\n * @internal\n */\nexport const MarkdownFeatures: Record<\n    keyof MarkdownFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    markdownBold: MarkdownBold,\n    markdownItalic: MarkdownItalic,\n    markdownStrikethru: MarkdownStrikethrough,\n    markdownInlineCode: MarkdownInlineCode,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    PluginKeyboardEvent,\n    PositionType,\n    QuoteFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) =>\n        editor.addUndoSnapshot(\n            () => splitQuote(event, editor),\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        ),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n\n/**\n * @internal\n */\nexport const QuoteFeatures: Record<\n    keyof QuoteFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n};\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\nimport {\n    BuildInEditFeature,\n    FontSizeChange,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ShortcutFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: IEditor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special characters\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n\n/**\n * @internal\n */\nexport const ShortcutFeatures: Record<\n    keyof ShortcutFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    defaultShortcut: DefaultShortcut,\n};\n","import {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    KnownCreateElementDataIndex,\n    PluginKeyboardEvent,\n    PositionType,\n    StructuredNodeFeatureSettings,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetEventData,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n    createElement,\n} from 'roosterjs-editor-dom';\n\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = createElement(\n            KnownCreateElementDataIndex.EmptyLine,\n            editor.getDocument()\n        ) as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n    defaultDisabled: true,\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n\n/**\n * @internal\n */\nexport const StructuredNodeFeatures: Record<\n    keyof StructuredNodeFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n};\n","import { editTable } from 'roosterjs-editor-api';\nimport {\n    BuildInEditFeature,\n    IEditor,\n    Keys,\n    NodeType,\n    PluginEvent,\n    PositionType,\n    TableFeatureSettings,\n    TableOperation,\n    PluginKeyboardEvent,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    cacheGetEventData,\n    contains,\n    getTagOfNode,\n    isVoidHtmlElement,\n    Position,\n    VTable,\n} from 'roosterjs-editor-dom';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0) {\n                    editor.select(vtable.table, PositionType.Before);\n                    break;\n                } else if (row >= vtable.cells.length) {\n                    editTable(editor, TableOperation.InsertBelow);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        const td = cacheGetTableCell(event, editor);\n        const vtable = new VTable(td);\n        const isUp = event.rawEvent.which == Keys.UP;\n        const step = isUp ? -1 : 1;\n        const hasShiftKey = event.rawEvent.shiftKey;\n        const selection = editor.getDocument().defaultView?.getSelection();\n        let targetTd: HTMLTableCellElement = null;\n\n        if (selection) {\n            let { anchorNode, anchorOffset } = selection;\n\n            for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n                let cell = vtable.getCell(row, vtable.col);\n                if (cell.td && cell.td != td) {\n                    targetTd = cell.td;\n                    break;\n                }\n            }\n\n            editor.runAsync(editor => {\n                let newContainer = editor.getElementAtCursor();\n                if (\n                    contains(vtable.table, newContainer) &&\n                    !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n                ) {\n                    let newPos = targetTd\n                        ? new Position(targetTd, PositionType.Begin)\n                        : new Position(\n                              vtable.table,\n                              isUp ? PositionType.Before : PositionType.After\n                          );\n                    if (hasShiftKey) {\n                        newPos =\n                            newPos.node.nodeType == NodeType.Element &&\n                            isVoidHtmlElement(newPos.node)\n                                ? new Position(\n                                      newPos.node,\n                                      newPos.isAtEnd ? PositionType.After : PositionType.Before\n                                  )\n                                : newPos;\n                        const selection = editor.getDocument().defaultView?.getSelection();\n                        selection?.setBaseAndExtent(\n                            anchorNode,\n                            anchorOffset,\n                            newPos.node,\n                            newPos.offset\n                        );\n                    } else {\n                        editor.select(newPos);\n                    }\n                }\n            });\n        }\n    },\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLE_CELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n\n/**\n * @internal\n */\nexport const TableFeatures: Record<\n    keyof TableFeatureSettings,\n    BuildInEditFeature<PluginKeyboardEvent>\n> = {\n    tabInTable: TabInTable,\n    upDownInTable: UpDownInTable,\n};\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n    TrustedHTMLHandler,\r\n} from 'roosterjs-editor-types';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n    toArray,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n            trustedHTMLHandler: options.trustedHTMLHandler || ((html: string) => html),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ancestor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start through end after splitting\r\n     * False to disallow split parent\r\n     * @returns When canSplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trim the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            const body = new DOMParser().parseFromString(\r\n                this.core.trustedHTMLHandler(content),\r\n                'text/html'\r\n            )?.body;\r\n            let allNodes = body?.childNodes ? toArray(body.childNodes) : [];\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original format.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView?.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first ancestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    public getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Get current relative distance from top-left corner of the given element to top-left corner of editor content DIV.\r\n     * @param element The element to calculate from. If the given element is not in editor, return value will be null\r\n     * @param addScroll When pass true, The return value will also add scrollLeft and scrollTop if any. So the value\r\n     * may be different than what user is seeing from the view. When pass false, scroll position will be ignored.\r\n     * @returns An [x, y] array which contains the left and top distances, or null if the given element is not in editor.\r\n     */\r\n    getRelativeDistanceToEditor(element: HTMLElement, addScroll?: boolean): number[] {\r\n        if (this.contains(element)) {\r\n            const contentDiv = this.core.contentDiv;\r\n            const editorRect = contentDiv.getBoundingClientRect();\r\n            const elementRect = element.getBoundingClientRect();\r\n\r\n            if (editorRect && elementRect) {\r\n                let x = elementRect.left - editorRect?.left;\r\n                let y = elementRect.top - editorRect?.top;\r\n\r\n                if (addScroll) {\r\n                    x += contentDiv.scrollLeft;\r\n                    y += contentDiv.scrollTop;\r\n                }\r\n\r\n                return [x, y];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Make the editor in \"Shadow Edit\" mode.\r\n     * In Shadow Edit mode, all format change will finally be ignored.\r\n     * This can be used for building a live preview feature for format button, to allow user\r\n     * see format result without really apply it.\r\n     * This function can be called repeated. If editor is already in shadow edit mode, we can still\r\n     * use this function to do more shadow edit operation.\r\n     */\r\n    public startShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, true /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Leave \"Shadow Edit\" mode, all changes made during shadow edit will be discarded\r\n     */\r\n    public stopShadowEdit() {\r\n        this.core.api.switchShadowEdit(this.core, false /*isOn*/);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in Shadow Edit mode\r\n     */\r\n    public isInShadowEdit() {\r\n        return !!this.core.lifecycle.shadowEditFragment;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Get a function to convert HTML string to trusted HTML string.\r\n     * By default it will just return the input HTML directly. To override this behavior,\r\n     * pass your own trusted HTML handler to EditorOptions.trustedHTMLHandler\r\n     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types\r\n     */\r\n    getTrustedHTMLHandler(): TrustedHTMLHandler {\r\n        return this.core.trustedHTMLHandler;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\nimport { attachDomEvent } from './attachDomEvent';\nimport { CoreApiMap } from 'roosterjs-editor-types';\nimport { createPasteFragment } from './createPasteFragment';\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\nimport { focus } from './focus';\nimport { getContent } from './getContent';\nimport { getSelectionRange } from './getSelectionRange';\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\nimport { hasFocus } from './hasFocus';\nimport { insertNode } from './insertNode';\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\nimport { selectRange } from './selectRange';\nimport { setContent } from './setContent';\nimport { switchShadowEdit } from './switchShadowEdit';\nimport { transformColor } from './transformColor';\nimport { triggerEvent } from './triggerEvent';\n\n/**\n * @internal\n */\nexport const coreApiMap: CoreApiMap = {\n    attachDomEvent,\n    addUndoSnapshot,\n    createPasteFragment,\n    ensureTypeInContainer,\n    focus,\n    getContent,\n    getSelectionRange,\n    getStyleBasedFormatState,\n    hasFocus,\n    insertNode,\n    restoreUndoSnapshot,\n    selectRange,\n    setContent,\n    switchShadowEdit,\n    transformColor,\n    triggerEvent,\n};\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    AddUndoSnapshot,\n    ChangeSource,\n    ContentChangedEvent,\n    EditorCore,\n    NodePosition,\n    PluginEventType,\n    GetContentMode,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\n * @param core The EditorCore object\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complete).\n */\nexport const addUndoSnapshot: AddUndoSnapshot = (\n    core: EditorCore,\n    callback: (start: NodePosition, end: NodePosition) => any,\n    changeSource: ChangeSource | string,\n    canUndoByBackspace: boolean\n) => {\n    const undoState = core.undo;\n    const isNested = undoState.isNested;\n    const isShadowEdit = !!core.lifecycle.shadowEditFragment;\n    let data: any;\n\n    if (!isNested) {\n        undoState.isNested = true;\n\n        if (!isShadowEdit) {\n            undoState.snapshotsService.addSnapshot(\n                core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                canUndoByBackspace\n            );\n            undoState.hasNewContent = false;\n        }\n    }\n\n    try {\n        if (callback) {\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            data = callback(\n                range && Position.getStart(range).normalize(),\n                range && Position.getEnd(range).normalize()\n            );\n\n            if (!isNested && !isShadowEdit) {\n                undoState.snapshotsService.addSnapshot(\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\n                    false /*isAutoCompleteSnapshot*/\n                );\n                undoState.hasNewContent = false;\n            }\n        }\n    } finally {\n        if (!isNested) {\n            undoState.isNested = false;\n        }\n    }\n\n    if (callback && changeSource) {\n        let event: ContentChangedEvent = {\n            eventType: PluginEventType.ContentChanged,\n            source: changeSource,\n            data: data,\n        };\n        core.api.triggerEvent(core, event, true /*broadcast*/);\n    }\n\n    if (canUndoByBackspace) {\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\n\n        if (range) {\n            core.undo.hasNewContent = false;\n            core.undo.autoCompletePosition = Position.getStart(range);\n        }\n    }\n};\n","import {\n    AttachDomEvent,\n    DOMEventHandler,\n    DOMEventHandlerObject,\n    EditorCore,\n    PluginDomEvent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Attach a DOM event to the editor content DIV\n * @param core The EditorCore object\n * @param eventName The DOM event name\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\n */\nexport const attachDomEvent: AttachDomEvent = (\n    core: EditorCore,\n    eventMap: Record<string, DOMEventHandler>\n) => {\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\n        let onEvent = (event: UIEvent) => {\n            if (beforeDispatch) {\n                beforeDispatch(event);\n            }\n            if (pluginEventType != null) {\n                core.api.triggerEvent(\n                    core,\n                    <PluginDomEvent>{\n                        eventType: pluginEventType,\n                        rawEvent: event,\n                    },\n                    false /*broadcast*/\n                );\n            }\n        };\n        core.contentDiv.addEventListener(eventName, onEvent);\n        return () => {\n            core.contentDiv.removeEventListener(eventName, onEvent);\n        };\n    });\n    return () => disposers.forEach(disposers => disposers());\n};\n\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\n    let result: DOMEventHandlerObject = {\n        pluginEventType: null,\n        beforeDispatch: null,\n    };\n\n    if (typeof handlerObj === 'number') {\n        result.pluginEventType = handlerObj;\n    } else if (typeof handlerObj === 'function') {\n        result.beforeDispatch = handlerObj;\n    } else if (typeof handlerObj === 'object') {\n        result = handlerObj;\n    }\n    return result;\n}\n","import {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n    moveChildNodes,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    CreatePasteFragment,\n    EditorCore,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\n/**\n * @internal\n * Create a DocumentFragment for paste from a ClipboardData\n * @param core The EditorCore object.\n * @param clipboardData Clipboard data retrieved from clipboard\n * @param position The position to paste to\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\n * false to keep original format\n */\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    if (!clipboardData) {\n        return null;\n    }\n\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData);\n    const { fragment, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    const document = core.contentDiv.ownerDocument;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (!pasteAsText && !text && imageDataUri) {\n        // Paste image\n        const img = document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        !pasteAsText &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(core.trustedHTMLHandler(rawHtml), 'text/html'))?.body\n    ) {\n        // Paste HTML\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            clipboardData.html = rawHtml.substring(startIndex + START_FRAGMENT.length, endIndex);\n            doc.body.innerHTML = core.trustedHTMLHandler(clipboardData.html);\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        moveChildNodes(fragment, doc.body);\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        // Paste text\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n            const textNode = document.createTextNode(line);\n\n            // There are 3 scenarios:\n            // 1. Single line: Paste as it is\n            // 2. Two lines: Add <br> between the lines\n            // 3. 3 or More lines, For first and last line, paste as it is. For middle lines, wrap with DIV, and add BR if it is empty line\n            if (lines.length == 2 && index == 0) {\n                // 1 of 2 lines scenario, add BR\n                fragment.appendChild(textNode);\n                fragment.appendChild(document.createElement('br'));\n            } else if (index > 0 && index < lines.length - 1) {\n                // Middle line of >=3 lines scenario, wrap with DIV\n                fragment.appendChild(wrap(line == '' ? document.createElement('br') : textNode));\n            } else {\n                // All others, paste as it is\n                fragment.appendChild(textNode);\n            }\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\n    const styleBasedFormat = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedFormat.fontName,\n        fontSize: styleBasedFormat.fontSize,\n        textColor: styleBasedFormat.textColor,\n        backgroundColor: styleBasedFormat.backgroundColor,\n        textColors: styleBasedFormat.textColors,\n        backgroundColors: styleBasedFormat.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    toArray(node.querySelectorAll('style')).forEach(callback);\n}\n","import {\n    ContentPosition,\n    EditorCore,\n    EnsureTypeInContainer,\n    KnownCreateElementDataIndex,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    applyFormat,\n    createElement,\n    createRange,\n    getBlockElementAtNode,\n    isNodeEmpty,\n    Position,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * When typing goes directly under content div, many things can go wrong\n * We fix it by wrapping it with a div and reposition cursor within the div\n */\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\n    core: EditorCore,\n    position: NodePosition,\n    keyboardEvent?: KeyboardEvent\n) => {\n    position = position.normalize();\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\n    let formatNode: HTMLElement;\n\n    if (block) {\n        formatNode = block.collapseToSingleElement();\n\n        // if the block is empty, apply default format\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\n        const shouldSetNodeStyles =\n            isNodeEmpty(formatNode) ||\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\n    } else {\n        // Only reason we don't get the selection block is that we have an empty content div\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\n        formatNode = createElement(\n            KnownCreateElementDataIndex.EmptyLine,\n            core.contentDiv.ownerDocument\n        ) as HTMLElement;\n        core.api.insertNode(core, formatNode, {\n            position: ContentPosition.End,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\n        position = new Position(formatNode.firstChild, PositionType.Begin);\n    }\n\n    if (formatNode) {\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\n    }\n\n    // If this is triggered by a keyboard event, let's select the new position\n    if (keyboardEvent) {\n        core.api.selectRange(core, createRange(position));\n    }\n};\n\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\n    return (\n        safeInstanceOf(event.target, 'Node') &&\n        event.target.contains(formatNode) &&\n        event.key === formatNode.innerText\n    );\n}\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Focus to editor. If there is a cached selection range, use it as current selection\n * @param core The EditorCore object\n */\nexport const focus: Focus = (core: EditorCore) => {\n    if (!core.lifecycle.shadowEditFragment) {\n        if (\n            !core.api.hasFocus(core) ||\n            !core.api.getSelectionRange(core, false /*tryGetFromCache*/)\n        ) {\n            // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\n            // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\n            // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\n            // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\n            // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\n            // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\n            // It should be better than the case you cannot type\n            if (\n                !core.domEvent.selectionRange ||\n                !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\n            ) {\n                let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\n                core.api.selectRange(\n                    core,\n                    createRange(node, PositionType.Begin),\n                    true /*skipSameRange*/\n                );\n            }\n        }\n\n        // remember to clear cached selection range\n        core.domEvent.selectionRange = null;\n\n        // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\n        if (!core.api.hasFocus(core)) {\n            core.contentDiv.focus();\n        }\n    }\n};\n","import {\n    ColorTransformDirection,\n    EditorCore,\n    GetContent,\n    GetContentMode,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getHtmlWithSelectionPath,\n    getSelectionPath,\n    getTextContent,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Get current editor content as HTML string\n * @param core The EditorCore object\n * @param mode specify what kind of HTML content to retrieve\n * @returns HTML string representing current editor content\n */\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\n    let content = '';\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\n\n    // When there is fragment for shadow edit, always use the cached fragment as document since HTML node in editor\n    // has been changed by uncommitted shadow edit which should be ignored.\n    const root = core.lifecycle.shadowEditFragment || core.contentDiv;\n\n    if (mode == GetContentMode.PlainText) {\n        content = getTextContent(root);\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\n        const clonedRoot = cloneNode(root);\n        clonedRoot.normalize();\n\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n        const path = !includeSelectionMarker\n            ? null\n            : core.lifecycle.shadowEditFragment\n            ? core.lifecycle.shadowEditSelectionPath\n            : originalRange\n            ? getSelectionPath(core.contentDiv, originalRange)\n            : null;\n        const range = path && createRange(clonedRoot, path.start, path.end);\n\n        if (core.lifecycle.isDarkMode) {\n            core.api.transformColor(\n                core,\n                clonedRoot,\n                false /*includeSelf*/,\n                null /*callback*/,\n                ColorTransformDirection.DarkToLight\n            );\n        }\n\n        if (triggerExtractContentEvent) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.ExtractContentWithDom,\n                    clonedRoot,\n                },\n                true /*broadcast*/\n            );\n\n            content = clonedRoot.innerHTML;\n        } else if (range) {\n            // range is not null, which means we want to include a selection path in the content\n            content = getHtmlWithSelectionPath(clonedRoot, range);\n        } else {\n            content = clonedRoot.innerHTML;\n        }\n    } else {\n        content = getHtmlWithSelectionPath(\n            root,\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\n        );\n    }\n\n    return content;\n};\n\nfunction cloneNode(node: HTMLElement | DocumentFragment): HTMLElement {\n    let clonedNode: HTMLElement;\n    if (safeInstanceOf(node, 'DocumentFragment')) {\n        clonedNode = node.ownerDocument.createElement('div');\n        clonedNode.appendChild(node.cloneNode(true /*deep*/));\n    } else {\n        clonedNode = node.cloneNode(true /*deep*/) as HTMLElement;\n    }\n\n    return clonedNode;\n}\n","import { contains, createRange } from 'roosterjs-editor-dom';\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get current or cached selection range\n * @param core The EditorCore object\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\n * @returns A Range object of the selection range\n */\nexport const getSelectionRange: GetSelectionRange = (\n    core: EditorCore,\n    tryGetFromCache: boolean\n) => {\n    let result: Range = null;\n\n    if (core.lifecycle.shadowEditFragment) {\n        result =\n            core.lifecycle.shadowEditSelectionPath &&\n            createRange(\n                core.contentDiv,\n                core.lifecycle.shadowEditSelectionPath.start,\n                core.lifecycle.shadowEditSelectionPath.end\n            );\n\n        return result;\n    } else {\n        if (!tryGetFromCache || core.api.hasFocus(core)) {\n            let selection = core.contentDiv.ownerDocument.defaultView?.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                let range = selection.getRangeAt(0);\n                if (contains(core.contentDiv, range)) {\n                    result = range;\n                }\n            }\n        }\n\n        if (!result && tryGetFromCache) {\n            result = core.domEvent.selectionRange;\n        }\n\n        return result;\n    }\n};\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\n\n/**\n * @internal\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.lifecycle.isDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor:\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\n                      ] ||\n                      ogBackgroundColorNode.dataset[\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\n                      ],\n              }\n            : undefined,\n    };\n};\n","import {\n    BlockElement,\n    ContentPosition,\n    ColorTransformDirection,\n    EditorCore,\n    InsertNode,\n    InsertOption,\n    NodeType,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    createRange,\n    getBlockElementAtNode,\n    getFirstLastBlockElement,\n    isBlockElement,\n    isVoidHtmlElement,\n    Position,\n    safeInstanceOf,\n    toArray,\n    wrap,\n    adjustInsertPosition,\n} from 'roosterjs-editor-dom';\n\nfunction getInitialRange(\n    core: EditorCore,\n    option: InsertOption\n): { range: Range; rangeToRestore: Range } {\n    // Selection start replaces based on the current selection.\n    // Range inserts based on a provided range.\n    // Both have the potential to use the current selection to restore cursor position\n    // So in both cases we need to store the selection state.\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n    let rangeToRestore = null;\n    if (option.position == ContentPosition.Range) {\n        rangeToRestore = range;\n        range = option.range;\n    } else if (range) {\n        rangeToRestore = range.cloneRange();\n    }\n\n    return { range, rangeToRestore };\n}\n\n/**\n * @internal\n * Insert a DOM node into editor content\n * @param core The EditorCore object. No op if null.\n * @param option An insert option object to specify how to insert the node\n */\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\n    option = option || {\n        position: ContentPosition.SelectionStart,\n        insertOnNewLine: false,\n        updateCursor: true,\n        replaceSelection: true,\n    };\n    let contentDiv = core.contentDiv;\n\n    if (option.updateCursor) {\n        core.api.focus(core);\n    }\n\n    if (option.position == ContentPosition.Outside) {\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\n        return true;\n    }\n\n    core.api.transformColor(\n        core,\n        node,\n        true /*includeSelf*/,\n        () => {\n            switch (option.position) {\n                case ContentPosition.Begin:\n                case ContentPosition.End: {\n                    let isBegin = option.position == ContentPosition.Begin;\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\n                    let insertedNode: Node | Node[];\n                    if (block) {\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\n                        if (\n                            option.insertOnNewLine ||\n                            refNode.nodeType == NodeType.Text ||\n                            isVoidHtmlElement(refNode)\n                        ) {\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\n                                // because insertBefore() returns an empty DocumentFragment\n                                insertedNode = toArray(node.childNodes);\n                                refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            } else {\n                                insertedNode = refNode.parentNode.insertBefore(\n                                    node,\n                                    isBegin ? refNode : refNode.nextSibling\n                                );\n                            }\n                        } else {\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\n                            insertedNode = refNode.insertBefore(\n                                node,\n                                isBegin ? refNode.firstChild : null\n                            );\n                        }\n                    } else {\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\n                        insertedNode = contentDiv.appendChild(node);\n                    }\n\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine) {\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\n                            wrap(nodes);\n                        }\n                    }\n\n                    break;\n                }\n                case ContentPosition.DomEnd:\n                    // Use appendChild to insert the node at the end of the content div.\n                    let insertedNode = contentDiv.appendChild(node);\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\n                    // add a DIV wrapping\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\n                        wrap(insertedNode);\n                    }\n                    break;\n                case ContentPosition.Range:\n                case ContentPosition.SelectionStart:\n                    let { range, rangeToRestore } = getInitialRange(core, option);\n                    if (!range) {\n                        return;\n                    }\n\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\n                    if (option.replaceSelection && !range.collapsed) {\n                        range.deleteContents();\n                    }\n\n                    let pos = Position.getStart(range);\n                    let blockElement: BlockElement;\n\n                    if (\n                        option.insertOnNewLine &&\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\n                    ) {\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\n                    } else {\n                        pos = adjustInsertPosition(contentDiv, node, pos, range);\n                    }\n\n                    let nodeForCursor =\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\n                    range = createRange(pos);\n                    range.insertNode(node);\n                    if (option.updateCursor && nodeForCursor) {\n                        rangeToRestore = createRange(\n                            new Position(nodeForCursor, PositionType.After).normalize()\n                        );\n                    }\n                    core.api.selectRange(core, rangeToRestore);\n\n                    break;\n            }\n        },\n        ColorTransformDirection.LightToDark\n    );\n\n    return true;\n};\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Restore an undo snapshot into editor\n * @param core The editor core object\n * @param step Steps to move, can be 0, positive or negative\n */\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\n    if (core.undo.hasNewContent && step < 0) {\n        core.api.addUndoSnapshot(\n            core,\n            null /*callback*/,\n            null /*changeSource*/,\n            false /*canUndoByBackspace*/\n        );\n    }\n\n    const snapshot = core.undo.snapshotsService.move(step);\n\n    if (snapshot != null) {\n        try {\n            core.undo.isRestoring = true;\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\n        } finally {\n            core.undo.isRestoring = false;\n        }\n    }\n};\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\nimport { hasFocus } from './hasFocus';\nimport {\n    contains,\n    getPendableFormatState,\n    Position,\n    PendableFormatNames,\n    PendableFormatCommandMap,\n    addRangeToSelection,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Change the editor selection to the given range\n * @param core The EditorCore object\n * @param range The range to select\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\n * in editor, otherwise it will always remove current selection range and set to the given one.\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\n */\nexport const selectRange: SelectRange = (\n    core: EditorCore,\n    range: Range,\n    skipSameRange?: boolean\n) => {\n    if (!core.lifecycle.shadowEditSelectionPath && contains(core.contentDiv, range)) {\n        addRangeToSelection(range, skipSameRange);\n\n        if (!hasFocus(core)) {\n            core.domEvent.selectionRange = range;\n        }\n\n        if (range.collapsed) {\n            // If selected, and current selection is collapsed,\n            // need to restore pending format state if exists.\n            restorePendingFormatState(core);\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Restore cached pending format state (if exist) to current selection\n */\nfunction restorePendingFormatState(core: EditorCore) {\n    const {\n        contentDiv,\n        pendingFormatState,\n        api: { getSelectionRange },\n    } = core;\n\n    if (pendingFormatState.pendableFormatState) {\n        const document = contentDiv.ownerDocument;\n        let formatState = getPendableFormatState(document);\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\n                document.execCommand(PendableFormatCommandMap[key], false, null);\n            }\n        });\n\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\n    }\n}\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ColorTransformDirection,\n    EditorCore,\n    PluginEventType,\n    SetContent,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\n * if triggerContentChangedEvent is set to true\n * @param core The EditorCore object\n * @param content HTML content to set in\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\n */\nexport const setContent: SetContent = (\n    core: EditorCore,\n    content: string,\n    triggerContentChangedEvent: boolean\n) => {\n    let contentChanged = false;\n    if (core.contentDiv.innerHTML != content) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.BeforeSetContent,\n                newContent: content,\n            },\n            true /*broadcast*/\n        );\n\n        const range = setHtmlWithSelectionPath(core.contentDiv, content, core.trustedHTMLHandler);\n        core.api.selectRange(core, range);\n        contentChanged = true;\n    }\n\n    // Convert content even if it hasn't changed.\n    core.api.transformColor(\n        core,\n        core.contentDiv,\n        false /*includeSelf*/,\n        null /*callback*/,\n        ColorTransformDirection.LightToDark\n    );\n\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\n        core.api.triggerEvent(\n            core,\n            {\n                eventType: PluginEventType.ContentChanged,\n                source: ChangeSource.SetContent,\n            },\n            false /*broadcast*/\n        );\n    }\n};\n","import { createRange, getSelectionPath, moveChildNodes } from 'roosterjs-editor-dom';\nimport { EditorCore, PluginEventType, SwitchShadowEdit } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const switchShadowEdit: SwitchShadowEdit = (core: EditorCore, isOn: boolean): void => {\n    const { lifecycle, contentDiv } = core;\n    let { shadowEditFragment, shadowEditSelectionPath } = lifecycle;\n    const wasInShadowEdit = !!shadowEditFragment;\n\n    if (isOn) {\n        if (!wasInShadowEdit) {\n            const range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\n            shadowEditSelectionPath = range && getSelectionPath(contentDiv, range);\n            shadowEditFragment = core.contentDiv.ownerDocument.createDocumentFragment();\n\n            moveChildNodes(shadowEditFragment, contentDiv);\n            shadowEditFragment.normalize();\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.EnteredShadowEdit,\n                    fragment: shadowEditFragment,\n                    selectionPath: shadowEditSelectionPath,\n                },\n                false /*broadcast*/\n            );\n\n            lifecycle.shadowEditFragment = shadowEditFragment;\n            lifecycle.shadowEditSelectionPath = shadowEditSelectionPath;\n        }\n\n        moveChildNodes(contentDiv);\n        contentDiv.appendChild(lifecycle.shadowEditFragment.cloneNode(true /*deep*/));\n    } else {\n        lifecycle.shadowEditFragment = null;\n        lifecycle.shadowEditSelectionPath = null;\n\n        if (wasInShadowEdit) {\n            core.api.triggerEvent(\n                core,\n                {\n                    eventType: PluginEventType.LeavingShadowEdit,\n                },\n                false /*broadcast*/\n            );\n\n            moveChildNodes(contentDiv);\n            contentDiv.appendChild(shadowEditFragment);\n            core.api.focus(core);\n\n            if (shadowEditSelectionPath) {\n                core.api.selectRange(\n                    core,\n                    createRange(\n                        contentDiv,\n                        shadowEditSelectionPath.start,\n                        shadowEditSelectionPath.end\n                    )\n                );\n            }\n        }\n    }\n};\n","import { arrayPush, getComputedStyles, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\nimport {\n    ColorTransformDirection,\n    DarkModeDatasetNames,\n    EditorCore,\n    TransformColor,\n} from 'roosterjs-editor-types';\n\nconst enum ColorAttributeEnum {\n    CssColor = 0,\n    HtmlColor = 1,\n    CssDataSet = 2,\n    HtmlDataSet = 3,\n}\n\nconst ColorAttributeName: { [key in ColorAttributeEnum]: string }[] = [\n    {\n        [ColorAttributeEnum.CssColor]: 'color',\n        [ColorAttributeEnum.HtmlColor]: 'color',\n        [ColorAttributeEnum.CssDataSet]: DarkModeDatasetNames.OriginalStyleColor,\n        [ColorAttributeEnum.HtmlDataSet]: DarkModeDatasetNames.OriginalAttributeColor,\n    },\n    {\n        [ColorAttributeEnum.CssColor]: 'background-color',\n        [ColorAttributeEnum.HtmlColor]: 'bgcolor',\n        [ColorAttributeEnum.CssDataSet]: DarkModeDatasetNames.OriginalStyleBackgroundColor,\n        [ColorAttributeEnum.HtmlDataSet]: DarkModeDatasetNames.OriginalAttributeBackgroundColor,\n    },\n];\n\n/**\n * @internal\n * Edit and transform color of elements between light mode and dark mode\n * @param core The EditorCore object\n * @param rootNode The root HTML elements to transform\n * @param includeSelf True to transform the root node as well, otherwise false\n * @param callback The callback function to invoke before do color transformation\n * @param direction To specify the transform direction, light to dark, or dark to light\n */\nexport const transformColor: TransformColor = (\n    core: EditorCore,\n    rootNode: Node,\n    includeSelf: boolean,\n    callback: () => void,\n    direction: ColorTransformDirection\n) => {\n    const elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\n    const transformFunction =\n        direction == ColorTransformDirection.DarkToLight\n            ? transformToLightMode\n            : core.lifecycle.onExternalContentTransform ||\n              ((element: HTMLElement) => transformToDarkMode(element, core.lifecycle.getDarkColor));\n\n    callback?.();\n\n    elementsToTransform.forEach(\n        element => element?.dataset && element.style && transformFunction(element)\n    );\n};\n\nfunction transformToLightMode(element: HTMLElement) {\n    ColorAttributeName.forEach(names => {\n        // Reset color styles based on the content of the ogsc/ogsb data element.\n        // If those data properties are empty or do not exist, set them anyway to clear the content.\n        element.style.setProperty(\n            names[ColorAttributeEnum.CssColor],\n            getValueOrDefault(element.dataset[names[ColorAttributeEnum.CssDataSet]], '')\n        );\n        delete element.dataset[names[ColorAttributeEnum.CssDataSet]];\n\n        // Some elements might have set attribute colors. We need to reset these as well.\n        const value = element.dataset[names[ColorAttributeEnum.HtmlDataSet]];\n\n        if (getValueOrDefault(value, null)) {\n            element.setAttribute(names[ColorAttributeEnum.HtmlColor], value);\n        } else {\n            element.removeAttribute(names[ColorAttributeEnum.HtmlColor]);\n        }\n\n        delete element.dataset[names[ColorAttributeEnum.HtmlDataSet]];\n    });\n}\n\nfunction transformToDarkMode(element: HTMLElement, getDarkColor: (color: string) => string) {\n    const computedValues = getComputedStyles(element, ['color', 'background-color']);\n\n    ColorAttributeName.forEach((names, index) => {\n        const styleColor = element.style.getPropertyValue(names[ColorAttributeEnum.CssColor]);\n        const attrColor = element.getAttribute(names[ColorAttributeEnum.HtmlColor]);\n\n        if (\n            !element.dataset[names[ColorAttributeEnum.CssDataSet]] &&\n            !element.dataset[names[ColorAttributeEnum.HtmlDataSet]] &&\n            (styleColor || attrColor)\n        ) {\n            const newColor = getDarkColor(computedValues[index] || styleColor || attrColor);\n            element.style.setProperty(names[ColorAttributeEnum.CssColor], newColor, 'important');\n            element.dataset[names[ColorAttributeEnum.CssDataSet]] = styleColor || '';\n\n            if (attrColor) {\n                element.setAttribute(names[ColorAttributeEnum.HtmlColor], newColor);\n                element.dataset[names[ColorAttributeEnum.HtmlDataSet]] = attrColor;\n            }\n        }\n    });\n}\n\nfunction getValueOrDefault(value: string, defaultValue: string | null) {\n    return value && value != 'undefined' && value != 'null' ? value : defaultValue;\n}\n\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\n        if (includeSelf) {\n            result.push(rootNode);\n        }\n        const allChildren = rootNode.getElementsByTagName('*');\n        arrayPush(result, toArray(allChildren));\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\n        const allChildren = rootNode.querySelectorAll('*');\n        arrayPush(result, toArray(allChildren));\n    }\n\n    return result;\n}\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Trigger a plugin event\n * @param core The EditorCore object\n * @param pluginEvent The event object to trigger\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\n */\nexport const triggerEvent: TriggerEvent = (\n    core: EditorCore,\n    pluginEvent: PluginEvent,\n    broadcast: boolean\n) => {\n    if (\n        !core.lifecycle.shadowEditFragment &&\n        (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin)))\n    ) {\n        core.plugins.forEach(plugin => {\n            if (plugin.onPluginEvent) {\n                plugin.onPluginEvent(pluginEvent);\n            }\n        });\n    }\n};\n\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\n        plugin.onPluginEvent(event);\n        return true;\n    }\n\n    return false;\n}\n","import CopyPastePlugin from './CopyPastePlugin';\nimport DOMEventPlugin from './DOMEventPlugin';\nimport EditPlugin from './EditPlugin';\nimport EntityPlugin from './EntityPlugin';\nimport LifecyclePlugin from './LifecyclePlugin';\nimport MouseUpPlugin from './MouseUpPlugin';\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\nimport UndoPlugin from './UndoPlugin';\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\n\n/**\n * @internal\n * Create Core Plugins\n * @param contentDiv Content DIV of editor\n * @param options Editor options\n */\nexport default function createCorePlugins(\n    contentDiv: HTMLDivElement,\n    options: EditorOptions\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\n    const map = options.corePluginOverride || {};\n    // The order matters, some plugin needs to be put before/after others to make sure event\n    // can be handled in right order\n    return {\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\n        edit: map.edit || new EditPlugin(),\n        _placeholder: null,\n        typeAfterLink: null, //deprecated after firefox update\n        undo: map.undo || new UndoPlugin(options),\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\n        copyPaste: map.copyPaste || new CopyPastePlugin(options),\n        entity: map.entity || new EntityPlugin(),\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\n    };\n}\n\n/**\n * @internal\n * Get plugin state of core plugins\n * @param corePlugins CorePlugins object\n */\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\n    return {\n        domEvent: corePlugins.domEvent.getState(),\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\n        edit: corePlugins.edit.getState(),\n        lifecycle: corePlugins.lifecycle.getState(),\n        undo: corePlugins.undo.getState(),\n        entity: corePlugins.entity.getState(),\n        copyPaste: corePlugins.copyPaste.getState(),\n    };\n}\n","import {\n    addRangeToSelection,\n    createElement,\n    extractClipboardEvent,\n    setHtmlWithSelectionPath,\n    moveChildNodes,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    CopyPastePluginState,\n    EditorOptions,\n    GetContentMode,\n    IEditor,\n    PluginEventType,\n    ExperimentalFeatures,\n    PluginWithState,\n    KnownCreateElementDataIndex,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Copy and paste plugin for handling onCopy and onPaste event\n */\nexport default class CopyPastePlugin implements PluginWithState<CopyPastePluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: CopyPastePluginState;\n\n    /**\n     * Construct a new instance of CopyPastePlugin\n     * @param options The editor options\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            allowedCustomPasteType: options.allowedCustomPasteType || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CopyPaste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            paste: this.onPaste,\n            copy: e => this.onCutCopy(e, false /*isCut*/),\n            cut: e => this.onCutCopy(e, true /*isCut*/),\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onCutCopy(event: Event, isCut: boolean) {\n        const originalRange = this.editor.getSelectionRange();\n        if (originalRange && !originalRange.collapsed) {\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\n            const newRange = setHtmlWithSelectionPath(\n                tempDiv,\n                html,\n                this.editor.getTrustedHTMLHandler()\n            );\n\n            if (newRange) {\n                addRangeToSelection(newRange);\n            }\n\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\n                clonedRoot: tempDiv,\n                range: newRange,\n                rawEvent: event as ClipboardEvent,\n                isCut,\n            });\n\n            this.editor.runAsync(editor => {\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\n\n                if (isCut) {\n                    editor.addUndoSnapshot(() => {\n                        const position = this.editor.deleteSelectedContent();\n                        editor.focus();\n                        editor.select(position);\n                    }, ChangeSource.Cut);\n                }\n            });\n        }\n    }\n\n    private onPaste = (event: Event) => {\n        let range: Range;\n\n        extractClipboardEvent(\n            event as ClipboardEvent,\n            clipboardData => this.editor.paste(clipboardData),\n            {\n                allowLinkPreview: this.editor.isFeatureEnabled(\n                    ExperimentalFeatures.PasteWithLinkPreview\n                ),\n                allowedCustomPasteType: this.state.allowedCustomPasteType,\n                getTempDiv: () => {\n                    range = this.editor.getSelectionRange();\n                    return this.getTempDiv();\n                },\n                removeTempDiv: div => {\n                    this.cleanUpAndRestoreSelection(div, range);\n                },\n            }\n        );\n    };\n\n    private getTempDiv(forceInLightMode?: boolean) {\n        const div = this.editor.getCustomData(\n            'CopyPasteTempDiv',\n            () => {\n                const tempDiv = createElement(\n                    KnownCreateElementDataIndex.CopyPasteTempDiv,\n                    this.editor.getDocument()\n                ) as HTMLDivElement;\n                this.editor.insertNode(tempDiv, {\n                    position: ContentPosition.Outside,\n                });\n\n                return tempDiv;\n            },\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\n        );\n\n        if (forceInLightMode) {\n            div.style.backgroundColor = 'white';\n            div.style.color = 'black';\n        }\n\n        div.style.display = '';\n        div.focus();\n\n        return div;\n    }\n\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\n        this.editor.select(range);\n        tempDiv.style.backgroundColor = '';\n        tempDiv.style.color = '';\n        tempDiv.style.display = 'none';\n        moveChildNodes(tempDiv);\n    }\n}\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContextMenuProvider,\n    DOMEventHandler,\n    DOMEventPluginState,\n    EditorOptions,\n    EditorPlugin,\n    IEditor,\n    Keys,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * DOMEventPlugin handles customized DOM events, including:\n * 1. Keyboard event\n * 2. Mouse event\n * 3. IME state\n * 4. Drop event\n * 5. Focus and blur event\n * 6. Input event\n * 7. Scroll event\n * It contains special handling for Safari since Safari cannot get correct selection when onBlur event is triggered in editor.\n */\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\n    private editor: IEditor;\n    private disposer: () => void;\n    private state: DOMEventPluginState;\n\n    /**\n     * Construct a new instance of DOMEventPlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.state = {\n            isInIME: false,\n            scrollContainer: options.scrollContainer || contentDiv,\n            selectionRange: null,\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\n            contextMenuProviders:\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'DOMEvent';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        const document = this.editor.getDocument();\n        const eventHandlers: Record<string, DOMEventHandler> = {\n            // 1. Keyboard event\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\n\n            // 2. Mouse event\n            mousedown: PluginEventType.MouseDown,\n            contextmenu: this.onContextMenuEvent,\n\n            // 3. IME state management\n            compositionstart: () => (this.state.isInIME = true),\n            compositionend: (rawEvent: CompositionEvent) => {\n                this.state.isInIME = false;\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\n                    rawEvent,\n                });\n            },\n\n            // 4. Drop event\n            drop: this.onDrop,\n\n            // 5. Focus management\n            focus: this.onFocus,\n\n            // 6. Input event\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\n        };\n\n        // 7. onBlur handlers\n        if (Browser.isSafari) {\n            document.addEventListener('mousedown', this.onMouseDownDocument, true /*useCapture*/);\n            document.addEventListener('keydown', this.onKeyDownDocument);\n            document.defaultView?.addEventListener('blur', this.cacheSelection);\n        } else {\n            eventHandlers[Browser.isIEOrEdge ? 'beforedeactivate' : 'blur'] = this.cacheSelection;\n        }\n\n        this.disposer = editor.addDomEventHandler(eventHandlers);\n\n        // 8. Scroll event\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('scroll', this.onScroll);\n        document.defaultView?.addEventListener('resize', this.onScroll);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        const document = this.editor.getDocument();\n        if (Browser.isSafari) {\n            document.removeEventListener(\n                'mousedown',\n                this.onMouseDownDocument,\n                true /*useCapture*/\n            );\n            document.removeEventListener('keydown', this.onKeyDownDocument);\n            document.defaultView?.removeEventListener('blur', this.cacheSelection);\n        }\n\n        document.defaultView?.removeEventListener('resize', this.onScroll);\n        document.defaultView?.removeEventListener('scroll', this.onScroll);\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    private onDrop = (e: UIEvent) => {\n        this.editor.runAsync(editor => {\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\n        });\n    };\n\n    private onFocus = () => {\n        this.editor.select(this.state.selectionRange);\n        this.state.selectionRange = null;\n    };\n    private onKeyDownDocument = (event: KeyboardEvent) => {\n        if (event.which == Keys.TAB && !event.defaultPrevented) {\n            this.cacheSelection();\n        }\n    };\n\n    private onMouseDownDocument = (event: MouseEvent) => {\n        if (!this.state.selectionRange && !this.editor.contains(event.target as Node)) {\n            this.cacheSelection();\n        }\n    };\n\n    private cacheSelection = () => {\n        if (!this.state.selectionRange) {\n            this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\n        }\n    };\n    private onScroll = (e: UIEvent) => {\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\n            rawEvent: e,\n            scrollContainer: this.state.scrollContainer,\n        });\n    };\n\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\n        return this.state.stopPrintableKeyboardEventPropagation\n            ? {\n                  pluginEventType: eventType,\n                  beforeDispatch:\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeyboardEvent,\n              }\n            : eventType;\n    }\n\n    private onKeyboardEvent = (event: KeyboardEvent) => {\n        if (isCharacterValue(event)) {\n            event.stopPropagation();\n        }\n    };\n\n    private onInputEvent = (event: InputEvent) => {\n        event.stopPropagation();\n    };\n\n    private onContextMenuEvent = (event: MouseEvent) => {\n        const allItems: any[] = [];\n        const searcher = this.editor.getContentSearcherOfCursor();\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\n\n        let eventTargetNode = event.target as Node;\n        if (event.button != 2) {\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\n        }\n        this.state.contextMenuProviders.forEach(provider => {\n            const items = provider.getContextMenuItems(eventTargetNode);\n            if (items?.length > 0) {\n                if (allItems.length > 0) {\n                    allItems.push(null);\n                }\n                arrayPush(allItems, items);\n            }\n        });\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\n            rawEvent: event,\n            items: allItems,\n        });\n    };\n}\n\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\n}\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\nimport {\n    EditPluginState,\n    GenericContentEditFeature,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Edit Component helps handle Content edit features\n */\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\n    private editor: IEditor;\n    private state: EditPluginState;\n\n    /**\n     * Construct a new instance of EditPlugin\n     * @param options The editor options\n     */\n    constructor() {\n        this.state = {\n            features: {},\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Edit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        let hasFunctionKey = false;\n        let features: GenericContentEditFeature<PluginEvent>[];\n        let ctrlOrMeta = false;\n\n        if (event.eventType == PluginEventType.KeyDown) {\n            const rawEvent = event.rawEvent;\n            const range = this.editor.getSelectionRange();\n\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\n            features =\n                this.state.features[rawEvent.which] ||\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            features = this.state.features[Keys.CONTENTCHANGED];\n        }\n\n        for (let i = 0; i < features?.length; i++) {\n            const feature = features[i];\n            if (\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\n            ) {\n                feature.handleEvent(event, this.editor);\n                break;\n            }\n        }\n    }\n}\n","import {\n    Browser,\n    commitEntity,\n    getEntityFromElement,\n    getEntitySelector,\n    isCharacterValue,\n    toArray,\n    arrayPush,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    EntityClasses,\n    EntityOperation,\n    EntityPluginState,\n    HtmlSanitizerOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    QueryScope,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_ID_REGEX = /_(\\d{1,8})$/;\n\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\nconst ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\n    private editor: IEditor;\n    private state: EntityPluginState;\n\n    /**\n     * Construct a new instance of EntityPlugin\n     */\n    constructor() {\n        this.state = {\n            clickingPoint: null,\n            knownEntityElements: [],\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Entity';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.state.knownEntityElements = [];\n        this.state.clickingPoint = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.handleCutEvent(event.rawEvent);\n                }\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n            case PluginEventType.ContextMenu:\n                this.handleContextMenuEvent(event.rawEvent);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent(event: UIEvent) {\n        const node = event.target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n\n        if (entityElement) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\n        }\n    }\n\n    private handleCutEvent = (event: ClipboardEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (range && !range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.state.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const node = target as Node;\n        let entityElement: HTMLElement;\n\n        if (\n            this.state.clickingPoint &&\n            this.state.clickingPoint.pageX == pageX &&\n            this.state.clickingPoint.pageY == pageY &&\n            node &&\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\n        ) {\n            event.preventDefault();\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.state.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.state.knownEntityElements = resetAll\n            ? []\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\n        const allId = this.state.knownEntityElements\n            .map(e => getEntityFromElement(e)?.id)\n            .filter(x => !!x);\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\n                this.state.knownEntityElements.push(element);\n\n                const entity = getEntityFromElement(element);\n\n                this.hydrateEntity(entity, allId);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\n        });\n    }\n\n    private checkRemoveEntityForRange(event: Event) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                this.triggerEvent(\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\n        const { id, type, wrapper, isReadonly } = entity;\n        const match = ENTITY_ID_REGEX.exec(id);\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\n\n        // Make sure entity id is unique\n        let newId = '';\n\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\n\n            if (knownIds.indexOf(newId) < 0) {\n                knownIds.push(newId);\n                break;\n            }\n        }\n\n        commitEntity(wrapper, type, isReadonly, newId);\n\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\n    }\n\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\n        const entity = element && getEntityFromElement(element);\n\n        if (entity) {\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n                operation,\n                rawEvent,\n                entity,\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: IEditor) => {\n          editor.runAsync(editor => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import { Browser, getComputedStyles, setColor } from 'roosterjs-editor-dom';\nimport {\n    DefaultFormat,\n    DocumentCommand,\n    EditorOptions,\n    IEditor,\n    LifecyclePluginState,\n    PluginEventType,\n    PluginWithState,\n    PluginEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\nconst COMMANDS: {\n    [command: string]: any;\n} = Browser.isFirefox\n    ? {\n          /**\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\n           */\n          [DocumentCommand.EnableObjectResizing]: false,\n          [DocumentCommand.EnableInlineTableEditing]: false,\n      }\n    : Browser.isIE\n    ? {\n          /**\n           * Change the default paragraph separator to DIV. This is mainly for IE since its default setting is P\n           */\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\n\n          /**\n           * Disable auto link feature in IE since we have our own implementation\n           */\n          [DocumentCommand.AutoUrlDetect]: false,\n      }\n    : {};\n\nconst DARK_MODE_DEFAULT_FORMAT = {\n    backgroundColors: {\n        darkModeColor: 'rgb(51,51,51)',\n        lightModeColor: 'rgb(255,255,255)',\n    },\n    textColors: {\n        darkModeColor: 'rgb(255,255,255)',\n        lightModeColor: 'rgb(0,0,0)',\n    },\n};\n\n/**\n * @internal\n * Lifecycle plugin handles editor initialization and disposing\n */\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\n    private editor: IEditor;\n    private state: LifecyclePluginState;\n    private initialContent: string;\n    private contentDivFormat: string[];\n    private initializer: () => void;\n    private disposer: () => void;\n    private adjustColor: () => void;\n\n    /**\n     * Construct a new instance of LifecyclePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\n        this.contentDivFormat = getComputedStyles(contentDiv);\n\n        // Make the container editable and set its selection styles\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\n            this.initializer = () => {\n                contentDiv.contentEditable = 'true';\n                this.setSelectStyle(contentDiv, 'text');\n            };\n            this.disposer = () => {\n                this.setSelectStyle(contentDiv, '');\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\n            };\n        }\n        this.adjustColor = options.doNotAdjustEditorColor\n            ? () => {}\n            : () => {\n                  const { textColors, backgroundColors } = DARK_MODE_DEFAULT_FORMAT;\n                  const { isDarkMode } = this.state;\n                  setColor(contentDiv, textColors, false /*isBackground*/, isDarkMode);\n                  setColor(contentDiv, backgroundColors, true /*isBackground*/, isDarkMode);\n              };\n\n        this.state = {\n            customData: {},\n            defaultFormat: options.defaultFormat || null,\n            isDarkMode: !!options.inDarkMode,\n            getDarkColor: options.getDarkColor || ((color: string) => color),\n            onExternalContentTransform: options.onExternalContentTransform,\n            experimentalFeatures: options.experimentalFeatures || [],\n            shadowEditFragment: null,\n            shadowEditSelectionPath: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Lifecycle';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n\n        // Calculate default format\n        this.recalculateDefaultFormat();\n\n        // Ensure initial content and its format\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\n\n        // Set content DIV to be editable\n        this.initializer?.();\n\n        // Set editor background color for dark mode\n        this.adjustColor();\n\n        // Do proper change for browsers to disable some browser-specified behaviors.\n        this.adjustBrowserBehavior();\n\n        // Let other plugins know that we are ready\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\n\n        Object.keys(this.state.customData).forEach(key => {\n            const data = this.state.customData[key];\n\n            if (data && data.disposer) {\n                data.disposer(data.value);\n            }\n\n            delete this.state.customData[key];\n        });\n\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n            this.initializer = null;\n        }\n\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.ContentChanged &&\n            (event.source == ChangeSource.SwitchToDarkMode ||\n                event.source == ChangeSource.SwitchToLightMode)\n        ) {\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\n            this.recalculateDefaultFormat();\n            this.adjustColor();\n        }\n    }\n\n    private adjustBrowserBehavior() {\n        Object.keys(COMMANDS).forEach(command => {\n            // Catch any possible exception since this should not block the initialization of editor\n            try {\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\n            } catch {}\n        });\n    }\n\n    private setSelectStyle(node: HTMLElement, value: string) {\n        node.style.userSelect = value;\n        node.style.msUserSelect = value;\n        node.style.webkitUserSelect = value;\n    }\n\n    private recalculateDefaultFormat() {\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\n\n        if (isDarkMode && baseFormat) {\n            if (!baseFormat.backgroundColors) {\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\n            }\n            if (!baseFormat.textColors) {\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\n            }\n        }\n\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\n            return;\n        }\n\n        const {\n            fontFamily,\n            fontSize,\n            textColor,\n            textColors,\n            backgroundColor,\n            backgroundColors,\n            bold,\n            italic,\n            underline,\n        } = baseFormat || <DefaultFormat>{};\n        const defaultFormat = this.contentDivFormat;\n\n        this.state.defaultFormat = {\n            fontFamily: fontFamily || defaultFormat[0],\n            fontSize: fontSize || defaultFormat[1],\n            get textColor() {\n                return textColors\n                    ? isDarkMode\n                        ? textColors.darkModeColor\n                        : textColors.lightModeColor\n                    : textColor || defaultFormat[2];\n            },\n            textColors: textColors,\n            get backgroundColor() {\n                return backgroundColors\n                    ? isDarkMode\n                        ? backgroundColors.darkModeColor\n                        : backgroundColors.lightModeColor\n                    : backgroundColor || '';\n            },\n            backgroundColors: backgroundColors,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n        };\n    }\n}\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\n * as long as the mouse was pressed within Editor before\n */\nexport default class MouseUpPlugin implements EditorPlugin {\n    private editor: IEditor;\n    private mouseUpEventListerAdded: boolean;\n    private mouseDownX: number;\n    private mouseDownY: number;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'MouseUp';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.removeMouseUpEventListener();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\n            this.editor\n                .getDocument()\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\n            this.mouseUpEventListerAdded = true;\n            this.mouseDownX = event.rawEvent.pageX;\n            this.mouseDownY = event.rawEvent.pageY;\n        }\n    }\n    private removeMouseUpEventListener() {\n        if (this.mouseUpEventListerAdded) {\n            this.mouseUpEventListerAdded = false;\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private onMouseUp = (rawEvent: MouseEvent) => {\n        if (this.editor) {\n            this.removeMouseUpEventListener();\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\n                rawEvent,\n                isClicking: this.mouseDownX == rawEvent.pageX && this.mouseDownY == rawEvent.pageY,\n            });\n        }\n    };\n}\n","import { Position } from 'roosterjs-editor-dom';\nimport {\n    IEditor,\n    PendingFormatStatePluginState,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * PendingFormatStatePlugin handles pending format state management\n */\nexport default class PendingFormatStatePlugin\n    implements PluginWithState<PendingFormatStatePluginState> {\n    private editor: IEditor;\n    private state: PendingFormatStatePluginState;\n\n    /**\n     * Construct a new instance of PendingFormatStatePlugin\n     * @param options The editor options\n     * @param contentDiv The editor content DIV\n     */\n    constructor() {\n        this.state = {\n            pendableFormatPosition: null,\n            pendableFormatState: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'PendingFormatState';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n        this.clear();\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.PendingFormatStateChanged:\n                // Got PendingFormatStateChanged event, cache current position and pending format\n                this.state.pendableFormatPosition = this.getCurrentPosition();\n                this.state.pendableFormatState = event.formatState;\n                break;\n            case PluginEventType.KeyDown:\n            case PluginEventType.MouseDown:\n            case PluginEventType.ContentChanged:\n                // If content or position is changed (by keyboard, mouse, or code),\n                // check if current position is still the same with the cached one (if exist),\n                // and clear cached format if position is changed since it is out-of-date now\n                if (\n                    this.state.pendableFormatPosition &&\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\n                ) {\n                    this.clear();\n                }\n                break;\n        }\n    }\n\n    private clear() {\n        this.state.pendableFormatPosition = null;\n        this.state.pendableFormatState = null;\n    }\n\n    private getCurrentPosition() {\n        let range = this.editor.getSelectionRange();\n        return range && Position.getStart(range).normalize();\n    }\n}\n","import { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    ExperimentalFeatures,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Typing Component helps to ensure typing is always happening under a DOM container\n */\nexport default class TypeInContainerPlugin implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TypeInContainer';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.KeyPress) {\n            // If normalization was not possible before the keypress,\n            // check again after the keyboard event has been processed by browser native behavior.\n            //\n            // This handles the case where the keyboard event that first inserts content happens when\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\n            //\n            // Only schedule when the range is not collapsed to catch this edge case.\n            let range = this.editor.getSelectionRange();\n            let shouldAlwaysApplyDefaultFormat = this.editor.isFeatureEnabled(\n                ExperimentalFeatures.AlwaysApplyDefaultFormat\n            );\n\n            if (\n                !range ||\n                this.editor.contains(\n                    findClosestElementAncestor(\n                        range.startContainer,\n                        null /* root */,\n                        shouldAlwaysApplyDefaultFormat ? '[style]' : null /*selector*/\n                    )\n                )\n            ) {\n                return;\n            }\n\n            if (range.collapsed) {\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\n            } else {\n                this.editor.runAsync(editor => {\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\n                });\n            }\n        }\n    }\n}\n","import {\n    EditorOptions,\n    IEditor,\n    Keys,\n    PluginEvent,\n    PluginEventType,\n    PluginWithState,\n    UndoPluginState,\n    UndoSnapshotsService,\n} from 'roosterjs-editor-types';\nimport {\n    addSnapshot,\n    canMoveCurrentSnapshot,\n    clearProceedingSnapshots,\n    createSnapshots,\n    isCtrlOrMetaPressed,\n    moveCurrentSnapshot,\n    canUndoAutoComplete,\n} from 'roosterjs-editor-dom';\n\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\n// to keep size under limit. This is kept at 10MB\nconst MAX_SIZE_LIMIT = 1e7;\n\n/**\n * @internal\n * Provides snapshot based undo service for Editor\n */\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\n    private editor: IEditor;\n    private lastKeyPress: number;\n    private state: UndoPluginState;\n\n    /**\n     * Construct a new instance of UndoPlugin\n     * @param options The wrapper of the state object\n     */\n    constructor(options: EditorOptions) {\n        this.state = {\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\n            isRestoring: false,\n            hasNewContent: false,\n            isNested: false,\n            autoCompletePosition: null,\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Undo';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Get plugin state object\n     */\n    getState() {\n        return this.state;\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * @param event The event to check\n     */\n    willHandleEventExclusively(event: PluginEvent) {\n        return (\n            event.eventType == PluginEventType.KeyDown &&\n            event.rawEvent.which == Keys.BACKSPACE &&\n            this.canUndoAutoComplete()\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent): void {\n        // if editor is in IME, don't do anything\n        if (!this.editor || this.editor.isInIME()) {\n            return;\n        }\n\n        switch (event.eventType) {\n            case PluginEventType.EditorReady:\n                const undoState = this.editor.getUndoState();\n                if (!undoState.canUndo && !undoState.canRedo) {\n                    // Only add initial snapshot when there is no existing snapshot\n                    // Otherwise preserved undo/redo state may be ruined\n                    this.addUndoSnapshot();\n                }\n                break;\n            case PluginEventType.KeyDown:\n                this.onKeyDown(event.rawEvent);\n                break;\n            case PluginEventType.KeyPress:\n                this.onKeyPress(event.rawEvent);\n                break;\n            case PluginEventType.CompositionEnd:\n                this.clearRedoForInput();\n                this.addUndoSnapshot();\n                break;\n            case PluginEventType.ContentChanged:\n                if (!this.state.isRestoring) {\n                    this.clearRedoForInput();\n                }\n                break;\n        }\n    }\n\n    private onKeyDown(evt: KeyboardEvent): void {\n        // Handle backspace/delete when there is a selection to take a snapshot\n        // since we want the state prior to deletion restorable\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\n                evt.preventDefault();\n                this.editor.undo();\n                this.state.autoCompletePosition = null;\n                this.lastKeyPress = evt.which;\n            } else {\n                let selectionRange = this.editor.getSelectionRange();\n\n                // Add snapshot when\n                // 1. Something has been selected (not collapsed), or\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\n                if (\n                    selectionRange &&\n                    (!selectionRange.collapsed ||\n                        this.lastKeyPress != evt.which ||\n                        isCtrlOrMetaPressed(evt))\n                ) {\n                    this.addUndoSnapshot();\n                }\n\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\n                this.state.hasNewContent = true;\n                this.lastKeyPress = evt.which;\n            }\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\n            if (this.state.hasNewContent) {\n                this.addUndoSnapshot();\n            }\n            this.lastKeyPress = 0;\n        }\n    }\n\n    private onKeyPress(evt: KeyboardEvent): void {\n        if (evt.metaKey) {\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\n            return;\n        }\n\n        let range = this.editor.getSelectionRange();\n        if (\n            (range && !range.collapsed) ||\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\n            evt.which == Keys.ENTER\n        ) {\n            this.addUndoSnapshot();\n            if (evt.which == Keys.ENTER) {\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\n                // we restore the snapshot before ENTER\n                this.state.hasNewContent = true;\n            }\n        } else {\n            this.clearRedoForInput();\n        }\n\n        this.lastKeyPress = evt.which;\n    }\n\n    private clearRedoForInput() {\n        this.state.snapshotsService.clearRedo();\n        this.lastKeyPress = 0;\n        this.state.hasNewContent = true;\n    }\n\n    private canUndoAutoComplete() {\n        return (\n            this.state.snapshotsService.canUndoAutoComplete() &&\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\n        );\n    }\n\n    private addUndoSnapshot() {\n        this.editor.addUndoSnapshot();\n        this.state.autoCompletePosition = null;\n    }\n}\n\nfunction createUndoSnapshots(): UndoSnapshotsService {\n    const snapshots = createSnapshots(MAX_SIZE_LIMIT);\n\n    return {\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\n        move: (delta: number): string => moveCurrentSnapshot(snapshots, delta),\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\n        clearRedo: () => clearProceedingSnapshots(snapshots),\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\n    };\n}\n","import * as Color from 'color';\n\nconst baseLValue = 21.247; // L-value of #333333\n\n/**\n * Get dark mode color for a given color\n * @param color The color to calculate from\n */\nexport default function getDarkColor(color: string): string {\n    try {\n        const computedColor = Color(color || undefined);\n        const colorLab = computedColor.lab().array();\n        const newLValue = (100 - colorLab[0]) * ((100 - baseLValue) / 100) + baseLValue;\n        color = Color.lab(newLValue, colorLab[1], colorLab[2])\n            .rgb()\n            .alpha(computedColor.alpha())\n            .toString();\n    } catch {}\n\n    return color;\n}\n","'use strict';\n\nvar colorString = require('color-string');\nvar convert = require('color-convert');\n\nvar _slice = [].slice;\n\nvar skippedModels = [\n\t// to be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// shouldn't really be in color-convert either...\n\t'hex'\n];\n\nvar hashedModelKeys = {};\nObject.keys(convert).forEach(function (model) {\n\thashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n});\n\nvar limiters = {};\n\nfunction Color(obj, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tvar i;\n\tvar channels;\n\n\tif (obj == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (obj instanceof Color) {\n\t\tthis.model = obj.model;\n\t\tthis.color = obj.color.slice();\n\t\tthis.valpha = obj.valpha;\n\t} else if (typeof obj === 'string') {\n\t\tvar result = colorString.get(obj);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + obj);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (obj.length) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tvar newArr = _slice.call(obj, 0, channels);\n\t\tthis.color = zeroArray(newArr, channels);\n\t\tthis.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;\n\t} else if (typeof obj === 'number') {\n\t\t// this is always RGB - can be converted later on.\n\t\tobj &= 0xFFFFFF;\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(obj >> 16) & 0xFF,\n\t\t\t(obj >> 8) & 0xFF,\n\t\t\tobj & 0xFF\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tvar keys = Object.keys(obj);\n\t\tif ('alpha' in obj) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;\n\t\t}\n\n\t\tvar hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(obj));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tvar labels = convert[this.model].labels;\n\t\tvar color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(obj[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tvar limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString: function () {\n\t\treturn this.string();\n\t},\n\n\ttoJSON: function () {\n\t\treturn this[this.model]();\n\t},\n\n\tstring: function (places) {\n\t\tvar self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString: function (places) {\n\t\tvar self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray: function () {\n\t\treturn this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n\t},\n\n\tobject: function () {\n\t\tvar result = {};\n\t\tvar channels = convert[this.model].channels;\n\t\tvar labels = convert[this.model].labels;\n\n\t\tfor (var i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray: function () {\n\t\tvar rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject: function () {\n\t\tvar rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround: function (places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n\t},\n\n\talpha: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(100)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(100)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.rgb().color;\n\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.rgb().color;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight: function () {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = this.rgb();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\t\treturn rgb;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale: function () {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar rgb = this.rgb().color;\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(val, val, val);\n\t},\n\n\tfade: function (ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer: function (ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.hsl();\n\t\tvar hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix: function (mixinColor, weight) {\n\t\t// ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\t\tvar color1 = mixinColor.rgb();\n\t\tvar color2 = this.rgb();\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t}\n};\n\n// model conversion methods and static constructors\nObject.keys(convert).forEach(function (model) {\n\tif (skippedModels.indexOf(model) !== -1) {\n\t\treturn;\n\t}\n\n\tvar channels = convert[model].channels;\n\n\t// conversion methods\n\tColor.prototype[model] = function () {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (arguments.length) {\n\t\t\treturn new Color(arguments, model);\n\t\t}\n\n\t\tvar newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n\t\treturn new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (color) {\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(_slice.call(arguments), channels);\n\t\t}\n\t\treturn new Color(color, model);\n\t};\n});\n\nfunction roundTo(num, places) {\n\treturn Number(num.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (num) {\n\t\treturn roundTo(num, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tmodel.forEach(function (m) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t});\n\n\tmodel = model[0];\n\n\treturn function (val) {\n\t\tvar result;\n\n\t\tif (arguments.length) {\n\t\t\tif (modifier) {\n\t\t\t\tval = modifier(val);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = val;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(val) {\n\treturn Array.isArray(val) ? val : [val];\n}\n\nfunction zeroArray(arr, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tif (typeof arr[i] !== 'number') {\n\t\t\tarr[i] = 0;\n\t\t}\n\t}\n\n\treturn arr;\n}\n\nmodule.exports = Color;\n","/* MIT license */\nvar colorNames = require('color-name');\nvar swizzle = require('simple-swizzle');\n\nvar reverseNames = {};\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (colorNames.hasOwnProperty(name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {},\n\tget: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-f0-9]{3,4})$/i;\n\tvar hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar keyword = /(\\D+)/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\tvar hexAlpha;\n\n\tif (match = string.match(hex)) {\n\t\thexAlpha = match[2];\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\t\thexAlpha = match[3];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\n\t\tif (hexAlpha) {\n\t\t\trgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\n\t\tif (!rgb) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t} else {\n\t\treturn null;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = (parseFloat(match[1]) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn (\n\t\t'#' +\n\t\thexDouble(rgba[0]) +\n\t\thexDouble(rgba[1]) +\n\t\thexDouble(rgba[2]) +\n\t\t(rgba[3] < 1\n\t\t\t? (hexDouble(Math.round(rgba[3] * 255)))\n\t\t\t: '')\n\t);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = num.toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n","'use strict';\n\nvar isArrayish = require('is-arrayish');\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n","module.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n","var conversions = require('./conversions');\nvar route = require('./route');\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","export { default as HyperLink } from './HyperLink';\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private originalHref: string;\n    private trackedLink: HTMLAnchorElement = null;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({\n                mouseover: this.onMouse,\n                mouseout: this.onMouse,\n                blur: this.onBlur,\n            });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    protected onBlur = (e: FocusEvent) => {\n        if (this.trackedLink) {\n            this.updateLinkHrefIfShouldUpdate();\n        }\n\n        this.resetLinkTracking();\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (\n            event.eventType == PluginEventType.MouseUp ||\n            (event.eventType == PluginEventType.KeyUp &&\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\n            event.eventType == PluginEventType.ContentChanged\n        ) {\n            const anchor = this.editor.getElementAtCursor(\n                'A[href]',\n                null /*startFrom*/,\n                event\n            ) as HTMLAnchorElement;\n\n            const shouldCheckUpdateLink =\n                anchor !== this.trackedLink ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.ContentChanged;\n\n            if (\n                this.trackedLink &&\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\n            ) {\n                // If cursor has moved out of previously tracked link\n                // update link href if display text doesn't match href anymore.\n                if (shouldCheckUpdateLink) {\n                    this.updateLinkHrefIfShouldUpdate();\n                }\n\n                // If the link's href value was edited, or the cursor has moved out of the\n                // previously tracked link, stop tracking the link.\n                this.resetLinkTracking();\n            }\n\n            // Cache link and href value if its href attribute currently matches its display text\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\n                this.trackedLink = anchor;\n                this.originalHref = this.tryGetHref(anchor);\n            }\n        }\n\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n\n    /**\n     * Determines if KeyboardEvent is meant to edit content\n     */\n    private isContentEditValue(event: KeyboardEvent): boolean {\n        return (\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\n        );\n    }\n\n    /**\n     * Updates the href of the tracked link if the display text doesn't match href anymore\n     */\n    private updateLinkHrefIfShouldUpdate() {\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\n            this.updateLinkHref();\n        }\n    }\n\n    /**\n     * Clears the tracked link and its original href value so that it's back to default state\n     */\n    private resetLinkTracking() {\n        this.trackedLink = null;\n        this.originalHref = '';\n    }\n\n    /**\n     * Compares the normalized URL of inner text of element to its href to see if they match.\n     */\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\n        if (element) {\n            let display = element.innerText.trim();\n\n            // We first escape the display text so that any text passed into the regex is not\n            // treated as a special character.\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\n            let href = this.tryGetHref(element);\n            if (href !== null) {\n                return rule.test(href);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update href of an element in place to new display text if it's a valid URL\n     */\n    private updateLinkHref() {\n        if (this.trackedLink) {\n            let linkData = matchLink(this.trackedLink.innerText.trim());\n            if (linkData !== null) {\n                this.editor.addUndoSnapshot(() => {\n                    this.trackedLink.href = linkData.normalizedUrl;\n                });\n            }\n        }\n    }\n}\n","export { default as Paste } from './Paste';\n","import convertPastedContentForLI from './commonConverter/convertPastedContentForLI';\nimport convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromPowerPoint from './pptConverter/convertPastedContentFromPowerPoint';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport handleLineMerge from './lineMerge/handleLineMerge';\nimport { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\nimport { toArray } from 'roosterjs-editor-dom';\nimport { WAC_IDENTIFY_SELECTOR } from './officeOnlineConverter/constants';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst PROG_ID_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst POWERPOINT_ATTRIBUTE_VALUE = 'PowerPoint.Slide';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or OneNote Online\n */\nexport default class Paste implements EditorPlugin {\n    private editor: IEditor;\n\n    /**\n     * Construct a new instance of Paste class\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\n     */\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            const trustedHTMLHandler = this.editor.getTrustedHTMLHandler();\n            let wacListElements: Node[];\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[PROG_ID_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event, trustedHTMLHandler);\n            } else if (htmlAttributes[PROG_ID_NAME] == POWERPOINT_ATTRIBUTE_VALUE) {\n                convertPastedContentFromPowerPoint(event, trustedHTMLHandler);\n            } else if (\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFY_SELECTOR))) &&\n                wacListElements.length > 0\n            ) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\n            } else {\n                convertPastedContentForLI(fragment);\n                handleLineMerge(fragment);\n            }\n\n            // Replace unknown tags with SPAN\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    getTagOfNode,\n    toArray,\n    wrap,\n    safeInstanceOf,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Convert content copied from Teams to be well-formed\n */\nexport default function convertPastedContentForLI(fragment: DocumentFragment) {\n    // Sometimes it is possible that we get LI nodes directly under DIV.\n    // In that case we need to convert DIV to UL. It is also possible to be OL, but we don't know it.\n    // So always assume it is UL here, and later user can change it.\n    if (isPureLiNode(fragment)) {\n        wrap(toArray(fragment.childNodes), 'UL');\n    } else if (\n        safeInstanceOf(fragment.firstChild, 'HTMLElement') &&\n        isPureLiNode(fragment.firstChild)\n    ) {\n        changeElementTag(fragment.firstChild as HTMLElement, 'UL');\n    }\n}\n\nfunction isPureLiNode(node: ParentNode & Node) {\n    if (node && !node.nextSibling && ['OL', 'UL', 'MENU'].indexOf(getTagOfNode(node)) < 0) {\n        let hasLi = false;\n        if (\n            toArray(node.childNodes).every(childNode => {\n                if (safeInstanceOf(childNode, 'Text') && !childNode.nodeValue?.trim()) {\n                    return true;\n                } else if (getTagOfNode(childNode) == 'LI') {\n                    hasLi = true;\n                    return true;\n                } else {\n                    return false;\n                }\n            }) &&\n            hasLi\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { BeforePasteEvent, TrustedHTMLHandler } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback, moveChildNodes } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param event The BeforePaste event\n */\nexport default function convertPastedContentFromExcel(\n    event: BeforePasteEvent,\n    trustedHTMLHandler: TrustedHTMLHandler\n) {\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\n    const html = excelHandler(clipboardData.html, htmlBefore);\n\n    if (clipboardData.html != html) {\n        const doc = new DOMParser().parseFromString(trustedHTMLHandler(html), 'text/html');\n        moveChildNodes(fragment, doc?.body);\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n\n/**\n * @internal Export for test only\n * @param html Source html\n */\nexport function excelHandler(html: string, htmlBefore: string): string {\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        html = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        html = table + html + '</TABLE>';\n    }\n\n    return html;\n}\n","import { BeforePasteEvent, TrustedHTMLHandler } from 'roosterjs-editor-types';\nimport { moveChildNodes } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n * Convert pasted content from PowerPoint\n * @param event The BeforePaste event\n */\nexport default function convertPastedContentFromPowerPoint(\n    event: BeforePasteEvent,\n    trustedHTMLHandler: TrustedHTMLHandler\n) {\n    const { fragment, clipboardData } = event;\n\n    if (clipboardData.html && !clipboardData.text && clipboardData.image) {\n        // It is possible that PowerPoint copied both image and HTML but not plain text.\n        // We always prefer HTML if any.\n        const doc = new DOMParser().parseFromString(\n            trustedHTMLHandler(clipboardData.html),\n            'text/html'\n        );\n\n        moveChildNodes(fragment, doc?.body);\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback, moveChildNodes } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        moveChildNodes(element);\n        element.appendChild(element.ownerDocument.createTextNode('\\u00A0')); // &nbsp;\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import WordConverterArguments from './WordConverterArguments';\nimport WordCustomData, { createCustomData } from './WordCustomData';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    wordCustomData: WordCustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        wordCustomData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item meta data of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './WordCustomData';\nimport { getStyles, getTagOfNode, moveChildNodes } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is empty or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparison, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                moveChildNodes(last, node, true /*keepExistingChildren*/);\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                moveChildNodes(li, node);\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(\n        wordConverter.wordCustomData,\n        list,\n        UNIQUE_LIST_ID_CUSTOM_DATA,\n        metadata.uniqueListId\n    );\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and transfer all the children\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.wordCustomData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        moveChildNodes(newList, list);\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list before the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the children marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list meta dada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listAttribute = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listAttribute && listAttribute.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; meta data\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list indentation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listProps = listAttribute.split(' ');\n                if (listProps.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listProps[1].substr('level'.length)),\n                        wordListId: listAttribute,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring empty text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listAttribute = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (\n            listAttribute &&\n            listAttribute.length > 0 &&\n            listAttribute.trim().toLowerCase() == 'ignore'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those nonstandard values through the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    return getStyles(node)[styleName] || null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import {\n    changeElementTag,\n    ContentTraverser,\n    getBlockElementAtNode,\n    getNextLeafSibling,\n    getPreviousLeafSibling,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n/**\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\n * change the tag of first and last node to be SPAN so that it will be merged into current block\n * @param root Root node of content to process\n */\nexport default function handleLineMerge(root: Node) {\n    const traverser = ContentTraverser.createBodyTraverser(root);\n    const blocks: { start: Node; end: Node }[] = [];\n\n    for (\n        let block = traverser?.currentBlockElement;\n        block;\n        block = traverser.getNextBlockElement()\n    ) {\n        blocks.push({\n            start: block.getStartNode(),\n            end: block.getEndNode(),\n        });\n    }\n\n    if (blocks.length > 0) {\n        processBlock(blocks[0]);\n        processBlock(blocks[blocks.length - 1]);\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\n    }\n}\n\nfunction processBlock(block: { start: Node; end: Node }) {\n    const { start, end } = block;\n\n    if (start == end && getTagOfNode(start) == 'DIV') {\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\n        block.start = node;\n        block.end = node;\n\n        if (getTagOfNode(node.lastChild) == 'BR') {\n            node.removeChild(node.lastChild);\n        }\n    } else if (getTagOfNode(end) == 'BR') {\n        const node = end.ownerDocument.createTextNode('');\n        end.parentNode?.insertBefore(node, end);\n        block.end = node;\n        end.parentNode?.removeChild(end);\n    }\n}\n\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\n    const blockElement = getBlockElementAtNode(root, block.start);\n    const sibling = isFirst\n        ? getNextLeafSibling(root, block.end)\n        : getPreviousLeafSibling(root, block.start);\n\n    if (blockElement?.contains(sibling)) {\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\n            block.start.ownerDocument.createElement('br'),\n            isFirst ? block.end.nextSibling : block.start\n        );\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n    toArray,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are separated into different nodes:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item nodes.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with proper listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item DIV may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be malformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = toArray(\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock?.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.appendChild(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.appendChild(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const parentNode = insertPositionNode.parentNode;\n        if (parentNode) {\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const parentNode = listItemBlock.startElement.parentNode;\n        if (parentNode) {\n            parentNode.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageEdit';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\n","import { createElement } from 'roosterjs-editor-dom';\nimport {\n    ContentPosition,\n    EditorPlugin,\n    IEditor,\n    KnownCreateElementDataIndex,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\nexport interface ContextMenuOptions<T> {\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\n\n    dismiss?: (container: HTMLElement) => void;\n\n    allowDefaultMenu?: boolean;\n}\n\n/**\n * An editor plugin that support showing a context menu using render() function from options parameter\n */\nexport default class ContextMenu<T> implements EditorPlugin {\n    private container: HTMLElement;\n    private editor: IEditor;\n    private isMenuShowing: boolean;\n\n    /**\n     * Create a new instance of ContextMenu class\n     * @param options An options object to determine how to show/hide the context menu\n     */\n    constructor(private options: ContextMenuOptions<T>) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContextMenu';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onDismiss();\n\n        if (this.container) {\n            this.container.parentNode.removeChild(this.container);\n            this.container = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\n            const { rawEvent, items } = event;\n\n            this.onDismiss();\n\n            if (!this.options.allowDefaultMenu) {\n                rawEvent.preventDefault();\n            }\n\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\n            this.options.render(this.container, items as T[], this.onDismiss);\n            this.isMenuShowing = true;\n        }\n    }\n\n    private initContainer(x: number, y: number) {\n        if (!this.container) {\n            this.container = createElement(\n                KnownCreateElementDataIndex.ContextMenuWrapper,\n                this.editor.getDocument()\n            ) as HTMLElement;\n            this.editor.insertNode(this.container, {\n                position: ContentPosition.Outside,\n            });\n        }\n        this.container.style.left = x + 'px';\n        this.container.style.top = y + 'px';\n    }\n\n    private onDismiss = () => {\n        if (this.container && this.isMenuShowing) {\n            this.options.dismiss?.(this.container);\n            this.isMenuShowing = false;\n        }\n    };\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\n","import {\n    CustomReplacement,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: CustomReplacement[] = [\n    makeReplacement(':)', '🙂', true),\n    makeReplacement(';)', '😉', true),\n    makeReplacement(':O', '😲', true),\n    makeReplacement(':o', '😯', true),\n    makeReplacement('<3', '❤️', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: IEditor;\n    private replacements: CustomReplacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: CustomReplacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: IEditor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = this.editor.getTrustedHTMLHandler()(replacement.replacementHTML);\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.addUndoSnapshot(\n            () => {\n                matchingRange.deleteContents();\n                matchingRange.insertNode(nodeToInsert);\n                this.editor.select(nodeToInsert, PositionType.End);\n            },\n            null /*changeSource*/,\n            true /*canUndoByBackspace*/\n        );\n    }\n\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/CutPasteListChain/index';\n","export { default as CutPasteListChain } from './CutPasteListChain';\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\nimport { VListChain } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\n\n/**\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\n */\nexport default class CutPasteListChain implements EditorPlugin {\n    private chains: VListChain[];\n    private expectedChangeSource: ChangeSource;\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'CutPasteListChain';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer?.();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.BeforeCutCopy:\n                if (event.isCut) {\n                    this.cacheListChains(ChangeSource.Cut);\n                }\n                break;\n\n            case PluginEventType.BeforePaste:\n                this.cacheListChains(ChangeSource.Paste);\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\n                    experimentCommitListChains(this.editor, this.chains);\n                    this.chains = null;\n                    this.expectedChangeSource = null;\n                }\n                break;\n        }\n    }\n\n    private onDrop = () => {\n        this.cacheListChains(ChangeSource.Drop);\n    };\n\n    private cacheListChains(source: ChangeSource) {\n        this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\n        this.expectedChangeSource = source;\n    }\n}\n","export { default as ImageEdit } from './ImageEdit';\nexport { default as canRegenerateImage } from './api/canRegenerateImage';\nexport { default as resizeByPercentage } from './api/resizeByPercentage';\nexport { default as isResizedTo } from './api/isResizedTo';\nexport { default as resetImage } from './api/resetImage';\n","import applyChange from './editInfoUtils/applyChange';\nimport canRegenerateImage from './api/canRegenerateImage';\nimport Cropper, { getCropHTML } from './imageEditors/Cropper';\nimport deleteEditInfo from './editInfoUtils/deleteEditInfo';\nimport DragAndDropContext, { X, Y } from './types/DragAndDropContext';\nimport DragAndDropHandler from '../../pluginUtils/DragAndDropHandler';\nimport DragAndDropHelper from '../../pluginUtils/DragAndDropHelper';\nimport getEditInfoFromImage from './editInfoUtils/getEditInfoFromImage';\nimport getGeneratedImageSize from './editInfoUtils/getGeneratedImageSize';\nimport ImageEditInfo from './types/ImageEditInfo';\nimport ImageHtmlOptions from './types/ImageHtmlOptions';\nimport Rotator, { getRotateHTML, ROTATE_GAP, ROTATE_SIZE } from './imageEditors/Rotator';\nimport { ImageEditElementClass } from './types/ImageEditElementClass';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport Resizer, {\n    doubleCheckResize,\n    getSideResizeHTML,\n    getCornerResizeHTML,\n} from './imageEditors/Resizer';\nimport {\n    ExperimentalFeatures,\n    ImageEditOperation,\n    ImageEditOptions,\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    EntityOperation,\n    Entity,\n    Keys,\n    PositionType,\n    CreateElementData,\n    KnownCreateElementDataIndex,\n} from 'roosterjs-editor-types';\nimport {\n    Browser,\n    getEntitySelector,\n    getEntityFromElement,\n    matchesSelector,\n    safeInstanceOf,\n    toArray,\n    wrap,\n    arrayPush,\n    createElement,\n} from 'roosterjs-editor-dom';\n\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\n/**\n * Map the experimental features to image edit operations to help determine which operation is allowed\n */\nconst FeatureToOperationMap = {\n    [ExperimentalFeatures.SingleDirectionResize]: ImageEditOperation.SideResize,\n    [ExperimentalFeatures.ImageRotate]: ImageEditOperation.Rotate,\n    [ExperimentalFeatures.ImageCrop]: ImageEditOperation.Crop,\n};\n\n/**\n * Default image edit options\n */\nconst DefaultOptions: Required<ImageEditOptions> = {\n    borderColor: '#DB626C',\n    minWidth: 10,\n    minHeight: 10,\n    preserveRatio: false,\n    minRotateDeg: 5,\n    imageSelector: 'img',\n    rotateIconHTML: null,\n};\n\n/**\n * Map the image edit operation to a function that returns editing elements HTML to help\n * build image editing UI\n */\nconst ImageEditHTMLMap = {\n    [ImageEditOperation.CornerResize]: getCornerResizeHTML,\n    [ImageEditOperation.SideResize]: getSideResizeHTML,\n    [ImageEditOperation.Rotate]: getRotateHTML,\n    [ImageEditOperation.Crop]: getCropHTML,\n};\n\n/**\n * Image edit entity name\n */\nconst IMAGE_EDIT_WRAPPER_ENTITY_TYPE = 'IMAGE_EDIT_WRAPPER';\n\n/**\n * Default background colors for rotate handle\n */\nconst LIGHT_MODE_BGCOLOR = 'white';\nconst DARK_MODE_BGCOLOR = '#333';\n\n/**\n * ImageEdit plugin provides the ability to edit an inline image in editor, including image resizing, rotation and cropping\n */\nexport default class ImageEdit implements EditorPlugin {\n    protected editor: IEditor;\n    protected options: ImageEditOptions;\n    private disposer: () => void;\n\n    // Allowed editing operations\n    private allowedOperations: ImageEditOperation = ImageEditOperation.CornerResize;\n\n    // Current editing image\n    private image: HTMLImageElement;\n\n    // Current edit info of the image. All changes user made will be stored in this object.\n    // We use this object to update the editing UI, and finally we will use this object to generate\n    // the new image if necessary\n    private editInfo: ImageEditInfo;\n\n    // Src of the image before current editing\n    private lastSrc: string;\n\n    // Drag and drop helper objects\n    private dndHelpers: DragAndDropHelper<DragAndDropContext, any>[];\n\n    /**\n     * Create a new instance of ImageEdit\n     * @param options Image editing options\n     */\n    constructor(options?: ImageEditOptions) {\n        this.options = {\n            ...DefaultOptions,\n            ...(options || {}),\n        };\n    }\n\n    /**\n     * Get a friendly name of this plugin\n     */\n    getName() {\n        return 'ImageEdit';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler('blur', this.onBlur);\n\n        // Read current enabled features from editor to determine which editing operations are allowed\n        Object.keys(FeatureToOperationMap).forEach((key: keyof typeof FeatureToOperationMap) => {\n            this.allowedOperations |= this.editor.isFeatureEnabled(key)\n                ? FeatureToOperationMap[key]\n                : 0;\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.clearDndHelpers();\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.MouseDown:\n                this.setEditingImage(null);\n                break;\n\n            case PluginEventType.MouseUp:\n                const target = e.rawEvent.target;\n                if (\n                    e.isClicking &&\n                    e.rawEvent.button == 0 &&\n                    safeInstanceOf(target, 'HTMLImageElement') &&\n                    target.isContentEditable &&\n                    matchesSelector(target, this.options.imageSelector)\n                ) {\n                    this.setEditingImage(target, ImageEditOperation.ResizeAndRotate);\n                }\n\n                break;\n\n            case PluginEventType.KeyDown:\n                const key = e.rawEvent.which;\n                if (key == Keys.DELETE || key == Keys.BACKSPACE) {\n                    // Set current editing image to null and select the image if any, and do not prevent default of the event\n                    // so that browser will delete the selected image for us\n                    this.setEditingImage(null, true /*selectImage*/);\n                } else if (key == Keys.ESCAPE && this.image) {\n                    // Press ESC should cancel current editing operation, resume back to original edit info\n                    this.editInfo = getEditInfoFromImage(this.image);\n                    this.setEditingImage(null);\n                    e.rawEvent.preventDefault();\n                } else if (key != SHIFT_KEYCODE && key != CTRL_KEYCODE && key != ALT_KEYCODE) {\n                    // For other key, just unselect current image and select it. If this is an input key, the image will be replaced\n                    this.setEditingImage(null, true /*selectImage*/);\n                }\n                break;\n\n            case PluginEventType.ContentChanged:\n                if (\n                    e.source != ChangeSource.InsertEntity ||\n                    (<Entity>e.data).type != IMAGE_EDIT_WRAPPER_ENTITY_TYPE\n                ) {\n                    // After contentChanged event, the current image wrapper may not be valid any more, remove all of them if any\n                    this.editor.queryElements(\n                        getEntitySelector(IMAGE_EDIT_WRAPPER_ENTITY_TYPE),\n                        this.removeWrapper\n                    );\n                }\n\n                break;\n\n            case PluginEventType.EntityOperation:\n                if (e.entity.type == IMAGE_EDIT_WRAPPER_ENTITY_TYPE) {\n                    if (e.operation == EntityOperation.ReplaceTemporaryContent) {\n                        this.removeWrapper(e.entity.wrapper);\n                    } else if (e.operation == EntityOperation.Click) {\n                        e.rawEvent.preventDefault();\n                    }\n                }\n                break;\n\n            case PluginEventType.ExtractContentWithDom:\n                // When extract content, remove all image info since they may not be valid when load the content again\n                toArray(e.clonedRoot.querySelectorAll(this.options.imageSelector)).forEach(img => {\n                    deleteEditInfo(img as HTMLImageElement);\n                });\n                break;\n        }\n    }\n\n    /**\n     * Set current image for edit. If there is already image in editing, it will quit editing mode and any pending editing\n     * operation will be submitted\n     * @param image The image to edit\n     * @param operation The editing operation\n     */\n    setEditingImage(image: HTMLImageElement, operation: ImageEditOperation): void;\n\n    /**\n     * Stop editing image. If there is already image in editing, it will quit editing mode and any pending editing\n     * operation will be submitted\n     * @param image The image to edit\n     * @param selectImage True to select this image after quit editing mode\n     */\n    setEditingImage(image: null, selectImage?: boolean): void;\n\n    setEditingImage(\n        image: HTMLImageElement | null,\n        operationOrSelect?: ImageEditOperation | boolean\n    ) {\n        let operation =\n            typeof operationOrSelect === 'number' ? operationOrSelect : ImageEditOperation.None;\n        const selectImage = typeof operationOrSelect === 'number' ? false : !!operationOrSelect;\n\n        if (this.image) {\n            // When there is image in editing, clean up any cached objects and elements\n            this.clearDndHelpers();\n\n            // Apply the changes, and add undo snapshot if necessary\n            if (applyChange(this.editor, this.image, this.editInfo, this.lastSrc)) {\n                this.editor.addUndoSnapshot(() => this.image, ChangeSource.ImageResize);\n            }\n\n            // Remove editing wrapper\n            const wrapper = this.getImageWrapper(this.image);\n            if (wrapper) {\n                this.removeWrapper(wrapper);\n            }\n\n            if (selectImage) {\n                this.editor.select(this.image);\n            }\n\n            this.image = null;\n            this.editInfo = null;\n            this.lastSrc = null;\n        }\n\n        if (!this.image && image?.isContentEditable) {\n            // If there is new image to edit, enter editing mode for this image\n            this.editor.addUndoSnapshot();\n            this.image = image;\n\n            // Get initial edit info\n            this.editInfo = getEditInfoFromImage(image);\n            operation =\n                (canRegenerateImage(image) ? operation : ImageEditOperation.Resize) &\n                this.allowedOperations;\n\n            // Create and update editing wrapper and elements\n            const wrapper = this.createWrapper(operation);\n            this.updateWrapper();\n\n            // Init drag and drop\n            this.dndHelpers = [\n                ...this.createDndHelpers(ImageEditElementClass.ResizeHandle, Resizer),\n                ...this.createDndHelpers(ImageEditElementClass.RotateHandle, Rotator),\n                ...this.createDndHelpers(ImageEditElementClass.CropHandle, Cropper),\n                ...this.createDndHelpers(ImageEditElementClass.CropContainer, Cropper),\n            ];\n\n            // Put cursor next to the image\n            this.editor.select(wrapper, PositionType.After);\n        }\n    }\n\n    /**\n     * quit editing mode when editor lose focus\n     */\n    private onBlur = () => {\n        this.setEditingImage(null);\n    };\n\n    /**\n     * Create editing wrapper for the image\n     */\n    private createWrapper(operation: ImageEditOperation) {\n        // Wrap the image with an entity so that we can easily retrieve it later\n        const { wrapper } = insertEntity(\n            this.editor,\n            IMAGE_EDIT_WRAPPER_ENTITY_TYPE,\n            wrap(this.image, KnownCreateElementDataIndex.ImageEditWrapper),\n            false /*isBlock*/,\n            true /*isReadonly*/\n        );\n\n        wrapper.style.position = 'relative';\n        wrapper.style.maxWidth = '100%';\n        wrapper.style.verticalAlign = 'bottom';\n        wrapper.style.display = Browser.isSafari ? 'inline-block' : 'inline-flex';\n\n        // Cache current src so that we can compare it after edit see if src is changed\n        this.lastSrc = this.image.src;\n\n        // Set image src to original src to help show editing UI, also it will be used when regenerate image dataURL after editing\n        this.image.src = this.editInfo.src;\n        this.image.style.position = 'absolute';\n        this.image.style.maxWidth = null;\n\n        // Get HTML for all edit elements (resize handle, rotate handle, crop handle and overlay, ...) and create HTML element\n        const options: ImageHtmlOptions = {\n            borderColor: this.options.borderColor,\n            rotateIconHTML: this.options.rotateIconHTML,\n            rotateHandleBackColor: this.editor.isDarkMode()\n                ? DARK_MODE_BGCOLOR\n                : LIGHT_MODE_BGCOLOR,\n        };\n        const htmlData: CreateElementData[] = [];\n\n        ((Object.keys(ImageEditHTMLMap) as any[]) as (keyof typeof ImageEditHTMLMap)[]).forEach(\n            thisOperation => {\n                if ((operation & thisOperation) == thisOperation) {\n                    arrayPush(htmlData, ImageEditHTMLMap[thisOperation](options));\n                }\n            }\n        );\n\n        htmlData.forEach(data => {\n            const element = createElement(data, this.image.ownerDocument);\n            if (element) {\n                wrapper.appendChild(element);\n            }\n        });\n\n        return wrapper;\n    }\n\n    /**\n     * Get image wrapper from image\n     * @param image The image to get wrapper from\n     */\n    private getImageWrapper(image: HTMLImageElement): HTMLElement {\n        // Get the image wrapper from image using Entity API\n        const entity = getEntityFromElement(image?.parentNode?.parentNode as HTMLElement);\n\n        return entity?.type == IMAGE_EDIT_WRAPPER_ENTITY_TYPE ? entity.wrapper : null;\n    }\n\n    /**\n     * Remove the temp wrapper of the image\n     * @param wrapper The wrapper object to remove. If not specified, remove all existing wrappers.\n     */\n    private removeWrapper = (wrapper: HTMLElement) => {\n        const parent = wrapper?.parentNode;\n        const img = wrapper?.querySelector('img');\n\n        if (img && parent) {\n            img.style.position = '';\n            img.style.maxWidth = '100%';\n            img.style.margin = null;\n\n            parent.insertBefore(img, wrapper);\n            parent.removeChild(wrapper);\n        }\n    };\n\n    /**\n     * Update image edit elements to reflect current editing result\n     * @param context\n     */\n    private updateWrapper = (context?: DragAndDropContext) => {\n        const wrapper = this.getImageWrapper(this.image);\n        if (wrapper) {\n            // Prepare: get related editing elements\n            const cropContainers = getEditElements(wrapper, ImageEditElementClass.CropContainer);\n            const cropOverlays = getEditElements(wrapper, ImageEditElementClass.CropOverlay);\n            const rotateCenter = getEditElements(wrapper, ImageEditElementClass.RotateCenter)[0];\n            const rotateHandle = getEditElements(wrapper, ImageEditElementClass.RotateHandle)[0];\n\n            // Cropping and resizing will show different UI, so check if it is cropping here first\n            const isCropping = cropContainers.length == 1 && cropOverlays.length == 4;\n            const {\n                angleRad,\n                heightPx,\n                bottomPercent,\n                leftPercent,\n                rightPercent,\n                topPercent,\n            } = this.editInfo;\n\n            // Width/height of the image\n            const {\n                targetWidth,\n                targetHeight,\n                originalWidth,\n                originalHeight,\n                visibleWidth,\n                visibleHeight,\n            } = getGeneratedImageSize(this.editInfo, isCropping);\n            const marginHorizontal = (targetWidth - visibleWidth) / 2;\n            const marginVertical = (targetHeight - visibleHeight) / 2;\n            const cropLeftPx = originalWidth * leftPercent;\n            const cropRightPx = originalWidth * rightPercent;\n            const cropTopPx = originalHeight * topPercent;\n            const cropBottomPx = originalHeight * bottomPercent;\n\n            // Update size and margin of the wrapper\n            wrapper.style.width = getPx(visibleWidth);\n            wrapper.style.height = getPx(visibleHeight);\n            wrapper.style.margin = `${marginVertical}px ${marginHorizontal}px`;\n            wrapper.style.transform = `rotate(${angleRad}rad)`;\n\n            // Update size of the image\n            this.image.style.width = getPx(originalWidth);\n            this.image.style.height = getPx(originalHeight);\n\n            if (isCropping) {\n                // For crop, we also need to set position of the overlays\n                setSize(\n                    cropContainers[0],\n                    cropLeftPx,\n                    cropTopPx,\n                    cropRightPx,\n                    cropBottomPx,\n                    undefined,\n                    undefined\n                );\n                setSize(cropOverlays[0], 0, 0, cropRightPx, undefined, undefined, cropTopPx);\n                setSize(cropOverlays[1], undefined, 0, 0, cropBottomPx, cropRightPx, undefined);\n                setSize(cropOverlays[2], cropLeftPx, undefined, 0, 0, undefined, cropBottomPx);\n                setSize(cropOverlays[3], 0, cropTopPx, undefined, 0, cropLeftPx, undefined);\n            } else {\n                // For rotate/resize, set the margin of the image so that cropped part won't be visible\n                this.image.style.margin = `${-cropTopPx}px 0 0 ${-cropLeftPx}px`;\n\n                // Double check resize\n                if (context?.elementClass == ImageEditElementClass.ResizeHandle) {\n                    const clientWidth = wrapper.clientWidth;\n                    const clientHeight = wrapper.clientHeight;\n                    doubleCheckResize(\n                        this.editInfo,\n                        this.options.preserveRatio,\n                        clientWidth,\n                        clientHeight\n                    );\n\n                    this.updateWrapper();\n                }\n\n                // Move rotate handle. When image is very close to the border of editor, rotate handle may not be visible.\n                // Fix it by reduce the distance from image to rotate handle\n                const distance = this.editor.getRelativeDistanceToEditor(\n                    wrapper,\n                    true /*addScroll*/\n                );\n\n                if (rotateCenter && rotateHandle && distance) {\n                    const cosAngle = Math.cos(angleRad);\n                    const adjustedDistance =\n                        cosAngle <= 0\n                            ? Number.MAX_SAFE_INTEGER\n                            : (distance[1] + heightPx / 2 + marginVertical) / cosAngle -\n                              heightPx / 2;\n                    const rotateGap = Math.max(Math.min(ROTATE_GAP, adjustedDistance), 0);\n                    const rotateTop = Math.max(\n                        Math.min(ROTATE_SIZE, adjustedDistance - rotateGap),\n                        0\n                    );\n                    rotateCenter.style.top = getPx(-rotateGap);\n                    rotateCenter.style.height = getPx(rotateGap);\n                    rotateHandle.style.top = getPx(-rotateTop);\n                }\n            }\n        }\n    };\n\n    /**\n     * Create drag and drop helpers\n     * @param wrapper\n     * @param elementClass\n     * @param dragAndDrop\n     */\n    private createDndHelpers(\n        elementClass: ImageEditElementClass,\n        dragAndDrop: DragAndDropHandler<DragAndDropContext, any>\n    ): DragAndDropHelper<DragAndDropContext, any>[] {\n        const commonContext = {\n            editInfo: this.editInfo,\n            options: this.options,\n            elementClass,\n        };\n        const wrapper = this.getImageWrapper(this.image);\n\n        return wrapper\n            ? getEditElements(wrapper, elementClass).map(\n                  element =>\n                      new DragAndDropHelper<DragAndDropContext, any>(\n                          element,\n                          {\n                              ...commonContext,\n                              x: element.dataset.x as X,\n                              y: element.dataset.y as Y,\n                          },\n                          this.updateWrapper,\n                          dragAndDrop\n                      )\n              )\n            : [];\n    }\n\n    /**\n     * Clean up drag and drop helpers\n     */\n    private clearDndHelpers() {\n        this.dndHelpers?.forEach(helper => helper.dispose());\n        this.dndHelpers = null;\n    }\n}\n\nfunction setSize(\n    element: HTMLElement,\n    left: number,\n    top: number,\n    right: number,\n    bottom: number,\n    width: number,\n    height: number\n) {\n    element.style.left = getPx(left);\n    element.style.top = getPx(top);\n    element.style.right = getPx(right);\n    element.style.bottom = getPx(bottom);\n    element.style.width = getPx(width);\n    element.style.height = getPx(height);\n}\n\nfunction getPx(value: number): string {\n    return value === undefined ? null : value + 'px';\n}\n\nfunction getEditElements(wrapper: HTMLElement, elementClass: ImageEditElementClass): HTMLElement[] {\n    return toArray(wrapper.querySelectorAll('.' + elementClass)) as HTMLElement[];\n}\n","import getGeneratedImageSize from './getGeneratedImageSize';\nimport ImageEditInfo from '../types/ImageEditInfo';\n\n/**\n * @internal\n * Generate new dataURL from an image and edit info\n * @param image The image to generate data URL from. It is supposed to have original src loaded\n * @param editInfo Edit info of the image\n * @returns A BASE64 encoded string with image prefix that represents the content of the generated image.\n * If there are rotate/crop/resize info in the edit info, the generated image will also reflect the result.\n * It is possible to throw exception since the original image may not be able to read its content from\n * the code, so better check canRegenerateImage() of the image first.\n * @throws Exception when fail to generate dataURL from canvas\n */\nexport default function generateDataURL(image: HTMLImageElement, editInfo: ImageEditInfo): string {\n    const {\n        angleRad: angle,\n        widthPx: width,\n        heightPx: height,\n        bottomPercent: bottom,\n        leftPercent: left,\n        rightPercent: right,\n        topPercent: top,\n        naturalWidth,\n        naturalHeight,\n    } = editInfo;\n    const imageWidth = naturalWidth * (1 - left - right);\n    const imageHeight = naturalHeight * (1 - top - bottom);\n    const canvas = document.createElement('canvas');\n    const { targetWidth, targetHeight } = getGeneratedImageSize(editInfo);\n    canvas.width = targetWidth;\n    canvas.height = targetHeight;\n\n    const context = canvas.getContext('2d');\n    context.translate(targetWidth / 2, targetHeight / 2);\n    context.rotate(angle);\n    context.drawImage(\n        image,\n        naturalWidth * left,\n        naturalHeight * top,\n        imageWidth,\n        imageHeight,\n        -width / 2,\n        -height / 2,\n        width,\n        height\n    );\n\n    return canvas.toDataURL('image/png', 1.0);\n}\n","import ImageEditInfo, { IMAGE_EDIT_INFO_NAME } from '../types/ImageEditInfo';\n\n/**\n * @internal\n * Save edit info to image\n * @param image The image to save edit info to\n * @param editInfo The edit info to save\n */\nexport default function saveEditInfo(image: HTMLImageElement, editInfo: ImageEditInfo) {\n    if (image) {\n        image.dataset[IMAGE_EDIT_INFO_NAME] = JSON.stringify(editInfo);\n    }\n}\n","import DragAndDropContext, { X, Y } from '../types/DragAndDropContext';\nimport DragAndDropHandler from '../../../pluginUtils/DragAndDropHandler';\nimport { CreateElementData } from 'roosterjs-editor-types';\nimport { CropInfo } from '../types/ImageEditInfo';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { rotateCoordinate } from './Resizer';\n\nconst CROP_HANDLE_SIZE = 22;\nconst CROP_HANDLE_WIDTH = 7;\nconst Xs: X[] = ['w', 'e'];\nconst Ys: Y[] = ['s', 'n'];\nconst ROTATION: Record<string, number> = {\n    sw: 0,\n    nw: 90,\n    ne: 180,\n    se: 270,\n};\n\n/**\n * Crop handle for DragAndDropHelper\n */\nconst Cropper: DragAndDropHandler<DragAndDropContext, CropInfo> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ editInfo, x, y, options }, e, base, dx, dy) => {\n        [dx, dy] = rotateCoordinate(dx, dy, editInfo.angleRad);\n\n        const {\n            widthPx,\n            heightPx,\n            leftPercent,\n            rightPercent,\n            topPercent,\n            bottomPercent,\n        } = editInfo;\n        const { minWidth, minHeight } = options;\n        const widthPercent = 1 - leftPercent - rightPercent;\n        const heightPercent = 1 - topPercent - bottomPercent;\n\n        if (widthPercent > 0 && heightPercent > 0) {\n            const fullWidth = widthPx / widthPercent;\n            const fullHeight = heightPx / heightPercent;\n            const newLeft =\n                x != 'e'\n                    ? crop(base.leftPercent, dx, fullWidth, rightPercent, minWidth)\n                    : leftPercent;\n            const newRight =\n                x != 'w'\n                    ? crop(base.rightPercent, -dx, fullWidth, leftPercent, minWidth)\n                    : rightPercent;\n            const newTop =\n                y != 's'\n                    ? crop(base.topPercent, dy, fullHeight, bottomPercent, minHeight)\n                    : topPercent;\n            const newBottom =\n                y != 'n'\n                    ? crop(base.bottomPercent, -dy, fullHeight, topPercent, minHeight)\n                    : bottomPercent;\n\n            editInfo.leftPercent = newLeft;\n            editInfo.rightPercent = newRight;\n            editInfo.topPercent = newTop;\n            editInfo.bottomPercent = newBottom;\n            editInfo.widthPx = fullWidth * (1 - newLeft - newRight);\n            editInfo.heightPx = fullHeight * (1 - newTop - newBottom);\n\n            return true;\n        } else {\n            return false;\n        }\n    },\n};\n\nfunction crop(\n    basePercentage: number,\n    deltaValue: number,\n    fullValue: number,\n    currentPercentage: number,\n    minValue: number\n): number {\n    const maxValue = fullValue * (1 - currentPercentage) - minValue;\n    const newValue = fullValue * basePercentage + deltaValue;\n    const validValue = Math.max(Math.min(newValue, maxValue), 0);\n    return validValue / fullValue;\n}\n\n/**\n * @internal\n */\nexport default Cropper;\n\n/**\n * @internal\n * Get HTML for crop elements, including 4 overlays (to show dark shadow), 1 container and 4 crop handles\n */\nexport function getCropHTML(): CreateElementData[] {\n    const overlayHTML: CreateElementData = {\n        tag: 'div',\n        style: 'position:absolute;background-color:rgb(0,0,0,0.5);pointer-events:none',\n        className: ImageEditElementClass.CropOverlay,\n    };\n    const containerHTML: CreateElementData = {\n        tag: 'div',\n        style: 'position:absolute;overflow:hidden',\n        className: ImageEditElementClass.CropContainer,\n        children: [],\n    };\n\n    Xs.forEach(x => Ys.forEach(y => containerHTML.children.push(getCropHTMLInternal(x, y))));\n\n    return [containerHTML, overlayHTML, overlayHTML, overlayHTML, overlayHTML];\n}\n\nfunction getCropHTMLInternal(x: X, y: Y): CreateElementData {\n    const leftOrRight = x == 'w' ? 'left' : 'right';\n    const topOrBottom = y == 'n' ? 'top' : 'bottom';\n    const rotation = ROTATION[y + x];\n\n    return {\n        tag: 'div',\n        className: ImageEditElementClass.CropHandle,\n        style: `position:absolute;pointer-events:auto;cursor:${y}${x}-resize;${leftOrRight}:0;${topOrBottom}:0;width:${CROP_HANDLE_SIZE}px;height:${CROP_HANDLE_SIZE}px;transform:rotate(${rotation}deg)`,\n        dataset: { x, y },\n        children: getCropHandleHTML(),\n    };\n}\n\nfunction getCropHandleHTML(): CreateElementData[] {\n    const result: CreateElementData[] = [];\n    [0, 1].forEach(layer =>\n        [0, 1].forEach(dir => {\n            result.push(getCropHandleHTMLInternal(layer, dir));\n        })\n    );\n    return result;\n}\n\nfunction getCropHandleHTMLInternal(layer: number, dir: number): CreateElementData {\n    const position =\n        dir == 0\n            ? `right:${layer}px;height:${CROP_HANDLE_WIDTH - layer * 2}px;`\n            : `top:${layer}px;width:${CROP_HANDLE_WIDTH - layer * 2}px;`;\n    const bgColor = layer == 0 ? 'white' : 'black';\n\n    return {\n        tag: 'div',\n        style: `position:absolute;left:${layer}px;bottom:${layer}px;${position};background-color:${bgColor}`,\n    };\n}\n","import DragAndDropHandler from './DragAndDropHandler';\n\n/**\n * @internal\n * A helper class to help manage drag and drop to an HTML element\n */\nexport default class DragAndDropHelper<TContext, TInitValue> {\n    private initX: number;\n    private initY: number;\n    private initValue: TInitValue;\n\n    /**\n     * Create a new instance of DragAndDropHelper class\n     * @param trigger The trigger element. When user start drag on this element,\n     * events will be fired to the handler object\n     * @param context Context object that will be passed to handler function when event is fired,\n     * so that the handler object knows which element it is triggered from.\n     * @param onSubmit A callback that will be invoked when event handler in handler object returns true\n     * @param handler The event handler object, see DragAndDropHandler interface for more information\n     */\n    constructor(\n        private trigger: HTMLElement,\n        private context: TContext,\n        private onSubmit: (context: TContext) => void,\n        private handler: DragAndDropHandler<TContext, TInitValue>\n    ) {\n        trigger.addEventListener('mousedown', this.onMouseDown);\n    }\n\n    /**\n     * Dispose this object, remove all event listeners that has been attached\n     */\n    dispose() {\n        this.trigger.removeEventListener('mousedown', this.onMouseDown);\n        this.removeDocumentEvents();\n    }\n\n    private addDocumentEvents() {\n        const doc = this.trigger.ownerDocument;\n        doc.addEventListener('mousemove', this.onMouseMove, true /*useCapture*/);\n        doc.addEventListener('mouseup', this.onMouseUp, true /*useCapture*/);\n    }\n\n    private removeDocumentEvents() {\n        const doc = this.trigger.ownerDocument;\n        doc.removeEventListener('mousemove', this.onMouseMove, true /*useCapture*/);\n        doc.removeEventListener('mouseup', this.onMouseUp, true /*useCapture*/);\n    }\n\n    private onMouseDown = (e: MouseEvent) => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.addDocumentEvents();\n\n        this.initX = e.pageX;\n        this.initY = e.pageY;\n        this.initValue = this.handler.onDragStart?.(this.context, e);\n    };\n\n    private onMouseMove = (e: MouseEvent) => {\n        e.preventDefault();\n        const deltaX = e.pageX - this.initX;\n        const deltaY = e.pageY - this.initY;\n        if (this.handler.onDragging?.(this.context, e, this.initValue, deltaX, deltaY)) {\n            this.onSubmit?.(this.context);\n        }\n    };\n\n    private onMouseUp = (e: MouseEvent) => {\n        e.preventDefault();\n        this.removeDocumentEvents();\n\n        if (this.handler.onDragEnd?.(this.context, e, this.initValue)) {\n            this.onSubmit?.(this.context);\n        }\n    };\n}\n","import DragAndDropContext from '../types/DragAndDropContext';\nimport DragAndDropHandler from '../../../pluginUtils/DragAndDropHandler';\nimport ImageHtmlOptions from '../types/ImageHtmlOptions';\nimport { CreateElementData } from 'roosterjs-editor-types';\nimport { ImageEditElementClass } from '../types/ImageEditElementClass';\nimport { RotateInfo } from '../types/ImageEditInfo';\n\n/**\n * @internal Size of rotate icon\n */\nexport const ROTATE_SIZE = 32;\n\n/**\n * @internal Gap between image and the rotate handle\n */\nexport const ROTATE_GAP = 15;\n\nconst DEG_PER_RAD = 180 / Math.PI;\nconst DEFAULT_ROTATE_HANDLE_HEIGHT = ROTATE_SIZE / 2 + ROTATE_GAP;\nconst ROTATE_ICON_MARGIN = 8;\n\n/**\n * The rotate drag and drop handler\n */\nconst Rotator: DragAndDropHandler<DragAndDropContext, RotateInfo> = {\n    onDragStart: ({ editInfo }) => ({ ...editInfo }),\n    onDragging: ({ editInfo, options }, e, base, deltaX, deltaY) => {\n        const distance = editInfo.heightPx / 2 + DEFAULT_ROTATE_HANDLE_HEIGHT;\n        const newX = distance * Math.sin(base.angleRad) + deltaX;\n        const newY = distance * Math.cos(base.angleRad) - deltaY;\n        let angleInRad = Math.atan2(newX, newY);\n\n        if (!e.altKey) {\n            const angleInDeg = angleInRad * DEG_PER_RAD;\n            const adjustedAngleInDeg =\n                Math.round(angleInDeg / options.minRotateDeg) * options.minRotateDeg;\n            angleInRad = adjustedAngleInDeg / DEG_PER_RAD;\n        }\n\n        if (editInfo.angleRad != angleInRad) {\n            editInfo.angleRad = angleInRad;\n            return true;\n        } else {\n            return false;\n        }\n    },\n};\n\n/**\n * @internal\n */\nexport default Rotator;\n\n/**\n * @internal\n * Get HTML for rotate elements, including the rotate handle with icon, and a line between the handle and the image\n */\nexport function getRotateHTML({\n    borderColor,\n    rotateHandleBackColor,\n}: ImageHtmlOptions): CreateElementData[] {\n    const handleLeft = ROTATE_SIZE / 2;\n    return [\n        {\n            tag: 'div',\n            className: ImageEditElementClass.RotateCenter,\n            style: `position:absolute;left:50%;width:1px;background-color:${borderColor}`,\n            children: [\n                {\n                    tag: 'div',\n                    className: ImageEditElementClass.RotateHandle,\n                    style: `position:absolute;background-color:${rotateHandleBackColor};border:solid 1px ${borderColor};border-radius:50%;width:${ROTATE_SIZE}px;height:${ROTATE_SIZE}px;left:-${handleLeft}px;cursor:move`,\n                    children: [getRotateIconHTML(borderColor)],\n                },\n            ],\n        },\n    ];\n}\n\nfunction getRotateIconHTML(borderColor: string): CreateElementData {\n    return {\n        tag: 'svg',\n        namespace: 'http://www.w3.org/2000/svg',\n        style: `width:16px;height:16px;margin: ${ROTATE_ICON_MARGIN}px ${ROTATE_ICON_MARGIN}px`,\n        children: [\n            {\n                tag: 'path',\n                namespace: 'http://www.w3.org/2000/svg',\n                attributes: {\n                    d: 'M 10.5,10.0 A 3.8,3.8 0 1 1 6.7,6.3',\n                    transform: 'matrix(1.1 1.1 -1.1 1.1 11.6 -10.8)',\n                    ['fill-opacity']: '0',\n                    stroke: borderColor,\n                },\n            },\n            {\n                tag: 'path',\n                namespace: 'http://www.w3.org/2000/svg',\n                attributes: {\n                    d: 'M12.0 3.648l.884-.884.53 2.298-2.298-.53z',\n                    stroke: borderColor,\n                },\n            },\n        ],\n    };\n}\n","import applyChange from '../editInfoUtils/applyChange';\nimport getEditInfoFromImage from '../editInfoUtils/getEditInfoFromImage';\nimport getTargetSizeByPercentage from '../editInfoUtils/getTargetSizeByPercentage';\nimport isResizedTo from './isResizedTo';\nimport { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Resize the image by percentage of its natural size. If the image is cropped or rotated,\n * the final size will also calculated with crop and rotate info.\n * @param editor The editor that contains the image\n * @param image The image to resize\n * @param percentage Percentage to resize to\n * @param minWidth Minimum width\n * @param minHeight Minimum height\n */\nexport default function resizeByPercentage(\n    editor: IEditor,\n    image: HTMLImageElement,\n    percentage: number,\n    minWidth: number,\n    minHeight: number\n) {\n    const editInfo = getEditInfoFromImage(image);\n\n    if (!isResizedTo(image, percentage)) {\n        loadImage(image, editInfo.src, () => {\n            if (!editor.isDisposed() && editor.contains(image)) {\n                const lastSrc = image.src;\n                const { width, height } = getTargetSizeByPercentage(editInfo, percentage);\n                editInfo.widthPx = Math.max(width, minWidth);\n                editInfo.heightPx = Math.max(height, minHeight);\n\n                editor.addUndoSnapshot(() => {\n                    applyChange(editor, image, editInfo, lastSrc);\n                }, ChangeSource.ImageResize);\n            }\n        });\n    }\n}\n\nfunction loadImage(img: HTMLImageElement, src: string, callback: () => void) {\n    img.onload = () => {\n        img.onload = null;\n        img.onerror = null;\n        callback();\n    };\n    img.onerror = () => {\n        img.onload = null;\n        img.onerror = null;\n        callback();\n    };\n    img.src = src;\n}\n","import deleteEditInfo from '../editInfoUtils/deleteEditInfo';\nimport { ChangeSource, IEditor } from 'roosterjs-editor-types';\n\n/**\n * Remove explicit width & height attributes on the image element.\n * @param editor The editor that contains the image\n * @param image The image to remove w/h from\n */\nexport default function resetImage(editor: IEditor, image: HTMLImageElement) {\n    editor.addUndoSnapshot(() => {\n        image.style.width = '';\n        image.style.height = '';\n        image.style.maxWidth = '100%';\n        image.removeAttribute('width');\n        image.removeAttribute('height');\n        deleteEditInfo(image);\n    }, ChangeSource.ImageResize);\n}\n","import { ImageEdit } from './ImageEdit';\nimport { ImageEditOperation } from 'roosterjs-editor-types';\n\n/**\n * @deprecated Use ImageEdit plugin instead\n */\nexport class ImageResize extends ImageEdit {\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        minWidth: number = 10,\n        minHeight: number = 10,\n        selectionBorderColor: string = '#DB626C',\n        forcePreserveRatio: boolean = false,\n        resizableImageSelector: string = 'img'\n    ) {\n        super({\n            minHeight,\n            minWidth,\n            borderColor: selectionBorderColor,\n            preserveRatio: forcePreserveRatio,\n            imageSelector: resizableImageSelector,\n        });\n    }\n\n    /**\n     * @deprecated\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.setEditingImage(img, ImageEditOperation.Resize);\n    }\n\n    /**\n     * @deprecated\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        this.setEditingImage(null /*image*/, selectImageAfterUnSelect);\n    }\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin } from './PickerPlugin';\n","import { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    Browser,\n    createRange,\n    isCharacterValue,\n    isModifierKey,\n    PartialInlineElement,\n} from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    EditorPlugin,\n    IEditor,\n    NodePosition,\n    PickerDataProvider,\n    PickerPluginOptions,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHAR_CODE = 'Backspace';\nconst TAB_CHAR_CODE = 'Tab';\nconst ENTER_CHAR_CODE = 'Enter';\nconst ESC_CHAR_CODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHAR_CODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHAR_CODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHAR_CODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHAR_CODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHAR_CODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPlugin {\n    private editor: IEditor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: IEditor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                this.editor.addUndoSnapshot(\n                    insertNode,\n                    this.pickerOptions.changeSource,\n                    this.pickerOptions.handleAutoComplete\n                );\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undo and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = this.editor.getContentSearcherOfCursor(event);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        positionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHAR_CODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {\n                // #483: If we are backspacing over the trigger character that triggered this Picker\n                // then we need to hide the Picker\n                const wordBeforeCursor = this.getWord(event);\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\n                    this.setIsSuggesting(false);\n                }\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHAR_CODE ||\n                      keyboardEvent.key == RIGHT_ARROW_CHAR_CODE\n                    : keyboardEvent.key == UP_ARROW_CHAR_CODE ||\n                      keyboardEvent.key == DOWN_ARROW_CHAR_CODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHAR_CODE\n                        : keyboardEvent.key == DOWN_ARROW_CHAR_CODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHAR_CODE || keyboardEvent.key == TAB_CHAR_CODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHAR_CODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHAR_CODE) {\n                let searcher = this.editor.getContentSearcherOfCursor(event);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(editor => {\n                        editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = this.editor.getContentSearcherOfCursor(event);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { createElement, getComputedStyle, normalizeRect, VTable } from 'roosterjs-editor-dom';\nimport {\n    EditorPlugin,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    Rect,\n    ChangeSource,\n    TableOperation,\n    ContentPosition,\n    CreateElementData,\n    KnownCreateElementDataIndex,\n} from 'roosterjs-editor-types';\n\nconst INSERTER_COLOR = '#4A4A4A';\nconst INSERTER_COLOR_DARK_MODE = 'white';\nconst INSERTER_SIDE_LENGTH = 12;\nconst INSERTER_BORDER_SIZE = 1;\nconst INSERTER_HOVER_OFFSET = 5;\nconst MIN_CELL_WIDTH = 30;\nconst MIN_CELL_HEIGHT = 20;\nconst CELL_RESIZER_WIDTH = 4;\nconst TABLE_RESIZER_LENGTH = 12;\n\nconst enum ResizeState {\n    None,\n    Horizontal,\n    Vertical,\n    Both, // when resizing the whole table\n}\n\nfunction getHorizontalDistance(rect: Rect, pos: number, toLeft: boolean): number {\n    return toLeft ? pos - rect.left : rect.right - pos;\n}\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: IEditor;\n    private onMouseMoveDisposer: () => void;\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\n    private resizerContainer: HTMLDivElement;\n    private tableResizerContainer: HTMLDivElement;\n    private currentTable: HTMLTableElement;\n    private currentTd: HTMLTableCellElement;\n    private currentCellsToResize: HTMLTableCellElement[] = [];\n    private nextCellsToResize: HTMLTableCellElement[] = [];\n    private horizontalResizer: HTMLDivElement;\n    private verticalResizer: HTMLDivElement;\n    private tableResizer: HTMLDivElement;\n    private resizingState: ResizeState = ResizeState.None;\n\n    private currentInsertTd: HTMLTableCellElement;\n    private insertingState: ResizeState = ResizeState.None;\n    private inserter: HTMLDivElement;\n    private isRTL: boolean;\n\n    private currentTableVerticalBorder: number;\n    private currentTableHorizontalBorder: number;\n    private resizingVtable: VTable;\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.setupResizerContainer();\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.onMouseMoveDisposer();\n        this.tableRectMap = null;\n        this.removeResizerContainer();\n        this.setCurrentTable(null);\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        switch (e.eventType) {\n            case PluginEventType.Input:\n            case PluginEventType.ContentChanged:\n            case PluginEventType.Scroll:\n                this.setTableResizer(null);\n                this.tableRectMap = null;\n                break;\n        }\n    }\n\n    private setupResizerContainer() {\n        const document = this.editor.getDocument();\n        this.resizerContainer = document.createElement('div');\n        this.editor.insertNode(this.resizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n\n        this.tableResizerContainer = document.createElement('div');\n        this.editor.insertNode(this.tableResizerContainer, {\n            updateCursor: false,\n            insertOnNewLine: false,\n            replaceSelection: false,\n            position: ContentPosition.Outside,\n        });\n    }\n\n    private removeResizerContainer() {\n        this.resizerContainer?.parentNode?.removeChild(this.resizerContainer);\n        this.resizerContainer = null;\n        this.tableResizerContainer?.parentNode?.removeChild(this.tableResizerContainer);\n        this.tableResizerContainer = null;\n    }\n\n    private onMouseOutInserter = () => {\n        this.setCurrentInsertTd(ResizeState.None);\n    };\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (this.resizingState != ResizeState.None) {\n            return;\n        }\n\n        if (!this.tableRectMap) {\n            this.cacheRects();\n        }\n\n        if (this.tableRectMap) {\n            this.setCurrentTable(null);\n\n            for (let i = this.tableRectMap.length - 1; i >= 0; i--) {\n                const { table, rect } = this.tableRectMap[i];\n\n                if (\n                    e.pageX <=\n                        rect.right + (this.isRTL ? INSERTER_SIDE_LENGTH : TABLE_RESIZER_LENGTH) &&\n                    e.pageX >=\n                        rect.left - (this.isRTL ? TABLE_RESIZER_LENGTH : INSERTER_SIDE_LENGTH) &&\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\n                    e.pageY <= rect.bottom + TABLE_RESIZER_LENGTH\n                ) {\n                    this.setCurrentTable(table);\n                    break;\n                }\n            }\n\n            if (this.currentTable) {\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\n                this.setTableResizer(map.rect);\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\n                    const tr = this.currentTable.rows[i];\n                    let j = 0;\n                    for (; j < tr.cells.length; j++) {\n                        const td = tr.cells[j];\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\n\n                        if (\n                            tdRect &&\n                            (this.isRTL ? e.pageX >= tdRect.left : e.pageX <= tdRect.right) &&\n                            e.pageY <= tdRect.bottom\n                        ) {\n                            // check vertical inserter\n                            if (\n                                i == 0 &&\n                                e.pageY >= tdRect.top - INSERTER_HOVER_OFFSET &&\n                                e.pageY <= tdRect.top + INSERTER_HOVER_OFFSET\n                            ) {\n                                let verticalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (\n                                    this.isRTL\n                                        ? e.pageX <=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                        : e.pageX >=\n                                          tdRect.left + (tdRect.right - tdRect.left) / 2.0\n                                ) {\n                                    verticalInserterTd = td;\n                                } else if (\n                                    this.isRTL ? e.pageX <= tdRect.right : e.pageX >= tdRect.left\n                                ) {\n                                    // set inserter at previous td if it exists\n                                    const preTd = td.previousElementSibling as HTMLTableCellElement;\n                                    if (preTd) {\n                                        verticalInserterTd = preTd;\n                                    }\n                                }\n                                if (verticalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    // we hide the inserter if left mouse button is pressed\n                                    if (e.buttons == 0) {\n                                        this.setCurrentInsertTd(\n                                            ResizeState.Vertical,\n                                            verticalInserterTd,\n                                            map.rect\n                                        );\n                                    }\n                                    break;\n                                }\n                                // check horizontal inserter\n                            } else if (\n                                j == 0 &&\n                                (this.isRTL\n                                    ? e.pageX >= tdRect.right - INSERTER_HOVER_OFFSET\n                                    : e.pageX <= tdRect.left + INSERTER_HOVER_OFFSET)\n                            ) {\n                                let horizontalInserterTd: HTMLTableCellElement = null;\n                                // set inserter at current td\n                                if (e.pageY >= tdRect.top + (tdRect.bottom - tdRect.top) / 2.0) {\n                                    horizontalInserterTd = td;\n                                } else if (e.pageY >= tdRect.top) {\n                                    // set insert at previous td if it exists\n                                    const preTd = this.currentTable.rows[i - 1]?.cells[0];\n                                    if (preTd) {\n                                        horizontalInserterTd = preTd;\n                                    }\n                                }\n\n                                if (horizontalInserterTd) {\n                                    this.setCurrentTd(null);\n                                    // we hide the inserter if left mouse button is pressed\n                                    if (e.buttons == 0) {\n                                        this.setCurrentInsertTd(\n                                            ResizeState.Horizontal,\n                                            horizontalInserterTd,\n                                            map.rect\n                                        );\n                                    }\n                                    break;\n                                }\n                            } else {\n                                this.setCurrentTd(\n                                    td,\n                                    map.rect,\n                                    this.isRTL ? tdRect.left : tdRect.right,\n                                    tdRect.bottom\n                                );\n                                this.setCurrentInsertTd(ResizeState.None);\n                                break;\n                            }\n                        }\n                    }\n                    if (j < tr.cells.length) {\n                        break;\n                    }\n                }\n            } else {\n                this.setTableResizer(null);\n            }\n        }\n    };\n\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td: HTMLTableCellElement,\n        tableRect: Rect\n    ): void;\n    private setCurrentInsertTd(\n        insertingState: ResizeState,\n        td?: HTMLTableCellElement,\n        tableRect?: Rect\n    ) {\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\n            if (this.currentInsertTd) {\n                this.inserter?.parentNode?.removeChild(this.inserter);\n                this.inserter = null;\n            }\n            this.insertingState = insertingState;\n            this.currentInsertTd = td;\n            if (this.currentInsertTd) {\n                this.inserter = this.createInserter(tableRect);\n                this.resizerContainer.appendChild(this.inserter);\n            }\n        }\n    }\n\n    private createInserter(tableRect: Rect) {\n        if (this.insertingState == ResizeState.None) {\n            return;\n        }\n\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\n        const inserterColor = this.editor.isDarkMode() ? INSERTER_COLOR_DARK_MODE : INSERTER_COLOR;\n        const leftOrRight = this.isRTL ? 'right' : 'left';\n        const outerDivStyle = `position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${inserterColor}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${inserterColor}; border-radius: 50%; background-color: ${inserterBackgroundColor}`;\n        const HORIZONTAL_INSERTER: CreateElementData = {\n            tag: 'div',\n            style: outerDivStyle,\n            children: [\n                {\n                    tag: 'div',\n                    style: `position: absolute; ${leftOrRight}: 12px; top: 5px; height: 3px; border-top: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};`,\n                },\n                '+',\n            ],\n        };\n        const VERTICAL_INSERTER: CreateElementData = {\n            tag: 'div',\n            style: outerDivStyle,\n            children: [\n                {\n                    tag: 'div',\n                    style: `position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${inserterColor}; border-right: 1px solid ${inserterColor}; border-bottom: 1px solid ${inserterColor}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor}`,\n                },\n                '+',\n            ],\n        };\n\n        const inserter = createElement(\n            this.insertingState == ResizeState.Horizontal ? HORIZONTAL_INSERTER : VERTICAL_INSERTER,\n            this.editor.getDocument()\n        ) as HTMLDivElement;\n\n        if (rect) {\n            if (this.insertingState == ResizeState.Horizontal) {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.right}px`;\n                } else {\n                    inserter.style.left = `${\n                        rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                    }px`;\n                }\n                inserter.style.top = `${rect.bottom - 8}px`;\n                (inserter.firstChild as HTMLElement).style.width = `${\n                    tableRect.right - tableRect.left\n                }px`;\n            } else {\n                if (this.isRTL) {\n                    inserter.style.left = `${rect.left - 8}px`;\n                } else {\n                    inserter.style.left = `${rect.right - 8}px`;\n                }\n                inserter.style.top = `${\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\n                }px`;\n                (inserter.firstChild as HTMLElement).style.height = `${\n                    tableRect.bottom - tableRect.top\n                }px`;\n            }\n        }\n\n        inserter.addEventListener('click', this.insertTd);\n        inserter.addEventListener('mouseout', this.onMouseOutInserter);\n\n        return inserter;\n    }\n\n    private insertTd = () => {\n        let vtable = new VTable(this.currentInsertTd);\n        if (this.insertingState === ResizeState.Vertical) {\n            vtable.normalizeTableCellSize();\n            // Since adding new column will cause table width to change, we need to remove width properties\n            vtable.table.removeAttribute('width');\n            vtable.table.style.width = null;\n        }\n        this.editor.addUndoSnapshot((start, end) => {\n            vtable.edit(\n                this.insertingState == ResizeState.Horizontal\n                    ? TableOperation.InsertBelow\n                    : TableOperation.InsertRight\n            );\n            vtable.writeBack();\n            this.editor.select(start, end);\n            this.setCurrentInsertTd(ResizeState.None);\n            // need to update the position of table resizer as new row/column has been added\n            if (this.currentTable) {\n                const rect = normalizeRect(this.currentTable.getBoundingClientRect());\n                this.setTableResizer(rect);\n            }\n        }, ChangeSource.Format);\n    };\n\n    private setCurrentTable(table: HTMLTableElement) {\n        if (this.currentTable != table) {\n            this.setCurrentTd(null);\n            this.setCurrentInsertTd(ResizeState.None);\n            this.currentTable = table;\n        }\n    }\n\n    private setCurrentTd(td: null): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect: Rect,\n        resizerPosX: number,\n        bottom: number\n    ): void;\n    private setCurrentTd(\n        td: HTMLTableCellElement,\n        tableRect?: Rect,\n        resizerPosX?: number,\n        bottom?: number\n    ) {\n        if (this.currentTd != td) {\n            if (this.currentTd) {\n                this.horizontalResizer?.parentNode?.removeChild(this.horizontalResizer);\n                this.verticalResizer?.parentNode?.removeChild(this.verticalResizer);\n                this.horizontalResizer = null;\n                this.verticalResizer = null;\n            }\n\n            this.currentTd = td;\n\n            if (this.currentTd) {\n                this.horizontalResizer = this.createCellsResizer(\n                    true /*horizontal*/,\n                    tableRect.left,\n                    bottom - CELL_RESIZER_WIDTH + 1,\n                    tableRect.right - tableRect.left,\n                    CELL_RESIZER_WIDTH\n                );\n                this.verticalResizer = this.createCellsResizer(\n                    false /*horizontal*/,\n                    resizerPosX - CELL_RESIZER_WIDTH + 1,\n                    tableRect.top,\n                    CELL_RESIZER_WIDTH,\n                    tableRect.bottom - tableRect.top\n                );\n\n                this.resizerContainer.appendChild(this.horizontalResizer);\n                this.resizerContainer.appendChild(this.verticalResizer);\n            }\n        }\n    }\n\n    private setTableResizer(rect: Rect | null): void {\n        // remove old one if exists\n        while (this.tableResizerContainer?.hasChildNodes()) {\n            this.tableResizerContainer.removeChild(this.tableResizerContainer.lastChild);\n        }\n        this.tableResizer = null;\n        // add new one if exists\n        if (rect) {\n            this.tableResizer = this.createTableResizer(rect);\n            this.tableResizerContainer.appendChild(this.tableResizer);\n        }\n    }\n\n    private createTableResizer(rect: Rect): HTMLDivElement {\n        const div = createElement(\n            this.isRTL\n                ? KnownCreateElementDataIndex.TableResizerRTL\n                : KnownCreateElementDataIndex.TableResizerLTR,\n            this.editor.getDocument()\n        ) as HTMLDivElement;\n\n        div.style.top = `${rect.bottom}px`;\n        div.style.left = this.isRTL\n            ? `${rect.left - TABLE_RESIZER_LENGTH - 2}px`\n            : `${rect.right}px`;\n        div.style.width = `${TABLE_RESIZER_LENGTH}px`;\n        div.style.height = `${TABLE_RESIZER_LENGTH}px`;\n\n        div.addEventListener('mousedown', this.startResizingTable);\n\n        return div;\n    }\n\n    private createCellsResizer(\n        horizontal: boolean,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ): HTMLDivElement {\n        const div = createElement(\n            horizontal\n                ? KnownCreateElementDataIndex.TableHorizontalResizer\n                : KnownCreateElementDataIndex.TableVerticalResizer,\n            this.editor.getDocument()\n        ) as HTMLDivElement;\n        div.style.top = `${top}px`;\n        div.style.left = `${left}px`;\n        div.style.width = `${width}px`;\n        div.style.height = `${height}px`;\n\n        div.addEventListener(\n            'mousedown',\n            horizontal ? this.startHorizontalResizeCells : this.startVerticalResizeCells\n        );\n\n        return div;\n    }\n\n    private startResizingTable = (e: MouseEvent) => {\n        if (!this.currentTable) {\n            return;\n        }\n        this.resizingVtable = new VTable(\n            this.currentTable,\n            true /* normalize the table for resizing */\n        );\n        this.resizingState = ResizeState.Both;\n\n        const rect = this.resizingVtable.table.getBoundingClientRect();\n        this.currentTableVerticalBorder = this.isRTL ? rect.left : rect.right;\n        this.currentTableHorizontalBorder = rect.bottom;\n\n        this.startResizeCells(e);\n    };\n\n    private startHorizontalResizeCells = (e: MouseEvent) => {\n        if (!this.currentTd) {\n            return;\n        }\n        this.resizingVtable = new VTable(\n            this.currentTd,\n            true /* normalize the table for resizing */\n        );\n        this.resizingState = ResizeState.Horizontal;\n        this.startResizeCells(e);\n    };\n\n    private startVerticalResizeCells = (e: MouseEvent) => {\n        if (!this.currentTd) {\n            return;\n        }\n        this.resizingVtable = new VTable(\n            this.currentTd,\n            true /* normalize the table for resizing */\n        );\n        this.resizingState = ResizeState.Vertical;\n        if (this.resizingVtable) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n\n            // calculate and retrieve the cells of the two columns shared by the current vertical resizer\n            this.currentCellsToResize = this.resizingVtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                !this.isRTL\n            );\n\n            this.nextCellsToResize = this.resizingVtable.getCellsWithBorder(\n                this.isRTL ? rect.left : rect.right,\n                this.isRTL\n            );\n        }\n        this.startResizeCells(e);\n    };\n\n    private startResizeCells(e: MouseEvent) {\n        const doc = this.editor.getDocument();\n        doc.addEventListener('mousemove', this.frameAnimateResizeCells, true);\n        doc.addEventListener('mouseup', this.endResizeCells, true);\n    }\n\n    private frameAnimateResizeCells = (e: MouseEvent) => {\n        this.editor.runAsync(() => this.resizeCells(e));\n    };\n\n    private resizeTable = (mouseX: number, mouseY: number) => {\n        const rect = normalizeRect(this.resizingVtable.table.getBoundingClientRect());\n        const ratioX =\n            1.0 +\n            (this.isRTL\n                ? (this.currentTableVerticalBorder - mouseX) /\n                  (rect.right - this.currentTableVerticalBorder)\n                : (mouseX - this.currentTableVerticalBorder) /\n                  (this.currentTableVerticalBorder - rect.left));\n        const ratioY =\n            1.0 +\n            (mouseY - this.currentTableHorizontalBorder) /\n                (this.currentTableHorizontalBorder - rect.top);\n\n        const shouldResizeX = Math.abs(ratioX - 1.0) > 1e-3;\n        const shouldResizeY = Math.abs(ratioY - 1.0) > 1e-3;\n        if (shouldResizeX || shouldResizeY) {\n            for (let i = 0; i < this.resizingVtable.cells.length; i++) {\n                for (let j = 0; j < this.resizingVtable.cells[i].length; j++) {\n                    const cell = this.resizingVtable.cells[i][j];\n                    if (cell.td) {\n                        if (shouldResizeX) {\n                            // the width of some external table is fixed, we need to make it resizable\n                            this.resizingVtable.table.style.width = null;\n                            const newWidth = cell.width * ratioX;\n                            cell.td.style.boxSizing = 'border-box';\n                            if (newWidth >= MIN_CELL_WIDTH) {\n                                cell.td.style.wordBreak = 'break-word';\n                                cell.td.style.whiteSpace = 'normal';\n                                cell.td.style.width = `${newWidth}px`;\n                            }\n                        }\n\n                        if (shouldResizeY) {\n                            // the height of some external table is fixed, we need to make it resizable\n                            this.resizingVtable.table.style.height = null;\n                            if (j == 0) {\n                                const newHeight = cell.height * ratioY;\n                                if (newHeight >= MIN_CELL_HEIGHT) {\n                                    cell.td.style.height = `${newHeight}px`;\n                                }\n                            } else {\n                                cell.td.style.height = null;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return;\n    };\n\n    private resizeRows = (newPos: number, rect: Rect) => {\n        this.resizingVtable.table.removeAttribute('height');\n        this.resizingVtable.table.style.height = null;\n        this.resizingVtable.forEachCellOfCurrentRow(cell => {\n            if (cell.td) {\n                cell.td.style.height = cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\n            }\n        });\n    };\n\n    private canResizeColumns = (newPos: number): boolean => {\n        for (let i = 0; i < this.currentCellsToResize.length; i++) {\n            const td = this.currentCellsToResize[i];\n            const rect = normalizeRect(td.getBoundingClientRect());\n            const width = getHorizontalDistance(rect, newPos, !this.isRTL);\n            if (width < MIN_CELL_WIDTH) {\n                return false;\n            }\n        }\n\n        for (let i = 0; i < this.nextCellsToResize.length; i++) {\n            const td = this.nextCellsToResize[i];\n            let width: number = Number.MAX_SAFE_INTEGER;\n            if (td) {\n                const rect = normalizeRect(td.getBoundingClientRect());\n                width = getHorizontalDistance(rect, newPos, this.isRTL);\n            }\n\n            if (width < MIN_CELL_WIDTH) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    private resizeColumns = (newPos: number, isShiftPressed: boolean) => {\n        if (!this.canResizeColumns(newPos)) {\n            return;\n        }\n\n        // Since we allow the user to resize the table width on adjusting the border of the last cell,\n        // we need to make the table width resizable by setting it as null;\n        // We also allow the user to resize the table width if Shift key is pressed\n        const isLastCell: boolean = this.nextCellsToResize.length == 0;\n\n        if (isLastCell || isShiftPressed) {\n            this.resizingVtable.table.style.width = null;\n        }\n\n        this.currentCellsToResize.forEach(td => {\n            const rect = normalizeRect(td.getBoundingClientRect());\n            td.style.wordBreak = 'break-word';\n            td.style.whiteSpace = 'normal';\n            td.style.boxSizing = 'border-box';\n            td.style.width = `${getHorizontalDistance(rect, newPos, !this.isRTL)}px`;\n        });\n\n        this.nextCellsToResize.forEach(td => {\n            if (!isShiftPressed) {\n                td.style.wordBreak = 'break-word';\n                td.style.whiteSpace = 'normal';\n                td.style.boxSizing = 'border-box';\n                td.style.width = null;\n            }\n        });\n    };\n\n    private resizeCells = (e: MouseEvent) => {\n        this.setTableResizer(null);\n        if (this.resizingState === ResizeState.None) {\n            return;\n        } else if (this.resizingState === ResizeState.Both) {\n            this.resizeTable(e.pageX, e.pageY);\n            this.resizingVtable.writeBack();\n        } else if (this.currentTd) {\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\n            if (rect) {\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\n                if (this.resizingState === ResizeState.Horizontal) {\n                    this.resizeRows(newPos, rect);\n                } else {\n                    this.resizeColumns(newPos, e.shiftKey);\n                }\n                this.resizingVtable.writeBack();\n            }\n        }\n    };\n\n    private endResizeCells = (e: MouseEvent) => {\n        const doc = this.editor.getDocument();\n        doc.removeEventListener('mousemove', this.frameAnimateResizeCells, true);\n        doc.removeEventListener('mouseup', this.endResizeCells, true);\n        this.currentCellsToResize = [];\n        this.nextCellsToResize = [];\n\n        this.editor.addUndoSnapshot((start, end) => {\n            this.frameAnimateResizeCells(e);\n            this.editor.select(start, end);\n        }, ChangeSource.Format);\n\n        this.setCurrentTd(null);\n        this.setTableResizer(null);\n\n        this.resizingVtable = null;\n        this.resizingState = ResizeState.None;\n    };\n\n    private cacheRects() {\n        this.tableRectMap = [];\n        this.editor.queryElements('table', table => {\n            if (table.isContentEditable) {\n                const rect = normalizeRect(table.getBoundingClientRect());\n                if (rect) {\n                    this.tableRectMap.push({\n                        table,\n                        rect,\n                    });\n                }\n            }\n        });\n        this.isRTL = getComputedStyle(this.editor.getDocument().body, 'direction') == 'rtl';\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\nimport { insertEntity } from 'roosterjs-editor-api';\nimport {\n    DefaultFormat,\n    EditorPlugin,\n    Entity,\n    EntityOperation,\n    IEditor,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n} from 'roosterjs-editor-types';\n\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: IEditor;\n    private disposer: () => void;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColors: {\n                lightModeColor: '#AAAAAA',\n                darkModeColor: '#6B6B6B',\n            },\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: IEditor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.showHideWatermark,\n            blur: this.showHideWatermark,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            event.eventType == PluginEventType.EditorReady ||\n            (event.eventType == PluginEventType.ContentChanged &&\n                (<Entity>event.data)?.type != ENTITY_TYPE)\n        ) {\n            this.showHideWatermark();\n        } else if (\n            event.eventType == PluginEventType.EntityOperation &&\n            event.entity.type == ENTITY_TYPE\n        ) {\n            const {\n                operation,\n                entity: { wrapper },\n            } = event;\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\n                this.removeWatermark(wrapper);\n            } else if (event.operation == EntityOperation.NewEntity) {\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\n                wrapper.spellcheck = false;\n            }\n        }\n    }\n\n    private showHideWatermark = () => {\n        const hasFocus = this.editor.hasFocus();\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\n        const isShowing = watermarks.length > 0;\n\n        if (hasFocus && isShowing) {\n            watermarks.forEach(this.removeWatermark);\n            this.editor.focus();\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\n            insertEntity(\n                this.editor,\n                ENTITY_TYPE,\n                this.editor.getDocument().createTextNode(this.watermark),\n                false /*isBlock*/,\n                false /*isReadonly*/,\n                ContentPosition.Begin\n            );\n        }\n    };\n\n    private removeWatermark = (wrapper: HTMLElement) => {\n        const parentNode = wrapper.parentNode;\n        parentNode?.removeChild(wrapper);\n\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n        if (\n            this.editor.contains(parentNode) &&\n            getTagOfNode(parentNode) == 'DIV' &&\n            !parentNode.firstChild\n        ) {\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n        }\n    };\n}\n"],"sourceRoot":""}